<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="archerda, ArcherdaArcherda's BlogHexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Archerda&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Archerda&#39;s Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Archerda&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title>Archerda's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Archerda's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Programmer. Meditating.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/24/编程之法-字符串的旋转/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/24/编程之法-字符串的旋转/" itemprop="url">编程之法-字符串的旋转</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-24T00:08:25+08:00">
                2015-12-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个字符串，要求将字符串前面的若干个字符移到字符串的尾部。例如，将字符串“abcdef”的前三个字母‘a’、‘b’和‘c’移到字符串的尾部，那么原字符串将编程“defabc”。请编写一个函数实现此功能。</p>
<h2 id="解法一：蛮力移位"><a href="#解法一：蛮力移位" class="headerlink" title="解法一：蛮力移位"></a>解法一：蛮力移位</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将需要移动的字符一个一个地移动到字符的最后。编写一个leftShiftOne方法，每次将一个字符移动到字符串尾部，然后调用m次这个方法，使得字符串开头的m个字符移到字符串的尾部。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">char</span>[] s = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>&#125;;</div><div class="line">		leftShiftString(s, s.length, <span class="number">3</span>);</div><div class="line">		System.out.println(s);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//移动首部m位字符到最后</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftShiftString</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span> (m &gt; <span class="number">0</span>) &#123;</div><div class="line">			leftShiftOne(s, n);</div><div class="line">			--m;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//移动首位字符到最后</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftShiftOne</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">		<span class="keyword">char</span> t = s[<span class="number">0</span>];</div><div class="line">		</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</div><div class="line">			s[i - <span class="number">1</span>] = s[i];</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		s[n - <span class="number">1</span>] = t;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>针对长度为n的字符串来说，假设需要移动m个字符到字符串的末尾，那么总共需要m*n次操作，同时设立一个变量保存第一个字符。因此时间复杂度是<code>O(mn)</code>, 空间复杂度是<code>O(1)</code>。</p>
<h2 id="解法二：三步反转"><a href="#解法二：三步反转" class="headerlink" title="解法二：三步反转"></a>解法二：三步反转</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>先将一个字符串分割成两个部分，然后将这两个部分的字符串分别反转，最后再对整个字符串整体反转（即三步反转），即可解决字符串旋转的问题。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">char</span>[] s = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>&#125;;</div><div class="line">		leftRotateString(s, s.length, <span class="number">3</span>);</div><div class="line">		System.out.println(s);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//字符串旋转</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftRotateString</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</div><div class="line">		m %= n; <span class="comment">//若要左移动大于n位，那么与移动%n是等价的;</span></div><div class="line">		reverseString(s, <span class="number">0</span>, m - <span class="number">1</span>);</div><div class="line">		reverseString(s, m, n - <span class="number">1</span>);</div><div class="line">		reverseString(s, <span class="number">0</span>, n - <span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//字符串反转</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span> (from &lt; to) &#123;</div><div class="line">			<span class="keyword">char</span> t = s[from];</div><div class="line">			s[from++] = s[to];</div><div class="line">			s[to--] = t;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这个方法的时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code>。</p>
<h2 id="举一反三：单词反转"><a href="#举一反三：单词反转" class="headerlink" title="举一反三：单词反转"></a>举一反三：单词反转</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入一个英文句子，翻转句子中单词的顺序。要求单词内字符的顺序保持不变，句子中单词以空格隔开。为简单起见，标点符号和普通字符一样处理。例如，若输入”I am a student.”，则输出”student. a am I”.</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>先反转每一个单词，再反转整个字符串。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		String str = <span class="string">"My name is luohuida!"</span>;</div><div class="line">		<span class="keyword">char</span>[] chs = leftRotateString(str.toCharArray(), str.length());</div><div class="line">		System.out.println(chs);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//单词翻转</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] leftRotateString(<span class="keyword">char</span>[] s, <span class="keyword">int</span> n) &#123;</div><div class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">		</div><div class="line">		<span class="comment">//先翻转每个单词</span></div><div class="line">		<span class="keyword">for</span> (; j &lt; n; ++j) &#123;</div><div class="line">			<span class="keyword">if</span> (j == n - <span class="number">1</span> || s[j+<span class="number">1</span>] == <span class="string">' '</span>) &#123;</div><div class="line">				reverseString(s, i, j);</div><div class="line">				i = j + <span class="number">2</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		reverseString(s, <span class="number">0</span>, n - <span class="number">1</span>);</div><div class="line"></div><div class="line">		<span class="keyword">return</span> s;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//字符串反转</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span> (from &lt; to) &#123;</div><div class="line">			<span class="keyword">char</span> t = s[from];</div><div class="line">			s[from++] = s[to];</div><div class="line">			s[to--] = t;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>时间复杂度<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="">《编程之法》</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/05/设计模式-六大设计原则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/05/设计模式-六大设计原则/" itemprop="url">【Repost】设计模式-六大设计原则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-05T17:30:36+08:00">
                2015-12-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文转载自<a href="http://www.devtf.cn/?p=1134" target="_blank" rel="external">开发技术前线：面向对象六大原则</a><br>本文转载自<a href="http://www.devtf.cn/?p=1134" target="_blank" rel="external">开发技术前线：面向对象六大原则</a><br>本文转载自<a href="http://www.devtf.cn/?p=1134" target="_blank" rel="external">开发技术前线：面向对象六大原则</a></p>
<h2 id="优化代码的第一步——单一职责原则"><a href="#优化代码的第一步——单一职责原则" class="headerlink" title="优化代码的第一步——单一职责原则"></a>优化代码的第一步——单一职责原则</h2><p>单一职责原则的英文名称是Single Responsibility Principle，简称SRP。它的定义是：就一个类而言，应该仅有一个引起它变化的原因。简单来说，一个类中应该是一组相关性很高的函数、数据的封装。就像秦小波老师在《设计模式之禅》中说的：“这是一个备受争议却又及其重要的原则。只要你想和别人争执、怄气或者是吵架，这个原则是屡试不爽的”。因为单一职责的划分界限并不是总是那么清晰，很多时候都是需要靠个人经验来界定。当然，最大的问题就是对职责的定义，什么是类的职责，以及怎么划分类的职责。<br>对于计算机技术，通常只单纯地学习理论知识并不能很好地领会其深意，只有自己动手实践，并在实际运用中发现问题、解决问题、思考问题，才能够将知识吸收到自己的脑海中。下面以我的朋友小民的事迹说起。</p>
<p>自从Android系统发布以来，小民就是Android的铁杆粉丝，于是在大学期间一直保持着对Android的关注，并且利用课余时间做些小项目，锻炼自己的实战能力。毕业后，小民如愿地加入了心仪的公司，并且投入到了他热爱的Android应用开发行业中。将爱好、生活、事业融为一体，小民的第一份工作也算是顺风顺水，一切尽在掌握中。<br>在经历过一周的适应期以及熟悉公司的产品、开发规范之后，小民的开发工作就正式开始了。小民的主管是个工作经验丰富的技术专家，对于小民的工作并不是很满意，尤其小民最薄弱的面向对象设计，而Android开发又是使用Java语言，什么抽象、接口、六大原则、23种设计模式等名词把小民弄得晕头转向。小民自己也察觉到了自己的问题所在，于是，小民的主管决定先让小民做一个小项目来锻炼锻炼这方面的能力。正所谓养兵千日用兵一时，磨刀不误砍柴工，小民的开发之路才刚刚开始。</p>
<p>在经过一番思考之后，主管挑选了使用范围广、难度也适中的ImageLoader（图片加载）作为小民的训练项目。既然要训练小民的面向对象设计，那么就必须考虑到可扩展性、灵活性，而检测这一切是否符合需求的最好途径就是开源。用户不断地提出需求、反馈问题，小民的项目需要不断升级以满足用户需求，并且要保证系统的稳定性、灵活性。在主管跟小民说了这一特殊任务之后，小民第一次感到了压力，“生活不容易呐！”年仅22岁至今未婚的小民发出了如此深刻的感叹！</p>
<p>挑战总是要面对的，何况是从来不服输的小民。主管的要求很简单，要小民实现图片加载，并且要将图片缓存起来。在分析了需求之后，小民一下就放心下来了，“这么简单，原来我还以为很难呢……”小民胸有成足的喃喃自语。在经历了十分钟的编码之后，小民写下了如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 图片加载类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 图片缓存</span></div><div class="line">    LruCache&lt;String, Bitmap&gt; mImageCache;</div><div class="line">    <span class="comment">// 线程池,线程数量为CPU的数量</span></div><div class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool (Runtime.getRuntime().availableProcessors());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageLoader</span><span class="params">()</span> </span>&#123;</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initImageCache</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// 计算可使用的最大内存</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</div><div class="line">            <span class="comment">// 取四分之一的可用内存作为缓存</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cacheSize = maxMemory / <span class="number">4</span>;</div><div class="line">        mImageCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> bitmap.getRowBytes() * bitmap.getHeight() / <span class="number">1024</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;                   </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</div><div class="line">        imageView.setTag(url);</div><div class="line">        mExecutorService.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">           <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">              Bitmap bitmap = downloadImage(url);</div><div class="line">                <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">              &#125;</div><div class="line">                <span class="keyword">if</span> (imageView.getTag().equals(url)) &#123;</div><div class="line">                    imageView.setImageBitmap(bitmap);</div><div class="line">              &#125;</div><div class="line">                mImageCache.put(url, bitmap);</div><div class="line">          &#125;</div><div class="line">       &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span>  Bitmap <span class="title">downloadImage</span><span class="params">(String imageUrl)</span> </span>&#123;</div><div class="line">        Bitmap bitmap = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          URL url = newURL(imageUrl);</div><div class="line">            <span class="keyword">final</span> HttpURLConnection conn = (HttpURLConnection) </div><div class="line">                            url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> bitmap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>并且使用git软件进行版本控制，将工程托管到github上，伴随着git push命令的完成，小民的ImageLoader 0.1版本就正式发布了！如此短的时间内就完成了这个任务，而且还是一个开源项目，小民暗暗自喜，幻想着待会儿主管的称赞。</p>
<p>在小民给主管报告了ImageLoader的发布消息的几分钟之后，主管就把小民叫到了会议室。这下小民纳闷了，怎么夸人还需要到会议室。“小民，你的ImageLoader耦合太严重啦！简直就没有设计可言，更不要说扩展性、灵活性了。所有的功能都写在一个类里怎么行呢，这样随着功能的增多，ImageLoader类会越来越大，代码也越来越复杂，图片加载系统就越来越脆弱……”Duang，这简直就是当头棒喝，小民的脑海里已经听不清主管下面说的内容了，只是觉得自己之前没有考虑清楚就匆匆忙忙完成任务，而且把任务想得太简单了。</p>
<p>“你还是把ImageLoader拆分一下，把各个功能独立出来，让它们满足单一职责原则。”主管最后说道。小民是个聪明人，敏锐地捕捉到了单一职责原则这个关键词。用Google搜索了一些优秀资料之后总算是对单一职责原则有了一些认识。于是打算对ImageLoader进行一次重构。这次小民不敢过于草率，也是先画了一幅UML图，如图1-1所示。<br><img src="http://img.blog.csdn.net/20151101112108511" alt="图1-1"><br>ImageLoader代码修改如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 图片加载类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 图片缓存</span></div><div class="line">    ImageCache mImageCache = <span class="keyword">new</span> ImageCache() ;</div><div class="line">    <span class="comment">// 线程池,线程数量为CPU的数量</span></div><div class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool (Runtime.getRuntime().availableProcessors());</div><div class="line"> </div><div class="line">    <span class="comment">// 加载图片</span></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</div><div class="line">        Bitmap bitmap = mImageCache.get(url);</div><div class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">            imageView.setImageBitmap(bitmap);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        imageView.setTag(url);</div><div class="line">        mExecutorService.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"> </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            Bitmap bitmap = downloadImage(url);</div><div class="line">                <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (imageView.getTag().equals(url)) &#123;</div><div class="line">                    imageView.setImageBitmap(bitmap);</div><div class="line">                &#125;</div><div class="line">                mImageCache.put(url, bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">     &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span>  Bitmap <span class="title">downloadImage</span><span class="params">(String imageUrl)</span> </span>&#123;</div><div class="line">        Bitmap bitmap = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">           URL url = <span class="keyword">new</span> URL(imageUrl);</div><div class="line">            <span class="keyword">final</span> HttpURLConnection conn = (HttpURLConnection) </div><div class="line">                        url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bitmap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>并且添加了一个ImageCache类用于处理图片缓存，具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageCache</span> </span>&#123;</div><div class="line">    <span class="comment">// 图片LRU缓存</span></div><div class="line">    LruCache&lt;String, Bitmap&gt; mImageCache;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageCache</span><span class="params">()</span> </span>&#123;</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initImageCache</span><span class="params">()</span> </span>&#123;</div><div class="line">         <span class="comment">// 计算可使用的最大内存</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</div><div class="line">        <span class="comment">// 取四分之一的可用内存作为缓存</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cacheSize = maxMemory / <span class="number">4</span>;</div><div class="line">        mImageCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> bitmap.getRowBytes() * bitmap.getHeight() / <span class="number">1024</span>;</div><div class="line">           &#125;</div><div class="line">        &#125;;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bitmap)</span> </span>&#123;</div><div class="line">        mImageCache.put(url, bitmap) ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mImageCache.get(url) ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如图1-1和上述代码所示，小民将ImageLoader一拆为二，ImageLoader只负责图片加载的逻辑，而ImageCache只负责处理图片缓存的逻辑，这样ImageLoader的代码量变少了，职责也清晰了，当与缓存相关的逻辑需要改变时，不需要修改ImageLoader类，而图片加载的逻辑需要修改时也不会影响到缓存处理逻辑。主管在审核了小民的第一次重构之后，对小民的工作给予了表扬，大致意思是结构变得清晰了许多，但是可扩展性还是比较欠缺，虽然没有得到主管的完全肯定，但也是颇有进步，再考虑到自己确实有所收获，小民原本沮丧的心里也略微地好转起来。</p>
<p>从上述的例子中我们能够体会到，单一职责所表达出的用意就是“单一”二字。正如上文所说，如何划分一个类、一个函数的职责，每个人都有自己的看法，这需要根据个人经验、具体的业务逻辑而定。但是，它也有一些基本的指导原则，例如，两个完全不一样的功能就不应该放在一个类中。一个类中应该是一组相关性很高的函数、数据的封装。工程师可以不断地审视自己的代码，根据具体的业务、功能对类进行相应的拆分，我想这会是你优化代码迈出的第一步。</p>
<h2 id="让程序更稳定、更灵活——开闭原则"><a href="#让程序更稳定、更灵活——开闭原则" class="headerlink" title="让程序更稳定、更灵活——开闭原则"></a>让程序更稳定、更灵活——开闭原则</h2><p>开闭原则的英文全称是Open Close Principle，简称OCP，它是Java世界里最基础的设计原则，它指导我们如何建立一个稳定的、灵活的系统。开闭原则的定义是：软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是，对于修改是封闭的。在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会将错误引入原本已经经过测试的旧代码中，破坏原有系统。因此，当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。当然，在现实开发中，只通过继承的方式来升级、维护原有系统只是一个理想化的愿景，因此，在实际的开发过程中，修改原有代码、扩展代码往往是同时存在的。</p>
<p>软件开发过程中，最不会变化的就是变化本身。产品需要不断地升级、维护，没有一个产品从第一版本开发完就再没有变化了，除非在下个版本诞生之前它已经被终止。而产品需要升级，修改原来的代码就可能会引发其他的问题。那么如何确保原有软件模块的正确性，以及尽量少地影响原有模块，答案就是尽量遵守本章要讲述的开闭原则。</p>
<p>勃兰特·梅耶在1988年出版的《面向对象软件构造》一书中提出这一原则。这一想法认为，一旦完成，一个类的实现只应该因错误而被修改，新的或者改变的特性应该通过新建不同的类实现。新建的类可以通过继承的方式来重用原类的代码。显然，梅耶的定义提倡实现继承，已存在的实现对于修改是封闭的，但是新的实现类可以通过覆写父类的接口应对变化。<br>说了这么多，想必大家还是半懂不懂，还是让我们以一个简单示例说明一下吧。</p>
<p>在对ImageLoader进行了一次重构之后，小民的这个开源库获得了一些用户。小民第一次感受到自己发明“轮子”的快感，对开源的热情也越发高涨起来！通过动手实现一些开源库来深入学习相关技术，不仅能够提升自我，也能更好地将这些技术运用到工作中，从而开发出更稳定、优秀的应用，这就是小民的真实想法。</p>
<p>小民第一轮重构之后的ImageLoader职责单一、结构清晰，不仅获得了主管的一点肯定，还得到了用户的夸奖，算是个不错的开始。随着用户的增多，有些问题也暴露出来了，小民的缓存系统就是大家“吐槽”最多的地方。通过内存缓存解决了每次从网络加载图片的问题，但是，Android应用的内存很有限，且具有易失性，即当应用重新启动之后，原来已经加载过的图片将会丢失，这样重启之后就需要重新下载！这又会导致加载缓慢、耗费用户流量的问题。小民考虑引入SD卡缓存，这样下载过的图片就会缓存到本地，即使重启应用也不需要重新下载了！小民在和主管讨论了该问题之后就投入了编程中，下面就是小民的代码。<br>DiskCache.java类，将图片缓存到SD卡中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskCache</span> </span>&#123;</div><div class="line">    <span class="comment">// 为了简单起见临时写个路径,在开发中请避免这种写法 !</span></div><div class="line">    <span class="keyword">static</span> String cacheDir = <span class="string">"sdcard/cache/"</span>;</div><div class="line">     <span class="comment">// 从缓存中获取图片</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> BitmapFactory.decodeFile(cacheDir + url);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将图片缓存到内存中</span></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">       FileOutputStream fileOutputStream = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            fileOutputStream = <span class="keyword">new</span> FileOutputStream(cacheDir + url);</div><div class="line">            bmp.compress(CompressFormat.PNG, <span class="number">100</span>, fileOutputStream);</div><div class="line">      &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">      &#125; <span class="keyword">final</span> ly &#123;</div><div class="line">            <span class="keyword">if</span> (fileOutputStream != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    fileOutputStream.close();</div><div class="line">              &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">             &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为需要将图片缓存到SD卡中，所以，ImageLoader代码有所更新，具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 内存缓存</span></div><div class="line">    ImageCache mImageCache = <span class="keyword">new</span> ImageCache();</div><div class="line">    <span class="comment">// SD卡缓存</span></div><div class="line">    DiskCache mDiskCache = <span class="keyword">new</span> DiskCache();</div><div class="line">    <span class="comment">// 是否使用SD卡缓存</span></div><div class="line">    <span class="keyword">boolean</span> isUseDiskCache = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 线程池,线程数量为CPU的数量</span></div><div class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool (Runtime.getRuntime().availableProcessors());</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</div><div class="line">        <span class="comment">// 判断使用哪种缓存</span></div><div class="line">       Bitmap bitmap = isUseDiskCache ? mDiskCache.get(url) </div><div class="line">                : mImageCache.get (url);</div><div class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">            imageView.setImageBitmap(bitmap);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">        <span class="comment">// 没有缓存，则提交给线程池进行下载</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useDiskCache</span><span class="params">(<span class="keyword">boolean</span> useDiskCache)</span> </span>&#123;</div><div class="line">        isUseDiskCache = useDiskCache ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上述的代码中可以看到，仅仅新增了一个DiskCache类和往ImageLoader类中加入了少量代码就添加了SD卡缓存的功能，用户可以通过useDiskCache方法来对使用哪种缓存进行设置，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ImageLoader imageLoader = <span class="keyword">new</span> ImageLoader() ;</div><div class="line"> <span class="comment">// 使用SD卡缓存</span></div><div class="line">imageLoader.useDiskCache(<span class="keyword">true</span>);</div><div class="line"><span class="comment">// 使用内存缓存</span></div><div class="line">imageLoader.useDiskCache(<span class="keyword">false</span>);</div></pre></td></tr></table></figure></p>
<p>通过useDiskCache方法可以让用户设置不同的缓存，非常方便啊！小民对此很满意，于是提交给主管做代码审核。“小民，你思路是对的，但是有些明显的问题，就是使用内存缓存时用户就不能使用SD卡缓存，类似的，使用SD卡缓存时用户就不能使用内存缓存。用户需要这两种策略的综合，首先缓存优先使用内存缓存，如果内存缓存没有图片再使用SD卡缓存，如果SD卡中也没有图片最后才从网络上获取，这才是最好的缓存策略。”主管真是一针见血，小民这时才如梦初醒，刚才还得意洋洋的脸上突然有些泛红……<br>于是小民按照主管的指点新建了一个双缓存类DoudleCache，具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 双缓存。获取图片时先从内存缓存中获取，如果内存中没有缓存该图片，再从SD卡中获取。</div><div class="line"> *  缓存图片也是在内存和SD卡中都缓存一份</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCache</span> </span>&#123;</div><div class="line">    ImageCache mMemoryCache = <span class="keyword">new</span> ImageCache();</div><div class="line">    DiskCache mDiskCache = <span class="keyword">new</span> DiskCache();</div><div class="line"> </div><div class="line">    <span class="comment">// 先从内存缓存中获取图片，如果没有，再从SD卡中获取</span></div><div class="line">    <span class="function"><span class="keyword">public</span>   Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">       Bitmap bitmap = mMemoryCache.get(url);</div><div class="line">        <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</div><div class="line">            bitmap = mDiskCache.get(url);</div><div class="line">       &#125;</div><div class="line">        <span class="keyword">return</span>  bitmap;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">// 将图片缓存到内存和SD卡中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">        mMemoryCache.put(url, bmp);</div><div class="line">        mDiskCache.put(url, bmp);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们再看看最新的ImageLoader类吧，代码更新也不多：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 内存缓存</span></div><div class="line">    ImageCache mImageCache = <span class="keyword">new</span> ImageCache();</div><div class="line">    <span class="comment">// SD卡缓存</span></div><div class="line">    DiskCache mDiskCache = <span class="keyword">new</span> DiskCache();</div><div class="line">    <span class="comment">// 双缓存</span></div><div class="line">    DoubleCache mDoubleCache = <span class="keyword">new</span> DoubleCache() ;</div><div class="line">    <span class="comment">// 使用SD卡缓存</span></div><div class="line">    <span class="keyword">boolean</span> isUseDiskCache = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 使用双缓存</span></div><div class="line">    <span class="keyword">boolean</span> isUseDoubleCache = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 线程池,线程数量为CPU的数量</span></div><div class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool (Runtime.getRuntime().availableProcessors());</div><div class="line"> </div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</div><div class="line">        Bitmap bmp = <span class="keyword">null</span>;</div><div class="line">         <span class="keyword">if</span> (isUseDoubleCache) &#123;</div><div class="line">            bmp = mDoubleCache.get(url);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUseDiskCache) &#123;</div><div class="line">            bmp = mDiskCache.get(url);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            bmp = mImageCache.get(url);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">         <span class="keyword">if</span> ( bmp != <span class="keyword">null</span> ) &#123;</div><div class="line">            imageView.setImageBitmap(bmp);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 没有缓存，则提交给线程池进行异步下载图片</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useDiskCache</span><span class="params">(<span class="keyword">boolean</span> useDiskCache)</span> </span>&#123;</div><div class="line">        isUseDiskCache = useDiskCache ;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useDoubleCache</span><span class="params">(<span class="keyword">boolean</span> useDoubleCache)</span> </span>&#123;</div><div class="line">        isUseDoubleCache = useDoubleCache ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过增加短短几句代码和几处修改就完成了如此重要的功能。小民已越发觉得自己Android开发已经到了的得心应手的境地，不仅感觉一阵春风袭来，他那飘逸的头发一下从他的眼前拂过，小民感觉今天天空比往常敞亮许多。</p>
<p>“小民，你每次加新的缓存方法时都要修改原来的代码，这样很可能会引入Bug，而且会使原来的代码逻辑变得越来越复杂，按照你这样的方法实现，用户也不能自定义缓存实现呀！”到底是主管水平高，一语道出了小民这缓存设计上的问题。</p>
<p>我们还是来分析一下小民的程序，小民每次在程序中加入新的缓存实现时都需要修改ImageLoader类，然后通过一个布尔变量来让用户使用哪种缓存，因此，就使得在ImageLoader中存在各种if-else判断，通过这些判断来确定使用哪种缓存。随着这些逻辑的引入，代码变得越来越复杂、脆弱，如果小民一不小心写错了某个if条件（条件太多，这是很容易出现的），那就需要更多的时间来排除。整个ImageLoader类也会变得越来越臃肿。最重要的是用户不能自己实现缓存注入到ImageLoader中，可扩展性可是框架的最重要特性之一。</p>
<p>“软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的，这就是开放-关闭原则。也就是说，当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。”小民的主管补充到，小民听得云里雾里的。主管看小民这等反应，于是亲自“操刀”，为他画下了如图1-2的UML图。<br><img src="http://img.blog.csdn.net/20151101112846324" alt="图1-2"><br>小民看到图1-2似乎明白些什么，但是又不是太明确如何修改程序。主管看到小民这般模样只好亲自上阵，带着小民把ImageLoader程序按照图1-2进行了一次重构。具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 图片缓存</span></div><div class="line">    ImageCache mImageCache = <span class="keyword">new</span> MemoryCache();</div><div class="line">    <span class="comment">// 线程池,线程数量为CPU的数量</span></div><div class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool (Runtime.getRuntime().availableProcessors());</div><div class="line"> </div><div class="line">    <span class="comment">// 注入缓存实现</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageCache</span><span class="params">(ImageCache cache)</span> </span>&#123;</div><div class="line">        mImageCache = cache;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String imageUrl, ImageView imageView)</span> </span>&#123;</div><div class="line">        Bitmap bitmap = mImageCache.get(imageUrl);</div><div class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">            imageView.setImageBitmap(bitmap);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 图片没缓存，提交到线程池中下载图片</span></div><div class="line">        submitLoadRequest(imageUrl, imageView);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">submitLoadRequest</span><span class="params">(<span class="keyword">final</span> String imageUrl,</span></span></div><div class="line">             <span class="keyword">final</span> ImageView imageView) &#123;</div><div class="line">        imageView.setTag(imageUrl);</div><div class="line">        mExecutorService.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"> </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">              Bitmap bitmap = downloadImage(imageUrl);</div><div class="line">                <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">             &#125;</div><div class="line">               <span class="keyword">if</span> (imageView.getTag().equals(imageUrl)) &#123;</div><div class="line">                    imageView.setImageBitmap(bitmap);</div><div class="line">             &#125;</div><div class="line">                mImageCache.put(imageUrl, bitmap);</div><div class="line">         &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span>  Bitmap <span class="title">downloadImage</span><span class="params">(String imageUrl)</span> </span>&#123;</div><div class="line">       Bitmap bitmap = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">           URL url = <span class="keyword">new</span> URL(imageUrl);</div><div class="line">            <span class="keyword">final</span> HttpURLConnection conn = (HttpURLConnection) </div><div class="line">                        url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">              e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> bitmap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>经过这次重构，没有了那么多的if-else语句，没有了各种各样的缓存实现对象、布尔变量，代码确实清晰、简单了很多，小民对主管的崇敬之情又“泛滥”了起来。需要注意的是，这里的ImageCache类并不是小民原来的那个ImageCache，这次程序重构主管把它提取成一个图片缓存的接口，用来抽象图片缓存的功能。我们看看该接口的声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageCache</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ImageCache接口简单定义了获取、缓存图片两个函数，缓存的key是图片的url，值是图片本身。内存缓存、SD卡缓存、双缓存都实现了该接口，我们看看这几个缓存实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 内存缓存MemoryCache类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryCache</span> <span class="keyword">implements</span> <span class="title">ImageCache</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> LruCache&lt;String, Bitmap&gt; mMemeryCache;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemoryCache</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 初始化LRU缓存</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line">     <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mMemeryCache.get(url);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">        mMemeryCache.put(url, bmp);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// SD卡缓存DiskCache类</span></div><div class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">DiskCache</span> <span class="keyword">implements</span> <span class="title">ImageCache</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span><span class="comment">/* 从本地文件中获取该图片 */</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">        <span class="comment">// 将Bitmap写入文件中</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 双缓存DoubleCache类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCache</span> <span class="keyword">implements</span> <span class="title">ImageCache</span></span>&#123;</div><div class="line">    ImageCache mMemoryCache = <span class="keyword">new</span> MemoryCache();</div><div class="line">    ImageCache mDiskCache = <span class="keyword">new</span> DiskCache();</div><div class="line"> </div><div class="line">    <span class="comment">// 先从内存缓存中获取图片，如果没有，再从SD卡中获取</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">       Bitmap bitmap = mMemoryCache.get(url);</div><div class="line">        <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</div><div class="line">            bitmap = mDiskCache.get(url);</div><div class="line">       &#125;</div><div class="line">        <span class="keyword">return</span> bitmap;</div><div class="line">     &#125;</div><div class="line"> </div><div class="line">    <span class="comment">// 将图片缓存到内存和SD卡中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">        mMemoryCache.put(url, bmp);</div><div class="line">        mDiskCache.put(url, bmp);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>细心的朋友可能注意到了，ImageLoader类中增加了一个setImageCache（ImageCache cache）函数，用户可以通过该函数设置缓存实现，也就是通常说的依赖注入。下面就看看用户是如何设置缓存实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ImageLoader imageLoader = <span class="keyword">new</span> ImageLoader() ;</div><div class="line">        <span class="comment">// 使用内存缓存</span></div><div class="line">imageLoader.setImageCache(<span class="keyword">new</span> MemoryCache());</div><div class="line">        <span class="comment">// 使用SD卡缓存</span></div><div class="line">imageLoader.setImageCache(<span class="keyword">new</span> DiskCache());</div><div class="line">        <span class="comment">// 使用双缓存</span></div><div class="line">imageLoader.setImageCache(<span class="keyword">new</span> DoubleCache());</div><div class="line">        <span class="comment">// 使用自定义的图片缓存实现</span></div><div class="line">imageLoader.setImageCache(<span class="keyword">new</span> ImageCache() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">            <span class="comment">// 缓存图片</span></div><div class="line">       &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span><span class="comment">/*从缓存中获取图片*/</span>;</div><div class="line">       &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>在上述代码中，通过setImageCache（ImageCache cache）方法注入不同的缓存实现，这样不仅能够使ImageLoader更简单、健壮，也使得ImageLoader的可扩展性、灵活性更高。MemoryCache、DiskCache、DoubleCache缓存图片的具体实现完全不一样，但是，它们的一个特点是都实现了ImageCache接口。当用户需要自定义实现缓存策略时，只需要新建一个实现ImageCache接口的类，然后构造该类的对象，并且通过setImageCache（ImageCache cache）注入到ImageLoader中，这样ImageLoader就实现了变化万千的缓存策略，而扩展这些缓存策略并不会导致ImageLoader类的修改。经过这次重构，小民的ImageLoader已经基本算合格了。咦！这不就是主管说的开闭原则么！“软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的。而遵循开闭原则的重要手段应该是通过抽象……”小民细声细语的念叨中，陷入了思索中……</p>
<p>开闭原则指导我们，当软件需要变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。这里的“应该尽量”4个字说明OCP原则并不是说绝对不可以修改原始类的，当我们嗅到原来的代码“腐化气味”时，应该尽早地重构，以使得代码恢复到正常的“进化”轨道，而不是通过继承等方式添加新的实现，这会导致类型的膨胀以及历史遗留代码的冗余。我们的开发过程中也没有那么理想化的状况，完全地不用修改原来的代码，因此，在开发过程中需要自己结合具体情况进行考量，是通过修改旧代码还是通过继承使得软件系统更稳定、更灵活，在保证去除“代码腐化”的同时，也保证原有模块的正确性。</p>
<h2 id="构建扩展性更好的系统——里氏替换原则"><a href="#构建扩展性更好的系统——里氏替换原则" class="headerlink" title="构建扩展性更好的系统——里氏替换原则"></a>构建扩展性更好的系统——里氏替换原则</h2><p>里氏替换原则英文全称是Liskov Substitution Principle，简称LSP。它的第一种定义是：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。上面这种描述确实不太好理解，理论家有时候容易把问题抽象化，本来挺容易理解的事让他们一概括就弄得拗口了。我们再看看另一个直截了当的定义。里氏替换原则第二种定义：所有引用基类的地方必须能透明地使用其子类的对象。</p>
<p>我们知道，面向对象的语言的三大特点是继承、封装、多态，里氏替换原则就是依赖于继承、多态这两大特性。里氏替换原则简单来说就是，所有引用基类的地方必须能透明地使用其子类的对象。通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。说了那么多，其实最终总结就两个字：抽象。<br>小民为了深入地了解Android中的Window与View的关系特意写了一个简单示例，为了便于理解，我们先看如图1-3所示。<br><img src="http://img.blog.csdn.net/20151102134653836" alt="图1-3"><br>我们看看具体的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 窗口类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(View child)</span></span>&#123;</div><div class="line">        child.draw();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 建立视图抽象，测量视图的宽高为公用代码，绘制交给具体的子类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span>  <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span>  <span class="title">draw</span><span class="params">()</span> </span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">measure</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>&#123;</div><div class="line">        <span class="comment">// 测量视图大小</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 按钮类的具体实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 绘制按钮</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// TextView的具体实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 绘制文本</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述示例中，Window依赖于View，而View定义了一个视图抽象，measure是各个子类共享的方法，子类通过覆写View的draw方法实现具有各自特色的功能，在这里，这个功能就是绘制自身的内容。任何继承自View类的子类都可以设置给show方法，也就我们所说的里氏替换。通过里氏替换，就可以自定义各式各样、千变万化的View，然后传递给Window，Window负责组织View，并且将View显示到屏幕上。<br>里氏替换原则的核心原理是抽象，抽象又依赖于继承这个特性，在OOP当中，继承的优缺点都相当明显。<br>优点如下：</p>
<ul>
<li>（1）代码重用，减少创建类的成本，每个子类都拥有父类的方法和属性；</li>
<li>（2）子类与父类基本相似，但又与父类有所区别；</li>
<li>（3）提高代码的可扩展性。</li>
</ul>
<p>继承的缺点：</p>
<ul>
<li>继承是侵入性的，只要继承就必须拥有父类的所有属性和方法；</li>
<li>可能造成子类代码冗余、灵活性降低，因为子类必须拥有父类的属性和方法。</li>
</ul>
<p>事物总是具有两面性，如何权衡利与弊都是需要根据具体场景来做出选择并加以处理。里氏替换原则指导我们构建扩展性更好的软件系统，我们还是接着上面的ImageLoader来做说明。<br>上文的图1-2也很好地反应了里氏替换原则，即MemoryCache、DiskCache、DoubleCache都可以替换ImageCache的工作，并且能够保证行为的正确性。ImageCache建立了获取缓存图片、保存缓存图片的接口规范，MemoryCache等根据接口规范实现了相应的功能，用户只需要在使用时指定具体的缓存对象就可以动态地替换ImageLoader中的缓存策略。这就使得ImageLoader的缓存系统具有了无线的可能性，也就是保证了可扩展性。</p>
<p>想象一个场景，当ImageLoader中的setImageCache（ImageCache cache）中的cache对象不能够被子类所替换，那么用户如何设置不同的缓存对象以及用户如何自定义自己的缓存实现，通过1.3节中的useDiskCache方法吗？显然不是的，里氏替换原则就为这类问题提供了指导原则，也就是建立抽象，通过抽象建立规范，具体的实现在运行时替换掉抽象，保证系统的高扩展性、灵活性。开闭原则和里氏替换原则往往是生死相依、不弃不离的，通过里氏替换来达到对扩展开放，对修改关闭的效果。然而，这两个原则都同时强调了一个OOP的重要特性——抽象，因此，在开发过程中运用抽象是走向代码优化的重要一步。</p>
<h2 id="让项目拥有变化的能力——依赖倒置原则"><a href="#让项目拥有变化的能力——依赖倒置原则" class="headerlink" title="让项目拥有变化的能力——依赖倒置原则"></a>让项目拥有变化的能力——依赖倒置原则</h2><p>依赖倒置原则英文全称是Dependence Inversion Principle，简称DIP。依赖反转原则指代了一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节的目的，依赖模块被颠倒了。这个概念有点不好理解，这到底是什么意思呢？<br>依赖倒置原则的几个关键点：</p>
<ul>
<li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li>
<li>抽象不应该依赖细节；</li>
<li>细节应该依赖抽象。</li>
</ul>
<p>在Java语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是，可以直接被实例化，也就是可以加上一个关键字 new 产生一个对象。高层模块就是调用端，低层模块就是具体实现类。依赖倒置原则在 Java 语言中的表现就是：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。这又是一个将理论抽象化的实例，其实一句话就可以概括：面向接口编程，或者说是面向抽象编程，这里的抽象指的是接口或者抽象类。面向接口编程是面向对象精髓之一，也就是上面两节强调的抽象。</p>
<p>如果在类与类直接依赖于细节，那么它们之间就有直接的耦合，当具体实现需要变化时，意味着在这要同时修改依赖者的代码，并且限制了系统的可扩展性。我们看1.3节的图1-3中，ImageLoader直接依赖于MemoryCache，这个MemoryCache是一个具体实现，而不是一个抽象类或者接口。这导致了ImageLoader直接依赖了具体细节，当MemoryCache不能满足ImageLoader而需要被其他缓存实现替换时，此时就必须修改ImageLoader的代码，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 内存缓存 ( 直接依赖于细节 )</span></div><div class="line">    MemoryCache mMemoryCache = <span class="keyword">new</span> MemoryCache();</div><div class="line">     <span class="comment">// 加载图片到ImageView中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String url, ImageView imageView)</span> </span>&#123;</div><div class="line">       Bitmap bmp = mMemoryCache.get(url);</div><div class="line">        <span class="keyword">if</span> (bmp == <span class="keyword">null</span>) &#123;</div><div class="line">            downloadImage(url, imageView);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">            imageView.setImageBitmap(bmp);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageCache</span><span class="params">(MemoryCache cache)</span> </span>&#123;</div><div class="line">        mCache = cache ;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>随着产品的升级，用户发现MemoryCache已经不能满足需求，用户需要小民的ImageLoader可以将图片同时缓存到内存和SD卡中，或者可以让用户自定义实现缓存。此时，我们的MemoryCache这个类名不仅不能够表达内存缓存和SD卡缓存的意义，也不能够满足功能。另外，用户需要自定义缓存实现时还必须继承自MemoryCache，而用户的缓存实现可不一定与内存缓存有关，这在命名上的限制也让用户体验不好。重构的时候到了!小民的第一种方案是将MemoryCache修改为DoubleCache，然后在DoubleCache中实现具体的缓存功能。我们需要将ImageLoader修改如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 双缓存 ( 直接依赖于细节 )</span></div><div class="line">    DoubleCache mCache = <span class="keyword">new</span> DoubleCache();</div><div class="line">    <span class="comment">// 加载图片到ImageView中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String url, ImageView imageView)</span> </span>&#123;</div><div class="line">       Bitmap bmp = mCache.get(url);</div><div class="line">        <span class="keyword">if</span> (bmp == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="comment">// 异步下载图片</span></div><div class="line">            downloadImageAsync(url, imageView);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">            imageView.setImageBitmap(bmp);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageCache</span><span class="params">(DoubleCache cache)</span> </span>&#123;</div><div class="line">         mCache = cache ;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们将MemoryCache修改成DoubleCache，然后修改了ImageLoader中缓存类的具体实现，轻轻松松就满足了用户需求。等等！这不还是依赖于具体的实现类（DoubleCache）吗？当用户的需求再次变化时，我们又要通过修改缓存实现类和ImageLoader代码来实现？修改原有代码不是违反了1.3节中的开闭原则吗？小民突然醒悟了过来，低下头思索着如何才能让缓存系统更灵活、拥抱变化……</p>
<p>当然，这些都是在主管给出图1-2（1.3节）以及相应的代码之前，小民体验的煎熬过程。既然是这样，那显然主管给出的解决方案就能够让缓存系统更加灵活。一句话概括起来就是：依赖抽象，而不依赖具体实现。针对于图片缓存，主管建立的ImageCache抽象，该抽象中增加了get和put方法用以实现图片的存取。每种缓存实现都必须实现这个接口，并且实现自己的存取方法。当用户需要使用不同的缓存实现时，直接通过依赖注入即可，保证了系统的灵活性。我们再来简单回顾一下相关代码：</p>
<p>ImageCache缓存抽象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageCache</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ImageLoader类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 图片缓存类，依赖于抽象，并且有一个默认的实现</span></div><div class="line">    ImageCache mCache = <span class="keyword">new</span> MemoryCache();</div><div class="line"></div><div class="line">    <span class="comment">// 加载图片</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String url, ImageView imageView)</span> </span>&#123;</div><div class="line">       Bitmap bmp = mCache.get(url);</div><div class="line">        <span class="keyword">if</span> (bmp == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 异步加载图片</span></div><div class="line">            downloadImageAsync(url, imageView);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">            imageView.setImageBitmap(bmp);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置缓存策略,依赖于抽象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageCache</span><span class="params">(ImageCache cache)</span> </span>&#123;</div><div class="line">        mCache = cache;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，我们建立了ImageCache抽象，并且让ImageLoader依赖于抽象而不是具体细节。当需求发生变更时，小民只需要实现ImageCahce类或者继承其他已有的ImageCache子类完成相应的缓存功能，然后将具体的实现注入到ImageLoader即可实现缓存功能的替换，这就保证了缓存系统的高可扩展性，拥有了拥抱变化的能力，而这一切的基本指导原则就是我们的依赖倒置原则。从上述几节中我们发现，要想让我们的系统更为灵活，抽象似乎成了我们唯一的手段。</p>
<h2 id="系统有更高的灵活性——接口隔离原则"><a href="#系统有更高的灵活性——接口隔离原则" class="headerlink" title="系统有更高的灵活性——接口隔离原则"></a>系统有更高的灵活性——接口隔离原则</h2><p>接口隔离原则英文全称是InterfaceSegregation Principles，简称ISP。它的定义是：客户端不应该依赖它不需要的接口。另一种定义是：类间的依赖关系应该建立在最小的接口上。接口隔离原则将非常庞大、臃肿的接口拆分成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。接口隔离原则的目的是系统解开耦合，从而容易重构、更改和重新部署。</p>
<p>接口隔离原则说白了就是，让客户端依赖的接口尽可能地小，这样说可能还是有点抽象，我们还是以一个示例来说明一下。在此之前我们来说一个场景，在Java 6以及之前的JDK版本，有一个非常讨厌的问题，那就是在使用了OutputStream或者其他可关闭的对象之后，我们必须保证它们最终被关闭了，我们的SD卡缓存类中就有这样的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将图片缓存到内存中</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">    FileOutputStream fileOutputStream = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        fileOutputStream = <span class="keyword">new</span> FileOutputStream(cacheDir + url);</div><div class="line">        bmp.compress(CompressFormat.PNG, <span class="number">100</span>, fileOutputStream);</div><div class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (fileOutputStream != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                fileOutputStream.close();</div><div class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">          &#125;</div><div class="line">       &#125; <span class="comment">// end if</span></div><div class="line">    &#125; <span class="comment">// end if finally</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看到的这段代码可读性非常差，各种try…catch嵌套，都是些简单的代码，但是会严重影响代码的可读性，并且多层级的大括号很容易将代码写到错误的层级中。大家应该对这类代码也非常反感，那我们看看如何解决这类问题。<br>我们可能知道Java中有一个Closeable接口，该接口标识了一个可关闭的对象，它只有一个close方法，如图1-4所示。<br>我们要讲的FileOutputStream类就实现了这个接口，我们从图1-4中可以看到，还有一百多个类实现了Closeable这个接口，这意味着，在关闭这一百多个类型的对象时，都需要写出像put方法中finally代码段那样的代码。这还了得！你能忍，反正小民是忍不了的！于是小民打算要发挥他的聪明才智解决这个问题，既然都是实现了Closeable接口，那只要我建一个方法统一来关闭这些对象不就可以了么？说干就干，于是小民写下来如下的工具类：<br><img src="http://img.blog.csdn.net/20151102135056245" alt="图1-4"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseUtils</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">Private <span class="title">CloseUtils</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 关闭Closeable对象</div><div class="line">     * <span class="doctag">@param</span> closeable</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeQuietly</span><span class="params">(Closeable closeable)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != closeable) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                closeable.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们再看看把这段代码运用到上述的put方法中的效果如何：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">    FileOutputStream fileOutputStream = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        fileOutputStream = <span class="keyword">new</span> FileOutputStream(cacheDir + url);</div><div class="line">        bmp.compress(CompressFormat.PNG, <span class="number">100</span>, fileOutputStream);</div><div class="line">   &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">   &#125; <span class="keyword">final</span> ly &#123;</div><div class="line">        CloseUtils.closeQuietly(fileOutputStream);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码简洁了很多！而且这个closeQuietly方法可以运用到各类可关闭的对象中，保证了代码的重用性。CloseUtils的closeQuietly方法的基本原理就是依赖于Closeable抽象而不是具体实现（这不是1.4节中的依赖倒置原则么），并且建立在最小化依赖原则的基础，它只需要知道这个对象是可关闭，其他的一概不关心，也就是这里的接口隔离原则。</p>
<p>试想一下，如果在只是需要关闭一个对象时，它却暴露出了其他的接口函数，比如OutputStream的write方法，这就使得更多的细节暴露在客户端代码面前，不仅没有很好地隐藏实现，还增加了接口的使用难度。而通过Closeable接口将可关闭的对象抽象起来，这样只需要客户端依赖于Closeable就可以对客户端隐藏其他的接口信息，客户端代码只需要知道这个对象可关闭（只可调用close方法）即可。小民ImageLoader中的ImageCache就是接口隔离原则的运用，ImageLoader只需要知道该缓存对象有存、取缓存图片的接口即可，其他的一概不管，这就使得缓存功能的具体实现对ImageLoader具体的隐藏。这就是用最小化接口隔离了实现类的细节，也促使我们将庞大的接口拆分到更细粒度的接口当中，这使得我们的系统具有更低的耦合性，更高的灵活性。</p>
<p>Bob大叔（Robert C Martin）在21世纪早期将单一职责、开闭原则、里氏替换、接口隔离以及依赖倒置（也称为依赖反转）5个原则定义为SOLID原则，指代了面向对象编程的5个基本原则。当这些原则被一起应用时，它们使得一个软件系统更清晰、简单、最大程度地拥抱变化。SOLID被典型地应用在测试驱动开发上，并且是敏捷开发以及自适应软件开发基本原则的重要组成部分。在经过第1.1～1.5节的学习之后，我们发现这几大原则最终就可以化为这几个关键词：抽象、单一职责、最小化。那么在实际开发过程中如何权衡、实践这些原则，是大家需要在实践中多思考与领悟，正所谓”学而不思则罔，思而不学则殆”，只有不断地学习、实践、思考，才能够在积累的过程有一个质的飞越。</p>
<h2 id="更好的可扩展性——迪米特原则"><a href="#更好的可扩展性——迪米特原则" class="headerlink" title="更好的可扩展性——迪米特原则"></a>更好的可扩展性——迪米特原则</h2><p>迪米特原则英文全称为Law of Demeter，简称LOD，也称为最少知识原则（Least Knowledge Principle）。虽然名字不同，但描述的是同一个原则：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
<p>迪米特法则还有一个英文解释是：Only talk to your immedate friends，翻译过来就是：只与直接的朋友通信。什么叫做直接的朋友呢？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系的类型有很多，例如组合、聚合、依赖等。</p>
<p>光说不练很抽象呐，下面我们就以租房为例来讲讲迪米特原则。<br>“北漂”的同学比较了解，在北京租房绝大多数都是通过中介找房。我们设定的情境为：我只要求房间的面积和租金，其他的一概不管，中介将符合我要求的房子提供给我就可以。下面我们看看这个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 房间</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> area;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> price;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Room</span><span class="params">(<span class="keyword">float</span>  area, <span class="keyword">float</span>  price)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.area = area;</div><div class="line">        <span class="keyword">this</span>.price = price;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Room [area="</span> + area + <span class="string">", price="</span> + price + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 中介</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</div><div class="line">    List&lt;Room&gt; mRooms = <span class="keyword">new</span> ArrayList&lt;Room&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mediator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (inti = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            mRooms.add(<span class="keyword">new</span> Room(<span class="number">14</span> + i, (<span class="number">14</span> + i) * <span class="number">150</span>));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;Room&gt;getAllRooms() &#123;</div><div class="line">        <span class="keyword">return</span> mRooms;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 租户</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tenant</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> roomArea;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> roomPrice;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> diffPrice = <span class="number">100.0001f</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> diffArea = <span class="number">0.00001f</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rentRoom</span><span class="params">(Mediator mediator)</span> </span>&#123;</div><div class="line">        List&lt;Room&gt;rooms = mediator.getAllRooms();</div><div class="line">        <span class="keyword">for</span> (Room room : rooms) &#123;</div><div class="line">            <span class="keyword">if</span> (isSuitable(room)) &#123;</div><div class="line">             System.out.println(<span class="string">"租到房间啦! "</span> + room);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSuitable</span><span class="params">(Room room)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.abs(room.price - roomPrice) &lt; diffPrice</div><div class="line">                &amp;&amp;Math.abs(room.area - roomArea) &lt; diffArea;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面的代码中可以看到，Tenant不仅依赖了Mediator类，还需要频繁地与Room类打交道。租户类的要求只是通过中介找到一间适合自己的房间罢了，如果把这些检测条件都放在Tenant类中，那么中介类的功能就被弱化，而且导致Tenant与Room的耦合较高，因为Tenant必须知道许多关于Room的细节。当Room变化时Tenant也必须跟着变化。Tenant又与Mediator耦合，就导致了纠缠不清的关系。这个时候就需要我们分清谁才是我们真正的“朋友”，在我们所设定的情况下，显然是Mediator（虽然现实生活中不是这样的）。上述代码的结构如图1-5所示。<br><img src="http://img.blog.csdn.net/20151102135211486" alt="图1-5"><br>既然是耦合太严重，那我们就只能解耦了，首先要明确地是，我们只和我们的朋友通信，这里就是指Mediator对象。必须将Room相关的操作从Tenant中移除，而这些操作案例应该属于Mediator，我们进行如下重构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 中介</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</div><div class="line">    List&lt;Room&gt; mRooms = <span class="keyword">new</span> ArrayList&lt;Room&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mediator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (inti = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            mRooms.add(<span class="keyword">new</span> Room(<span class="number">14</span> + i, (<span class="number">14</span> + i) * <span class="number">150</span>));</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Room <span class="title">rentOut</span><span class="params">(<span class="keyword">float</span>  area, <span class="keyword">float</span>  price)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Room room : mRooms) &#123;</div><div class="line">            <span class="keyword">if</span> (isSuitable(area, price, room)) &#123;</div><div class="line">                <span class="keyword">return</span>  room;</div><div class="line">          &#125;</div><div class="line">       &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSuitable</span><span class="params">(<span class="keyword">float</span> area, <span class="keyword">float</span> price, Room room)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.abs(room.price - price) &lt; Tenant.diffPrice</div><div class="line">            &amp;&amp; Math.abs(room.area - area) &lt; Tenant.diffPrice;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 租户</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tenant</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> roomArea;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> roomPrice;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> diffPrice = <span class="number">100.0001f</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> diffArea = <span class="number">0.00001f</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rentRoom</span><span class="params">(Mediator mediator)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"租到房啦 "</span> + mediator.rentOut(roomArea, roomPrice));</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重构后的结构图如图1-6所示:<br><img src="http://img.blog.csdn.net/20151102135310062" alt="图1-6"><br>只是将对于Room的判定操作移到了Mediator类中，这本应该是Mediator的职责，他们根据租户设定的条件查找符合要求的房子，并且将结果交给租户就可以了。租户并不需要知道太多关于Room的细节，比如与房东签合同、房东的房产证是不是真的、房内的设施坏了之后我要找谁维修等，当我们通过我们的“朋友”中介租了房之后，所有的事情我们都通过与中介沟通就好了，房东、维修师傅等这些角色并不是我们直接的“朋友”。“只与直接的朋友通信”这简单的几个字就能够将我们从乱七八糟的关系网中抽离出来，使我们的耦合度更低、稳定性更好。<br>通过上述示例以及小民的后续思考，迪米特原则这把利剑在小民的手中已经舞得风生水起。就拿sd卡缓存来说吧，ImageCache就是用户的直接朋友，而SD卡缓存内部却是使用了jake wharton的DiskLruCache实现，这个DiskLruCache就不属于用户的直接朋友了，因此，用户完全不需要知道它的存在，用户只需要与ImageCache对象打交道即可。例如将图片存到SD卡中的代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap value)</span> </span>&#123;</div><div class="line">    DiskLruCache.Editor editor = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 如果没有找到对应的缓存，则准备从网络上请求数据，并写入缓存</span></div><div class="line">        editor = mDiskLruCache.edit(url);</div><div class="line">        <span class="keyword">if</span> (editor != <span class="keyword">null</span>) &#123;</div><div class="line">                OutputStream outputStream = editor.newOutputStream(<span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span> (writeBitmapToDisk(value, outputStream)) &#123;</div><div class="line">              <span class="comment">// 写入disk缓存</span></div><div class="line">                editor.commit();</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">                editor.abort();</div><div class="line">          &#125;</div><div class="line">            CloseUtils.closeQuietly(outputStream);</div><div class="line">       &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用户在使用SD卡缓存时，根本不知晓DiskLruCache的实现，这就很好地对用户隐藏了具体实现。当小民已经“牛”到可以自己完成SD卡的rul实现时，他就可以随心所欲的替换掉jake wharton的DiskLruCache。小民的代码大体如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将Bitmap写入文件中</span></div><div class="line">    FileOutputStream fos = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 构建图片的存储路径 ( 省略了对url取md5)</span></div><div class="line">        fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"sdcard/cache/"</span> + imageUrl2MD5(url));</div><div class="line">        bmp.compress(CompressFormat.JPEG, <span class="number">100</span>, fos);</div><div class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> ( fos != <span class="keyword">null</span> ) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                fos.close();</div><div class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">          &#125;</div><div class="line">       &#125;</div><div class="line">    &#125; <span class="comment">// end if finally</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>SD卡缓存的具体实现虽然被替换了，但用户根本不会感知到。因为用户根本不知道DiskLruCache的存在，他们没有与DiskLruCache进行通信，他们只认识直接“朋友”ImageCache，ImageCache将一切细节隐藏在了直接“朋友”的外衣之下，使得系统具有更低的耦合性和更好的可扩展性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在应用开发过程中，最难的不是完成应用的开发工作，而是在后续的升级、维护过程中让应用系统能够拥抱变化。拥抱变化也就意味着在满足需求且不破坏系统稳定性的前提下保持高可扩展性、高内聚、低耦合，在经历了各版本的变更之后依然保持清晰、灵活、稳定的系统架构。当然，这是一个比较理想的情况，但我们必须要朝着这个方向去努力，那么遵循面向对象六大原则就是我们走向灵活软件之路所迈出的第一步。</p>
<h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><ul>
<li><a href="http://www.devtf.cn/?p=1134" target="_blank" rel="external">开发技术前线:面向对象六大原则</a></li>
<li><a href="">Android源码设计模式解析与实战</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/11/Intellij-IDEA部署本地Tomcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/11/Intellij-IDEA部署本地Tomcat/" itemprop="url">Intellij IDEA部署本地Tomcat</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-11T22:15:36+08:00">
                2015-11-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一直以来用Eclipse都是用本地tomcat、IDEA都是tomcat/jetty的maven插件的方式来跑Web工程。之前使用让IDEA用本地tomcat的方式来运行却没成功，一直困惑不已。然而今天公司需要这样做，问了下同事终于把这问题解决了。所以记录下！</p>
<h2 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h2><h3 id="安装本地Tomcat"><a href="#安装本地Tomcat" class="headerlink" title="安装本地Tomcat"></a>安装本地Tomcat</h3><p>Tomcat和JDK的安装可以查看这里<a href="http://www.cnblogs.com/pannysp/archive/2012/03/07/2383364.html" target="_blank" rel="external">win7下安装配置tomcat,java运行环境</a>,具体的就不啰嗦了，这个步骤应该都操作过很多次了。但这是基础，jdk和tomcat没配好，接下来的所有工作都无法进行。</p>
<h3 id="安装Tomcat-and-TomEE-Integration"><a href="#安装Tomcat-and-TomEE-Integration" class="headerlink" title="安装Tomcat and TomEE Integration"></a>安装Tomcat and TomEE Integration</h3><p>因为IDEA要依赖”<strong>Tomcat and TomEE Integration</strong>“这个插件来运行tomcat，所以我们的IDEA必须要进行安装。ULTIMATE版本的已经自带了，社区版的好像要自己装 。可以在工具栏的<code>Run-&gt;Edit Configurations</code>，在弹出来的界面中点击<code>+</code>，输入<code>tomcat</code>看是否有<code>Tomcat Server</code>，有的话就是已经安装了，没有的话就去<code>Settings</code>里的插件中心安装即可。<br><img src="https://c1.staticflickr.com/1/773/22272123843_82e7e3a187_c.jpg" alt=""></p>
<h3 id="验证Project的Artifacts"><a href="#验证Project的Artifacts" class="headerlink" title="验证Project的Artifacts"></a>验证Project的Artifacts</h3><p>打开Project的<code>Module Setting(F4)</code>，看<code>Artifacts</code>里是不是有<code>&lt;project_name&gt;:war</code>和<code>&lt;project_name&gt;:war exploded</code>，如果你的是Web工程，一般都会有。如果没有就检查下是否是Web工程。<br><img src="https://c1.staticflickr.com/1/757/22883412036_19caf37b3b_c.jpg" alt=""></p>
<h3 id="添加服务器配置"><a href="#添加服务器配置" class="headerlink" title="添加服务器配置"></a>添加服务器配置</h3><p>依次打开<code>Run -&gt; Edit Configurations -&gt; + -&gt; Tomcat Server -&gt; Local</code>，输入如下图中的配置。<br><img src="https://c2.staticflickr.com/6/5720/22893261735_31e829dae6_c.jpg" alt=""><br><img src="https://c1.staticflickr.com/1/737/22474938568_aab1510c02_c.jpg" alt=""></p>
<h2 id="配置热部署"><a href="#配置热部署" class="headerlink" title="配置热部署"></a>配置热部署</h2><p>在服务器的配置过程中，热部署是一个很常用的功能。如果没有配置热部署，那么你每修改一个java文件，甚至一个jsp文件，都必须手动restart server，那将是多么痛苦的一件事。</p>
<p>上面的图中，<strong>On ‘Update’ action</strong>是你点击Update按钮后的动作。而<strong>On frame deactivation</strong>是热部署的关键，为了实现热部署我们应该把它设置为<strong>Update classed and resources</strong>。 但是有时候我们发觉只有Do nothing、Update resources这两个选项，并没有Update classed and resources这个选项。其实这是因为我们的war包是选了 <code>&lt;project_name&gt;:war</code>这个，只要选回<code>&lt;project_name&gt;:war exploded</code>这个就可以了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实本地tomcat的运行关键是依靠war包，而这个war包IDEA默认已经帮我们配置好了。所以把这个war包添加到tomcat的配置中就可以run on local了。</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://blog.csdn.net/dandandeshangni/article/details/44057871" target="_blank" rel="external">CSDN:idea 修改jsp页面需要重新部署项目的额问题</a></li>
<li><a href="http://www.cnblogs.com/pannysp/archive/2012/03/07/2383364.html" target="_blank" rel="external">win7下安装配置tomcat,java运行环境</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/25/链表-常见面试问题总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/25/链表-常见面试问题总结/" itemprop="url">链表-常见面试问题总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-25T02:56:01+08:00">
                2015-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近这段时间都在忙活校招，在面试的过程中遇到了很多有关链表的问题，由于以前没怎么搞过ACM，数据结构也忘的七七八八了，所以总体感觉回答得不是很好。昨天把链表的基础回顾了下，见这里<a href="http://www.luohuida.com/2015/10/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">单链表的基础操作</a>，于是今天把面试过程中经常遇到的链表相关的问题总结下。</p>
<h2 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h2><p>单链表的反转是面试的常用考点，所以必须掌握。思路是<strong>把当前节点拿过来作为已经翻转的表头，成为一个已翻转的子链，用result指向其头部（也就是当前节点）</strong>。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 反转单链表</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">traversingReverse</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">	Node result = <span class="keyword">null</span>;</div><div class="line">	Node temp = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 头反转法：把当前节点拿过来作为已经翻转结果的表头</span></div><div class="line">	<span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">		temp = head.next; <span class="comment">// 保存下一个节点</span></div><div class="line">		head.next = result; <span class="comment">// 当前节点放在结果的开头</span></div><div class="line">		result = head; <span class="comment">// 当前节点的头</span></div><div class="line">		head = temp; <span class="comment">// head指向下一个节点</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="懒删除-在O-1-时间删除链表节点"><a href="#懒删除-在O-1-时间删除链表节点" class="headerlink" title="懒删除(在O(1)时间删除链表节点)"></a>懒删除(在O(1)时间删除链表节点)</h2><p>有一种情况，当我们的now引用指向某一个节点的时候，我们需要删除该节点。然而如果不知道now节点的前驱节点，一般方法是无法删除now这个节点的。</p>
<p>这个时候，我们可以使用“懒”删除，这种方法的思想是：<strong>把now节点后驱节点的值赋给now节点，然后now节点的next指向的它后驱节点的下一个节点</strong>。因为不用遍历，所以这个算法的时间复杂度是O(1)。然而要注意的是尾节点，当now节点就是尾节点的时候，这种办法就行不通了。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// O(1)复杂度删除某个节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lazyDelete</span><span class="params">(Node now)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(now.next != <span class="keyword">null</span>) &#123; <span class="comment">// ①非尾节点</span></div><div class="line">        now.value = now.next.value; <span class="comment">// 复制后驱节点的值</span></div><div class="line">        now.next = now.next.next; <span class="comment">// “删除”后驱节点</span></div><div class="line">    &#125;  <span class="keyword">else</span>&#123; <span class="comment">// ②尾节点，行不通</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="求链表倒数第k个节点"><a href="#求链表倒数第k个节点" class="headerlink" title="求链表倒数第k个节点"></a>求链表倒数第k个节点</h2><p>经常会遇到求单链表倒数第几个节点的问题，如果按常规方法的话，我们需要先遍历整个链表，记录下节点个数，假设为n，然后再遍历一遍，第n-k+1个就是所求节点了。可是这个方法效率太低，需要两次遍历，有没有更加高效的方法呢？答案是肯定的。我们可以用 <strong>快慢指针</strong> 来解决这个问题，这个方法的思想是这样的：</p>
<blockquote>
<ul>
<li>假设有引用fast、slow，开始都指向首节点;</li>
<li>fast先走k次，这样fast和slow就相隔了k个节点;</li>
<li>然后fast、slow一起走，当fast走到链表末尾为null的时候，slow就是所求节点了。</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 求单链表倒数第k个节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getKNode</span><span class="params">(Node head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    Node fast = head;</div><div class="line">    Node slow = head;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(; i &lt; k &amp;&amp; fast != <span class="keyword">null</span>; i++) &#123;</div><div class="line">        fast = fast.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(i != k) &#123;</div><div class="line">        System.out.println(k + <span class="string">"位置超出链表长度"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span>) &#123;</div><div class="line">        fast = fast.next;</div><div class="line">        slow = slow.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> slow;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="求链表的中间节点"><a href="#求链表的中间节点" class="headerlink" title="求链表的中间节点"></a>求链表的中间节点</h2><p>如果要求一个链表的中间节点，常规的方法是先遍历一次获取链表的长度n，如果n是偶数就n/2、n/2+1都可以，如果n是奇数，那就第n/2+1个。可是这个方法的效率也是非常低。</p>
<p>其实通过上面找用快慢指针的方法来找倒数第k个数，我们可以衍生到这里来。这个方法的思路是这样的：</p>
<blockquote>
<ul>
<li>假设有引用fast、slow，开始都指向首节点;</li>
<li>fast、slow同时走，但是fast每次走2步，slow每次走1步；</li>
<li>当fast走到链表末尾时，slow就是中间节点；</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 求链表的中间节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getMiddleNode</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Node fast = head;</div><div class="line">    Node slow = head;</div><div class="line">    </div><div class="line">    <span class="comment">// ①如果fast==null的话，说明是偶数个；而fast.next==null的话，说明是奇数个</span></div><div class="line">    <span class="comment">// ①条件返回的是偶数情况中的后者，如果要返回前者，可用下面判断条件：</span></div><div class="line">    <span class="comment">// while (fast != null &amp;&amp; fast.next != null &amp;&amp; fast.next.next != null)</span></div><div class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123; <span class="comment">// ①</span></div><div class="line">        fast = fast.next.next; <span class="comment">// 快指针走2步</span></div><div class="line">        slow = slow.next; <span class="comment">// 慢指针走1步</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> slow;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="单链表是否存在环-leetcode-141"><a href="#单链表是否存在环-leetcode-141" class="headerlink" title="单链表是否存在环(leetcode 141)"></a>单链表是否存在环(leetcode 141)</h2><p>其实判断单链表是否有环有2种方法，第一种是用Set集合的方法，第二种是用快慢指针的方法。</p>
<h3 id="利用HashSet集合"><a href="#利用HashSet集合" class="headerlink" title="利用HashSet集合"></a>利用HashSet集合</h3><p>这个方法的思想很简单，就是<strong>遍历该链表，每走一次，就判断HashSet中是否存在该节点，如果存在则说明有环，结束；如果不存在，说明还没有环，把该节点放到HashSet中去，直到链表的末尾</strong>。如果利用的是HashSet，则该算法的时间复杂度也是O(n)，就是空间复杂度大了点。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 利用HashMap判断是否有环</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCircle</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    Set&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">    	<span class="keyword">if</span>(getFromSet(set, head) != <span class="keyword">null</span>) &#123;</div><div class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    	&#125;</div><div class="line">    	</div><div class="line">    	set.add(head);</div><div class="line">    	head = head.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 由于Set没有提供get()方法，所以自己实现一个</span></div><div class="line"><span class="comment">// 缘何Set不提供get()？？？</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getFromSet</span><span class="params">(Set&lt;Node&gt; set, Node node)</span> </span>&#123;</div><div class="line">	Iterator it = set.iterator();</div><div class="line">	Node tmp;</div><div class="line"></div><div class="line">	<span class="keyword">while</span>(it.hasNext()) &#123;</div><div class="line">		tmp = (Node)it.next();</div><div class="line">		<span class="keyword">if</span>(tmp == node) &#123;</div><div class="line">			<span class="keyword">return</span> tmp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="利用快慢指针"><a href="#利用快慢指针" class="headerlink" title="利用快慢指针"></a>利用快慢指针</h3><p>上面的方法实现起来很简单高效，但是却需要额外的空间，空间复杂度是O(n)，而快慢指针是一个更高效的方法。<strong>让快指针每次走2步，慢指针每次走1步，两个指针的速度不一样，如果存在环的话，那么最后快慢指针肯定会相遇</strong>。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 利用快慢指针判断链表是否有环</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCircle</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    Node fast = head;</div><div class="line">    Node slow = head;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</div><div class="line">        fast = fast.next.next;</div><div class="line">        slow = slow.next;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (fast == slow) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="单链表中环的起点-leetcode-142"><a href="#单链表中环的起点-leetcode-142" class="headerlink" title="单链表中环的起点(leetcode 142)"></a>单链表中环的起点(leetcode 142)</h2><p><img src="https://c1.staticflickr.com/1/620/22399861952_2440672711_c.jpg" alt="快慢指针求环起点"><br>假设链表中存在环，我们先设定几个参数：n(环的长度=7)、a(链表起点到环起点的距离=3)、x(fast指针到环起点的时候，slow指针在环中的位置0 &lt;= x &lt; n)，由此我们可以推出下面几个性质：</p>
<blockquote>
<ol>
<li>slow到起点(s3)的时候，fast在环中走了x步(f3)，那么fast和slow相差 n - x 步，也就是说 n - x 步后，fast会追上slow；</li>
<li>经过 n - x 步后(4步)，fast和slow在环中M点相遇(f7与s7)；</li>
<li>假设这时候相遇点M与环起点的距离为b(=4)，则slow走过的距离是 a + b ，而fast走过的距离为 a + b + k <em> n 。显然fast走的长度是slow的2倍，所以2 </em> ( a + b ) = a + b + k <em> n，则 **a + b = k </em> n**；</li>
<li>把fast指针拉回链表的起始点，这时候fast和slow每次都走一步，经过a步后，fast和slow在环的起始点相遇。</li>
</ol>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用快慢指针求环起点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listCircleStart</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    <span class="comment">// 空链或者单节点，不存在环</span></div><div class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Node fast = head;</div><div class="line">    Node slow = head;</div><div class="line">    </div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123; <span class="comment">// 无环</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        fast = fast.next.next; <span class="comment">// 走2步</span></div><div class="line">        slow = slow.next; <span class="comment">// 走1步</span></div><div class="line">    &#125; <span class="keyword">while</span> (fast != slow) <span class="comment">// 直到fast和slow相遇</span></div><div class="line">    </div><div class="line">    fast = head; <span class="comment">// 重新拉回链表起点</span></div><div class="line">    <span class="keyword">while</span> (fast != slow) &#123; <span class="comment">// 相遇即为环起点</span></div><div class="line">        fast = fast.next; <span class="comment">// 走1步</span></div><div class="line">        slow = slow.next; <span class="comment">// 走1步</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> fast;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="单链表中环的长度"><a href="#单链表中环的长度" class="headerlink" title="单链表中环的长度"></a>单链表中环的长度</h2><p>在上面，我们找到环的起点后，再用slow指针走一遍，就可以算出环的长度了。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用快慢指针求环长度</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">listCircleLength</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    Node cicleStart = listCircleStart(head); <span class="comment">// 先利用上面的方法求出环起点</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(cicleStart == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Node tmp = cicleStart.next;</div><div class="line">    <span class="keyword">int</span> counter = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (tmp != cicleStart) &#123; <span class="comment">// 重走一遍，直到回到环起点</span></div><div class="line">        counter++;</div><div class="line">        tmp = tmp.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="两个链表是否相交并求出交点-leetcode-160"><a href="#两个链表是否相交并求出交点-leetcode-160" class="headerlink" title="两个链表是否相交并求出交点(leetcode 160)"></a>两个链表是否相交并求出交点(leetcode 160)</h2><p>给定2个链表，判断这两个链表是否相交，如果相交的话，就类似于一个向左翻转90°的Y。见下图：<br><img src="https://c1.staticflickr.com/1/649/22234956790_1986323deb_c.jpg" alt="相交链表"></p>
<p>这个问题相比环来说简单很多，我们可以用Set集合方法、链长先走方法、成环方法来解决。下面我们逐一来看。</p>
<h3 id="Set集合方法"><a href="#Set集合方法" class="headerlink" title="Set集合方法"></a>Set集合方法</h3><p>这个方法的思路最简单：</p>
<blockquote>
<ol>
<li>先遍历a链，依次把所有节点放入到Set中去；</li>
<li>然后遍历b链，每到一个节点，就去Set看是否存在该节点，如果存在，则说明有交点，而交点就是该节点(第一个相等的肯定是交点)；</li>
<li>如果直到b链的末尾都没有相等节点，则说明没有交点；</li>
</ol>
</blockquote>
<p>这个方法其实比较笨，效率也比较低。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 利用Set求2链表交点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getCrossNode</span><span class="params">(Node headA, Node headB)</span> </span>&#123;</div><div class="line">    Set&lt;Node&gt; set = <span class="keyword">new</span> Hash&lt;&gt;();</div><div class="line">    </div><div class="line">    <span class="comment">// 把a链全部放入Set中</span></div><div class="line">    <span class="keyword">while</span> (headA != <span class="keyword">null</span>) &#123;</div><div class="line">        set.add(headA);</div><div class="line">        headA = headA.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 遍历b链</span></div><div class="line">    <span class="keyword">while</span> (headB != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(set.getFromSet(set, headB) != <span class="keyword">null</span>) &#123; <span class="comment">// 相交</span></div><div class="line">            <span class="keyword">return</span> headB;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getFromSet</span><span class="params">(Set&lt;Node&gt; set, Node node)</span> </span>&#123;</div><div class="line">	Iterator it = set.iterator();</div><div class="line">	Node tmp;</div><div class="line"></div><div class="line">	<span class="keyword">while</span>(it.hasNext()) &#123;</div><div class="line">		tmp = (Node)it.next();</div><div class="line">		<span class="keyword">if</span>(tmp == node) &#123;</div><div class="line">			<span class="keyword">return</span> tmp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="链长先走方法"><a href="#链长先走方法" class="headerlink" title="链长先走方法"></a>链长先走方法</h3><p>这个方法的思路是这样的：</p>
<blockquote>
<ol>
<li>遍历一次，求出链a的长度x，链b的长度y，求出|x-y|=k，这个k是链a和链b的长度差；</li>
<li>让长的链先走k步，这样a、b链剩下的长度都是一样的；</li>
<li>然后a、b一起走，遇到相等的节点，就是它们的交点；如果没相遇，说明没有交点；</li>
</ol>
</blockquote>
<p>这个方法比Set的方法好很多，因为不用用到Set集合，所以快很多。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 链长先走求2链交点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getCrossNode</span><span class="params">(Node headA, Node headB)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="comment">// 链a长度</span></div><div class="line">    <span class="keyword">int</span> y = <span class="number">0</span>; <span class="comment">// 链b长度</span></div><div class="line">    </div><div class="line">    Node tmp = headA; <span class="comment">// 因为后续还要用到headA，所以用临时变量来遍历</span></div><div class="line">    <span class="keyword">while</span>(tmp != <span class="keyword">null</span>) &#123;</div><div class="line">        x++;</div><div class="line">        tmp = tmp.next;</div><div class="line">    &#125;</div><div class="line">    tmp = headB;</div><div class="line">    <span class="keyword">while</span>(tmp != <span class="keyword">null</span>) &#123;</div><div class="line">        y++;</div><div class="line">        tmp = tmp.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> k; <span class="comment">// 链长度差</span></div><div class="line">    <span class="keyword">if</span> (x - y &gt; <span class="number">0</span>) &#123; <span class="comment">// a链长</span></div><div class="line">        k = x - y;</div><div class="line">        </div><div class="line">        <span class="comment">// a链走k步</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</div><div class="line">            headA = headA.next;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        k = y - x;</div><div class="line">        </div><div class="line">        <span class="comment">// b链走k步</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</div><div class="line">            headB = headB.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 这时候，headA指向的子链和headB指向的子链长度一样，一起走</span></div><div class="line">    <span class="keyword">while</span> (headA != <span class="keyword">null</span>) &#123; <span class="comment">// 这里不需要判断headB，因为headA和headB肯定同时为null</span></div><div class="line">        <span class="keyword">if</span>(headA == headB) &#123; <span class="comment">// 相遇的节点是交点</span></div><div class="line">            <span class="keyword">return</span> headA</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        headA = headA.next;</div><div class="line">        headB = headB.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="成环方法"><a href="#成环方法" class="headerlink" title="成环方法"></a>成环方法</h3><p>我们把a链的首尾连接起来，这样a链就形成了一个环。如果a、b链相交，那么从b链来看，链b这个时候就会出现环路，我们可以用上面找环的方法来解决。如下图：<br><img src="https://c1.staticflickr.com/1/583/22236866799_dbacbb5d5e_c.jpg" alt="成环方法求两链交点"></p>
<p>这个方法的思路如下：</p>
<blockquote>
<ol>
<li>把a链的尾部指向a链头部，让其形成一个环；</li>
<li>从b链头部开始遍历，如果b中能找到环，说明ab相交，环的起点即为交点；如果不能找到环，说明无交点；</li>
<li>把a链中的环断开，恢复链a；</li>
</ol>
</blockquote>
<p>这个方法的代码和找环的代码差不多，这里就不写了。</p>
<h2 id="复制带有随机指针的链表-leetcode-138"><a href="#复制带有随机指针的链表-leetcode-138" class="headerlink" title="复制带有随机指针的链表(leetcode 138)"></a>复制带有随机指针的链表(leetcode 138)</h2><p>一个单链表除了next指针外，还有一个random指针，random指针随机指向任何一个元素(可能为null)，然后我们的任务是复制它。</p>
<p>这个复制其实next指针直接用常规方法就能解决，<strong>难点在于random指针，因为我们不知道random指针在复制后的地址-复制元素的地址变了，而且random指向的元素可能还没生成</strong>。</p>
<p>要解决这个问题，我们有2种方法：map集合方法、“副本”方法。</p>
<h3 id="map集合方法"><a href="#map集合方法" class="headerlink" title="map集合方法"></a>map集合方法</h3><p>这个方法的思路是这样的：</p>
<blockquote>
<ol>
<li>先遍历一次原链，用常规方法复制一个新链，使其next指针指向正确的位置，random指针为null；而且在这个过程中，每生成一个新节点，用map来保存旧节点到新节点的映射，类似与map(oldNode, newNode);</li>
<li>再同时遍历原链和新链，在原链中得到节点的random指向的oldNode，然后利用map.get(oldNode)获取newCode，把新链节点的random指向这个newNode；</li>
</ol>
</blockquote>
<p>结合下图：<br><img src="https://c1.staticflickr.com/1/602/22251236159_7a98624fd3_c.jpg" alt="利用map复制带random的链表"></p>
<p>容易知道，这个方法的时间复杂度是O(n)，空间复杂度也是O(n)，效率比较低。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 利用map实现带random指针的链表复制</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NodeWithRandom <span class="title">copyWithRandom</span> <span class="params">(NodeWithRandom h)</span> </span>&#123;</div><div class="line">	NodeWithRandom newNode = <span class="keyword">null</span>;</div><div class="line">	Map&lt;NodeWithRandom, NodeWithRandom&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">	map.put(<span class="keyword">null</span>, <span class="keyword">null</span>); <span class="comment">// 解决random指向null的情况</span></div><div class="line"></div><div class="line">	<span class="comment">// 先用常规方法复制链表</span></div><div class="line">	NodeWithRandom tmp1 = h;</div><div class="line">	NodeWithRandom h2 = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">while</span> (tmp1 != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span>(newNode == <span class="keyword">null</span>) &#123; <span class="comment">// 表头</span></div><div class="line">			newNode = <span class="keyword">new</span> NodeWithRandom(tmp1.value);</div><div class="line">			h2 = newNode;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			newNode.next = <span class="keyword">new</span> NodeWithRandom(tmp1.value);</div><div class="line">			newNode = newNode.next;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		map.put(tmp1, newNode); <span class="comment">// 旧地址到新地址的映射</span></div><div class="line">		tmp1 = tmp1.next;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 再两个链表同时走复制random，a'.random = map[a.random]</span></div><div class="line">	tmp1 = h;</div><div class="line">	NodeWithRandom tmp2 = h2;</div><div class="line">	<span class="keyword">while</span> (tmp1 != <span class="keyword">null</span>) &#123;</div><div class="line">		tmp2.random = map.get(tmp1.random); <span class="comment">// 利用map的映射，将新链表的random指针指向新节点</span></div><div class="line">		tmp1 = tmp1.next;</div><div class="line">		tmp2 = tmp2.next;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> h2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 带random的节点</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeWithRandom</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> value;</div><div class="line">	<span class="keyword">public</span> NodeWithRandom next;</div><div class="line">	<span class="keyword">public</span> NodeWithRandom random;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NodeWithRandom</span> <span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.value = value;</div><div class="line">		<span class="keyword">this</span>.next = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">this</span>.random = <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="“副本”方法"><a href="#“副本”方法" class="headerlink" title="“副本”方法"></a>“副本”方法</h3><p>这个方法的思路主要是：</p>
<blockquote>
<ol>
<li>new副本：在每个旧节点后插入一个当前节点的副本，重新拉成链；</li>
<li>复制random：新节点的random=旧节点random的next；</li>
<li>拆分：奇数项都是旧节点，偶数项都是新节点，提取偶数项成链；</li>
</ol>
</blockquote>
<p>如下图：<br><img src="https://c1.staticflickr.com/1/745/22428455812_4c8560e01e_c.jpg" alt="“副本”方法复制带随机指针的链表"></p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// "副本"方式复制带随机指针链表</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NodeWithRandom <span class="title">copyRandomList</span> <span class="params">(NodeWithRandom head)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 在每个节点后创建副本，拉成链</span></div><div class="line">	NodeWithRandom now = head; </div><div class="line">	<span class="keyword">while</span> (now != <span class="keyword">null</span>) &#123;</div><div class="line">		NodeWithRandom copy = <span class="keyword">new</span> NodeWithRandom(now.value);</div><div class="line">		copy.next = now.next;</div><div class="line">		now.next = copy;</div><div class="line"></div><div class="line">		now = copy.next;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 复制random</span></div><div class="line">	<span class="keyword">for</span> (now = head; now != <span class="keyword">null</span>; now = now.next.next) &#123;</div><div class="line">		now.next.random = now.random == <span class="keyword">null</span> ? <span class="keyword">null</span> : now.random.next; <span class="comment">// 新节点的random=旧节点random的next</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 奇数项为旧节点，偶数项为新节点</span></div><div class="line">	<span class="comment">// 提取出偶数项就是所求</span></div><div class="line">	NodeWithRandom h = head.next; <span class="comment">// 新链头部</span></div><div class="line">	NodeWithRandom t = h; <span class="comment">// 遍历游标</span></div><div class="line">	NodeWithRandom tail = head;</div><div class="line">	<span class="keyword">for</span> (;;) &#123;</div><div class="line">		tail.next = t.next; <span class="comment">// 重连旧节点</span></div><div class="line">		tail = tail.next; <span class="comment">// 移向下一个旧节点</span></div><div class="line">		<span class="keyword">if</span>(tail == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		t.next = tail.next; <span class="comment">// 连接新节点</span></div><div class="line">		t = t.next; <span class="comment">// 移向下一个新节点</span></div><div class="line">	&#125; </div><div class="line"></div><div class="line">	<span class="keyword">return</span> h;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="链表partition过程-leetcode-86"><a href="#链表partition过程-leetcode-86" class="headerlink" title="链表partition过程(leetcode 86)"></a>链表partition过程(leetcode 86)</h2><p>链表里存放整数，给定x，把x小的节点放在&gt;=x之前，这就是一个partition过程，数组在partition的过程就是这样做的。然而链表和数组不同的是，在patition的过程中，链表没必要赋值来赋值去，而是重新起一个头，把比x小的连起来，把&gt;=x的连成另外一条链，最后再把这2条链连起来就是了。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 链表的partition过程</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Node</span><span class="params">(Node head, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    Node h1 = <span class="keyword">null</span>; <span class="comment">// 小子链头部</span></div><div class="line">    Node h2 = <span class="keyword">null</span>; <span class="comment">// 大子链头部</span></div><div class="line">    Node t1 = <span class="keyword">null</span>; <span class="comment">// 小子链尾部</span></div><div class="line">    Node t2 = <span class="keyword">null</span>; <span class="comment">// 大子链尾部</span></div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (; head != <span class="keyword">null</span>; head = head.next) &#123;</div><div class="line">        <span class="keyword">if</span> (head.val &lt; x) &#123; <span class="comment">// 比x小</span></div><div class="line">            <span class="keyword">if</span> (h1 = <span class="keyword">null</span>) &#123; <span class="comment">// 头部</span></div><div class="line">                h1 = head;</div><div class="line">                t1 = head;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                t1.next = head;</div><div class="line">                t1 = t1.next;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (h2 == <span class="keyword">null</span>) &#123;</div><div class="line">                h2 = head;</div><div class="line">                t2 = head;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                t2.next = head;</div><div class="line">                t2 = t2.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (t2 != <span class="keyword">null</span>) &#123; <span class="comment">// 大子链有节点</span></div><div class="line">        t2.next = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(t1 != <span class="keyword">null</span>) &#123; <span class="comment">// 小子链有节点</span></div><div class="line">        t1.next = h2;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> h1 != <span class="keyword">null</span> ? h1 : h2;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面可以看出，涉及链表的问题，大部分都可以用快慢指针或集合的方式来解决，所以遇到这种问题可以往这方面考虑。由于链表实在非常灵活，所以具体的问题还是得灵活处理。</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://wuchong.me/blog/2014/03/25/interview-link-questions/" target="_blank" rel="external">面试精选：链表问题集锦</a></li>
<li><a href="http://www.julyedu.com/video/play/?id=31&amp;course=25" target="_blank" rel="external">七月算法：链表面试精讲</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/14/单链表的基础操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/14/单链表的基础操作/" itemprop="url">单链表的基础操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-14T00:01:36+08:00">
                2015-10-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们知道，线性表分为顺序表和链式表。顺序表是基于数组的存储表示，其特点是用物理位置上的邻接关系来表示结点间的逻辑关系。但是基于数组的顺序表的缺点也非常明显，比如说插入/删除的效率低下（平均需要移动一半元素）、需要预先进行存储分配等。</p>
<p>为了克服顺序表的缺点，可以采用链接方式来存储线性表，通常将链接方式的线性表称为链表。<strong>链表适用于插入/删除频繁，存储空间不确定的场景</strong>。单链表的特点是<strong>长度可以很方便地进行扩充，其数据元素的顺序与其链表表示中节点的物理顺序可能不一致，一般通过单链表的指针将各个数据元素按照线性表的逻辑顺序连接起来</strong>，如下图：<br><img src="https://c1.staticflickr.com/1/631/21509590143_579b0d0b40_z.jpg" alt="单链表示意图"></p>
<p>由于链表的每个节点带有指针域(引用)，因而在存储空间上比顺序表要付出较大的代价。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>创建单链表主要有前插和后插两种方法，建立的方式不同，最终得到的链表也不相同。</p>
<h3 id="前插法建立单链表"><a href="#前插法建立单链表" class="headerlink" title="前插法建立单链表"></a>前插法建立单链表</h3><p>前插法是指每次插入新节点总是在表的前端进行，这样插入的结果是<strong>链表中各节点中数据的逻辑顺序与输入顺序是正好相反的</strong>。其主要步骤如下：</p>
<blockquote>
<ol>
<li>生成新节点newNode，将读入数据存放到newNode的data域中；</li>
<li>将newNode插入到链表的前端；</li>
</ol>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 建立链表</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">buildList</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">	Node first = <span class="keyword">null</span>;</div><div class="line">	Node newNode = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 头插入法</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">		newNode = <span class="keyword">new</span> Node(i);</div><div class="line">		newNode.next = first;</div><div class="line">		first = newNode;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> first;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="后插法建立单链表"><a href="#后插法建立单链表" class="headerlink" title="后插法建立单链表"></a>后插法建立单链表</h3><p>后插法是指每次newNode总是插入到链表的尾端，这样插入的结果，链表中各个节点的逻辑顺序和输入数据的顺序是完全一致的。这个方法需要设置一个<strong>尾指针last</strong>，总是指向新链表中最后一个节点，新节点连接到它所指链尾的后面。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">buildListLast</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">	Node first = <span class="keyword">null</span>;</div><div class="line">	Node last = <span class="keyword">null</span>;</div><div class="line">	Node now = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 后插法</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">		now = <span class="keyword">new</span> Node(i);</div><div class="line">		now.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(first == <span class="keyword">null</span>) &#123;				</div><div class="line">			first = now;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			last.next = now;				</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		last = now;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> first;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>利用单链表来表示线性表，将使得插入和删除变得非常方便，只要修改链中节点指针或引用的值，无需移动表中的元素，就能高效地实现插入和删除操作。</p>
<p>对于插入，我们希望在单链表（a1，a2，a3，…an）的包含数据ai的节点之后插入一个newNode，那么可能会出现3种情况：</p>
<ol>
<li><p>插入到链表头部。这个时候newNode应插入在<strong>第一个节点之前</strong>，如下图a所示。这时必须修改头指针first。插入操作为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">newNode.next = first；</div><div class="line">first = newNode;</div></pre></td></tr></table></figure>
</li>
<li><p>插入到链表中间。此时，首先让一个<strong>检测指针current</strong>指向ai所在节点，再将新节点插入到ai之后，如下图b所示。插入操作为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">newNode.next = current.next;</div><div class="line">current.next = newNode;</div></pre></td></tr></table></figure>
</li>
<li><p>插入到链表尾端。新节点追加到表尾，如下图c所示。这时，应先令检测指针current指向最后一个节点an，再执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">newNode.next = current.next;</div><div class="line">current.next = newNode;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://c2.staticflickr.com/6/5658/21510886033_db7ebd8b1b_z.jpg" alt="链表插入的示例"></p>
<p>从上面可以看出，2和3情形的操作一致，所以这2中情况可以合并考虑。综上，最后可得单链表的插入算法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将新元素插入到第index个节点之后。index从1开始，index = 0表示插入到第一个节点之前</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">insert</span><span class="params">(Node first, Node newNode, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">	<span class="comment">// ①如果链表为空，或者插入的索引为0，则插入到前端</span></div><div class="line">	<span class="keyword">if</span>(first == <span class="keyword">null</span> || index == <span class="number">0</span>) &#123;</div><div class="line">		newNode.next = first;</div><div class="line">		first = newNode;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		Node current = first;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; index; k++) &#123;</div><div class="line">			<span class="keyword">if</span>(current == <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				current = current.next;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(current == <span class="keyword">null</span>) &#123;</div><div class="line">			System.out.println(<span class="string">"无效的插入位置"</span>);</div><div class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//  ②插入中间或尾部</span></div><div class="line">			newNode.next = current.next;</div><div class="line">			current.next = newNode;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> first;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>单链表的删除算法比较简单，但也分为2种情况：</p>
<ol>
<li><p>删除头部。这时需要用一个del引用先保存头部节点，再将表头引用指向下一个节点，使其成为新链表的头部，最后删除del保存的节点。如下图a所示。删除操作为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Node del = first;</div><div class="line">first = first.next;</div><div class="line">del = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>删除中间节点或尾部。设删除链表中的第i个节点，首先用引用del保存第i个节点，再让第i-1个节点的next引用指向第i+1个节点，通过重新拉链，把第i个节点从链表中分离出来，最后删除del引用的节点。如下图b所示。删除操作为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Node del = current.next;</div><div class="line">current.next = del.next;</div><div class="line">del = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://c2.staticflickr.com/6/5783/21948392158_887cc9754b_z.jpg" alt="在单链表中删除ai节点"></p>
<p>由此可得单链表的删除算法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将链表的第index个元素删除，index从1开始</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">delete</span><span class="params">(Node first, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">	Node del = <span class="keyword">null</span>;</div><div class="line">	Node current = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(index &lt; <span class="number">1</span>) &#123; <span class="comment">// ①删除头结点</span></div><div class="line">		del = first;</div><div class="line">		first = first.next;</div><div class="line">		del = <span class="keyword">null</span>; <span class="comment">// 让GC回收</span></div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		current = first;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; index - <span class="number">1</span>; k++) &#123;</div><div class="line">			<span class="keyword">if</span>(current == <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				current = current.next;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(current == <span class="keyword">null</span> || current.next == <span class="keyword">null</span>) &#123;</div><div class="line">			System.out.println(<span class="string">"无效的删除位置"</span>);</div><div class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// ②删除中间节点或尾部节点</span></div><div class="line">			del = current.next;</div><div class="line">			current.next = del.next;</div><div class="line">			del = <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> first;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>遍历应该是最简单的了，直接看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 遍历链表</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traveling</span><span class="params">(Node first)</span> </span>&#123;</div><div class="line">	Node h = first;   </div><div class="line"></div><div class="line">    <span class="keyword">while</span> (h != <span class="keyword">null</span>) &#123;   </div><div class="line">        System.out.print(h.value + <span class="string">" "</span>);   </div><div class="line">        h = h.next;   </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了链表的相关基础操作：创建、插入、删除、遍历。链表本身很灵活，所以很考察编程功底，所以掌握基础至关重要，接下来还会再写一篇，记录下其他链表的其他进一步的运用。</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="">数据结构(用面向对象方法与C++语言描述) 第二版 殷人昆主编 清华大学出版社</a></li>
<li><a href="http://www.julyedu.com/video/play/?id=31&amp;course=25" target="_blank" rel="external">七月算法：链表面试精讲</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/13/设计模式系列一之单例模式-Singleton/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/13/设计模式系列一之单例模式-Singleton/" itemprop="url">设计模式系列一之单例模式(Singleton)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-13T12:14:39+08:00">
                2015-10-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>学习设计模式的时候，经常会以单例模式作为第一个案例来分析，因为这个模式比较简单，容易理解。但其实一旦牵涉到并发的时候，单例模式也往往很多问题。所以需要系统的梳理一下。</p>
<p>单例模式是一种<code>创建型模式</code>，在Java应用中，单例对象必须保证在一个Java虚拟机中，该对象有且只能有一个实例。这个模式有一下几种应用场景（或者说有这么些优点）：</p>
<blockquote>
<ul>
<li>某些类的实例对象创建，开销比较大，消耗很多的系统资源；</li>
<li>对于某些频繁使用的对象，减少new操作，避免在Java堆中产生过多实例，降低GC压力；</li>
<li>在某些场景中，多个实例对象会导致系统错乱。类似于一个Company有多个CEO，听谁的。</li>
</ul>
</blockquote>
<p>以上这几种情况就非常适合使用单例模式来解决。</p>
<p>单例模式有一下几个特点：</p>
<blockquote>
<ul>
<li>必须保持只有一个实例；</li>
<li>必须自己创建一个自己的实例（因为构造方式是private的）；</li>
<li>必须为其他对象提供唯一的实例（需要提供一个getInstance()方法）；</li>
</ul>
</blockquote>
<p>单例模式主要有以下5种方式，逐一分析下。</p>
<h2 id="饿汉式（线程安全）"><a href="#饿汉式（线程安全）" class="headerlink" title="饿汉式（线程安全）"></a>饿汉式（线程安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="comment">// 类加载的时候就会初始化，这个过程有且仅有一次</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line"></div><div class="line">    <span class="comment">// 私有的构造方法</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 对外提供唯一的Singleton实例</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式非常简单，因为单例的实例被声明为<code>static</code>和<code>final</code>，在JVM第一次加载该单例类到内存中的时候就会初始化【1】，所以创建实例本身是线程安全的。</p>
<p>然而这种方式的缺点也是显而易见的：</p>
<blockquote>
<ul>
<li>这个方式不是<code>懒加载模式</code>（lazy initialization），单例会在第一次加载的时候就被初始化，即使客户端没有调用getInstance()方法。这个时候如果单例类的开销比较大或者时间花费较多，就会降低系统效率。</li>
<li>在一些场景中是无法使用这种方式的：比如Singleton的创建是依赖参数或配置文件的，在getInstance之前必须调用某个方法设置参数给它，那么这种单例就无法使用了。</li>
</ul>
</blockquote>
<h2 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// a</span></div><div class="line">            <span class="comment">// 为了加大出现线程问题的概率，我们在这里休眠1秒</span></div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            instance = <span class="keyword">new</span> Singleton(); <span class="comment">// b</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码简单明了，而且使用了懒加载模式，但是却存在着致命伤。当有多个线程同时运行这段代码的时候，就非常可能创建出多个实例，也就是说这个单例类在并发环境中是无法正确运行的。</p>
<p>我们来分析下出现错误的原因：假设有2个线程同时来到了a处，此时的instance为null。假设线程1先进入if语句块中，但是还没执行b，就交出了CPU使用权。接着线程2获取CPU使用权，进入if语句块，执行了b，生成一个对象，这时候交出了CPU使用权。<strong>这时候，线程1接着执行b，又生成了一个对象</strong>。而在这2个对象的创建期间，其他类可能调用了getInstance()方法，极大可能调用了第1个对象，然后第2个对象创建后，其他类又调用的是第2个对象。这就严重违反了单例模式的核心功能，<strong>所以这种写法是完全不正确的</strong>。</p>
<h2 id="懒汉式（synchronized）"><a href="#懒汉式（synchronized）" class="headerlink" title="懒汉式（synchronized）"></a>懒汉式（synchronized）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// a</span></div><div class="line">            <span class="comment">// 为了出现线程问题，我们在这里休眠1000毫秒。(当然这里并不出现线程安全问题)</span></div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            instance = <span class="keyword">new</span> Singleton(); <span class="comment">// b：这里不会释放掉对象锁，所以其他线程无法进入</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了解决线程安全问题，我们需要使用Java提供的同步机制。为此我们用<code>synchronized</code>关键字来修饰getInstance()方法。</p>
<p>这种方式虽然做到了线程安全，但是却也并不高效。<strong>因为每次只能有一个线程调用getInstance()方法，但是明显同步操作只需要在第一次初始化的时候才被需要</strong>。为此我们引入了双重校验锁。</p>
<h2 id="懒汉式（双重校验锁Double-Checked-Locking）"><a href="#懒汉式（双重校验锁Double-Checked-Locking）" class="headerlink" title="懒汉式（双重校验锁Double Checked Locking）"></a>懒汉式（双重校验锁Double Checked Locking）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;<span class="comment">// private static volatile Singleton instance;</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;<span class="comment">// 第一次校验</span></div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;<span class="comment">// 锁</span></div><div class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;<span class="comment">// 第二次校验</span></div><div class="line">                    Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    instance = <span class="keyword">new</span> Singleton();<span class="comment">// a：可加赋值的内存屏障</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实这种方式本质上就是在同步方式的基础上再加一层校验（也就是if语句判断），只不过把同步的方法换成了同步块。</p>
<p>但是这段代码还是可能出现问题，问题出现在a处<code>instance = new Singleton();</code>这句代码并非是一个原子操作【2】，JVM大概做了3件事：</p>
<ol>
<li>【分配引用内存】给instance分配内存；</li>
<li>【分配实例内存】调用Singleton的构造函数来初始化成员变量；</li>
<li>【引用指向实例地址】将instance引用指向分配的实例内存，这时候instance才不为null；</li>
</ol>
<p>但是JVM可能存在<code>指令重排序</code>，也就是说上面的2、3顺序是不一定的，最终执行顺序可能是1-2-3，也可能是1-3-2，如果是后者，则在执行完3、2未执行的时候，被线程2夺取了CPU，那么这个时候<strong>instance不为null，但是却没有初始化</strong>，所以线程2直接就返回了instance，使用的时候就报错了。</p>
<p>为此我们需要把intance声明为<code>volatile</code>，有部分人认为volatile是保证了可见性，也就是保证线程在本地内存中不会存有instance的副本，每次都是去主内存中获取。但其实是不对的，即使是保证了可见性，也还是会出现上面的问题。使用volatile的主要原因是其另外一个特性：<code>禁止指令重排序</code>。<strong>在volatile变量的赋值操作后，会生成一个内存屏障（在汇编代码上），读操作不会被重排序到内存屏障前</strong>。比如上面的例子，取操作必须在执行完1-2-3或1-3-2后，不存在执行到1-3后读取instance的情况。从“<a href="http://www.luohuida.com/2015/08/28/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/#先行发生原则" target="_blank" rel="external">先行发生原则</a>”的角度来理解的话，就是对于一个volatile变量的写操作是先行发生与后面对这个变量的读操作（这里的后面指的是时间概念）。</p>
<p>但是特别注意的是，在JDK1.5之前，使用volatile的双重校验锁还是有问题的。因为JDK1.5之前的内存模型是存在缺陷的，即使将变量声明为volatile也不能完全避免重排序，主要是volatile变量前后的代码仍然存在重排序问题。在JDK1.5及之后这个问题得到了修复，可以放心使用。</p>
<h2 id="静态内部类方式"><a href="#静态内部类方式" class="headerlink" title="静态内部类方式"></a>静态内部类方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>静态内部类是最被提倡使用的方式，在《effective java》上也是被推荐的。这种写法仍然使用了JVM本身机制保证了线程安全问题。由于SingletonHolder是私有的，除了getInstance()没有其他方法能够访问它，因此它是懒汉式的。同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。这种方式其实是懒汉式和饿汉式的结合。</p>
<p>这种方式使用一个私有静态内部类来维护单例的实现，JVM内部机制保证当一个类被加载时，这个类的加载过程是线程互斥的。这样，当我们第一次调用getInstance()方法的时候，JVM能够帮助我们保证INSTANCE只被创建一次，并且会保证把赋值给INSTANCE的内存初始化完毕，这样我们就不用担心上面的问题了。同时该方法也只会在第一次使用的时候使用互斥机制，这样就解决了低性能的问题。</p>
<h2 id="枚举法"><a href="#枚举法" class="headerlink" title="枚举法"></a>枚举法</h2><p>在《Effective Java》最后提供了枚举法来实现单例模式，不仅简单，而且保证了线程安全。此外，这个方法还提供了防止序列化和反射创建多个实例的问题，即使面对复杂的序列化和反射攻击（不清楚序列化和反射攻击的，可以看这里 <a href="http://archerda.github.io/2017/11/13/设计模式系列之单例模式的破坏/" target="_blank" rel="external">单例模式的破坏</a>）。</p>
<blockquote>
<p>单元素的枚举类型已经成为实现Singleton的最佳方法。《Effective Java》</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</div><div class="line">    INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，在枚举类，构造方法自动声明为private，同时每个元素都自动声明为static final，表明元素只能被实例化一次。也就是说，enum里的实例都只会被实例化一次，所以我们INSTANCE也被保证只实例化一次。此外，我们看一下enum的定义:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span></div></pre></td></tr></table></figure></p>
<p>可以看出，Enum实现了序列化接口，即提供了序列化机制。</p>
<h3 id="枚举是如何防止序列化生成多个实例的"><a href="#枚举是如何防止序列化生成多个实例的" class="headerlink" title="枚举是如何防止序列化生成多个实例的"></a>枚举是如何防止序列化生成多个实例的</h3><p>我们知道，反序列化实例化对象是通过<code>ObjectInputStream</code>的<code>readObject</code>方法实现的，其中枚举的调用链是：</p>
<blockquote>
<p><strong>readObject</strong> -&gt; <strong>readObject0</strong> -&gt; <strong>readEnum</strong> -&gt; <strong>checkResolve</strong></p>
</blockquote>
<p>我们重点来看readEnum方法，部分实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Enum&lt;?&gt; readEnum(<span class="keyword">boolean</span> unshared) <span class="keyword">throws</span> IOException &#123;</div><div class="line">       ...</div><div class="line"></div><div class="line">        String name = readString(<span class="keyword">false</span>);</div><div class="line">        Enum&lt;?&gt; result = <span class="keyword">null</span>;</div><div class="line">        Class&lt;?&gt; cl = desc.forClass();</div><div class="line">        <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);</div><div class="line">                result = en;</div><div class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</div><div class="line">                <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidObjectException(</div><div class="line">                    <span class="string">"enum constant "</span> + name + <span class="string">" does not exist in "</span> +</div><div class="line">                    cl).initCause(ex);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!unshared) &#123;</div><div class="line">                handles.setObject(enumHandle, result);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        handles.finish(enumHandle);</div><div class="line">        passHandle = enumHandle;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>看第10行代码<code>Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);</code>，可以看出是通过Enum.valeOf来获取枚举类对象的，那我们去看一下这个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType,</span></span></div><div class="line">                                                String name) &#123;</div><div class="line">        T result = enumType.enumConstantDirectory().get(name);</div><div class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Name is null"</span>);</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">            <span class="string">"No enum constant "</span> + enumType.getCanonicalName() + <span class="string">"."</span> + name);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>实际上是通过调用enumType(Class对象的引用)的enumConstantDirectory方法获取到一个Map集合，在该集合内存储了以枚举类name为key，枚举实例变量值为value的键值对数据，因此通过name就可以获取到枚举实例。我们再来看下enumConstantDirectory方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">Map&lt;String, T&gt; <span class="title">enumConstantDirectory</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (enumConstantDirectory == <span class="keyword">null</span>) &#123;</div><div class="line">        T[] universe = getEnumConstantsShared();</div><div class="line">        <span class="keyword">if</span> (universe == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                getName() + <span class="string">" is not an enum type"</span>);</div><div class="line">        Map&lt;String, T&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span> * universe.length);</div><div class="line">        <span class="keyword">for</span> (T constant : universe)</div><div class="line">            m.put(((Enum&lt;?&gt;)constant).name(), constant);</div><div class="line">        enumConstantDirectory = m;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> enumConstantDirectory;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>getEnumConstantsShared方法最终利用反射调用枚举类的<code>values</code>方法来获取的枚举类实例数组，然后再以键值对的方式存储到Map集合中去。</p>
<p>到这里，我们的确可以看出来，枚举类反序列化的确不会重新创建实例，JVM保证了每个枚举类实例变量的唯一性。</p>
<h3 id="枚举是如何防止反射生成多个实例的"><a href="#枚举是如何防止反射生成多个实例的" class="headerlink" title="枚举是如何防止反射生成多个实例的"></a>枚举是如何防止反射生成多个实例的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 常规方法获取实例</span></div><div class="line">    Singleton commonSingleton = Singleton.getInstance();</div><div class="line"></div><div class="line">    <span class="comment">// 通过反射获取实例</span></div><div class="line">    Constructor constructor = Singleton.class.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</div><div class="line">    constructor.setAccessible(<span class="keyword">true</span>);</div><div class="line">    Singleton reflectionSingleton = (Singleton) constructor.newInstance();</div><div class="line"></div><div class="line">    <span class="comment">// 这里会输出： false，证明两个实例不一样，单例模式被破坏了</span></div><div class="line">    System.out.println(reflectionSingleton == commonSingleton);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道，反射破坏单例主要是通过利用调用私有构造器来实现的，当用反射尝试实例化枚举类的时候，会抛出下面的异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Exception in thread <span class="string">"main"</span> java.lang.IllegalArgumentException: Cannot reflectively create <span class="keyword">enum</span> objects</div><div class="line">    at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">417</span>)</div><div class="line">    at com.github.archerda.designpattern.singleton.destory.reflection.BreakingSingleton.main(BreakingSingleton.java:<span class="number">23</span>)</div></pre></td></tr></table></figure></p>
<p>显然，异常告诉我们，不能通过反射实例化枚举类，为什么呢？我们来看下newInstance的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CallerSensitive</span></div><div class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></div><div class="line">       <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</div><div class="line">              IllegalArgumentException, InvocationTargetException</div><div class="line">   &#123;</div><div class="line">       <span class="keyword">if</span> (!override) &#123;</div><div class="line">           <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</div><div class="line">               Class&lt;?&gt; caller = Reflection.getCallerClass();</div><div class="line">               checkAccess(caller, clazz, <span class="keyword">null</span>, modifiers);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</div><div class="line">       ConstructorAccessor ca = constructorAccessor;   <span class="comment">// read volatile</span></div><div class="line">       <span class="keyword">if</span> (ca == <span class="keyword">null</span>) &#123;</div><div class="line">           ca = acquireConstructorAccessor();</div><div class="line">       &#125;</div><div class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">       T inst = (T) ca.newInstance(initargs);</div><div class="line">       <span class="keyword">return</span> inst;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>看第12行，很显然了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>常见的5种单例模式实现方式：</p>
<ul>
<li>主要：<ul>
<li>饿汉式：线程安全，调用效率高，不能延迟加载；</li>
<li>懒汉式：线程安全，调用效率低，但是可以延迟加载；</li>
</ul>
</li>
<li>其他：<ul>
<li>双重检验锁：JDK1.5之前底层内部模型有问题，不建议使用；</li>
<li>静态内部类式：线程安全，调用效率高，可以延迟加载；</li>
<li>枚举式：线程安全，调用效率高，不能延迟加载，但是可以天然防止反射和序列化漏洞；</li>
</ul>
</li>
</ul>
</li>
<li><p>如何选用：</p>
<ul>
<li>单例对象占用资源少，不需要延迟加载：<strong>枚举式 &gt; 饿汉式</strong>；</li>
<li>单例对象占用资源大，需要延迟加载：<strong>静态内部式 &gt; 懒汉式</strong></li>
</ul>
</li>
</ul>
<h2 id="在JDK中的应用"><a href="#在JDK中的应用" class="headerlink" title="在JDK中的应用"></a>在JDK中的应用</h2><h3 id="java-lang-Runtime"><a href="#java-lang-Runtime" class="headerlink" title="java.lang.Runtime"></a>java.lang.Runtime</h3><p><code>Runtime</code>类封装了Java运行时的环境。因为Java程序实际是启动了一个JVM进程，而每个JVM进程都对应一个Runtime实例，此实例是由JVM来实例化的。每个Java程序都有一个Runtime实例，使应用程序能够与其运行的环境交互。</p>
<p>由于Java进程是单进程的，所以在一个JVM中，Runtime实例应该只要一个。所以应该用单例模式来实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> currentRuntime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上代码为JDK中Runtime代码的部分实现，明显，这是饿汉式的实现方式。在该类被ClassLoader第一次加载的时候被创建。</p>
<h3 id="在Spring中的应用"><a href="#在Spring中的应用" class="headerlink" title="在Spring中的应用"></a>在Spring中的应用</h3><p>Spring单例Bean与单例模式的区别在于它们关联的环境不一样，单例模式是指在一个JVM进程中仅有一个实例，而Spring单例是指一个SpringBean容器(ApplicationContext)中仅有一个实例，所以如果一个JVM进程中有多个IoC容器，即使是单例Bean，也会有多个实例，比如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 即使声明了为单例，只要有多个容器，也一定会创建多个实例 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.github.archerda.Person"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>archerda<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  第一个Spring Bean容器</span></div><div class="line">ApplicationContext context1 = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"classpath:/ApplicationContext.xml"</span>);</div><div class="line">Person person1 = context1.getBean(<span class="string">"person"</span>, Person.class);</div><div class="line"><span class="comment">//  第二个Spring Bean容器</span></div><div class="line">ApplicationContext context2 = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"classpath:/ApplicationContext.xml"</span>);</div><div class="line">Person person2 = context2.getBean(<span class="string">"person"</span>, Person.class);</div><div class="line"><span class="comment">//  这里绝对不会相等，因为创建了多个实例</span></div><div class="line">System.out.println(person1 == person2);</div></pre></td></tr></table></figure>
<hr>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>【1】如果是final的话，应该是静态绑定的，在编译期间就可以确定，参考<a href="http://www.luohuida.com/2015/09/09/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/#被动引用场景-3：使用父类常量不会触发定义常量的类的初始化" target="_blank" rel="external">使用父类常量不会触发定义常量的类的初始化</a>。<br>【2】这与<a href="http://www.luohuida.com/2015/08/28/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" target="_blank" rel="external">Java 内存模型</a>中提到的synchroized保证了原子性有冲突？</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="external">Jark’s Blog: 如何正确地写出单例模式
</a></li>
<li><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="external">CSDN: Java之美[从菜鸟到高手演变]之设计模式</a></li>
<li><a href="http://blog.csdn.net/ljhljh8888/article/details/8017701" target="_blank" rel="external">CSDN: 单例模式有什么好处</a></li>
<li><a href="http://blog.csdn.net/javazejian/article/details/71333103#枚举与单例模式" target="_blank" rel="external">CSDN：深入理解Java枚举类型(enum)</a></li>
<li><a href="http://blog.csdn.net/gcxzflgl/article/details/77043530" target="_blank" rel="external">CSDN：单例模式详解（解决反射反序列化问题）</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/01/Sublime-Text-3-快捷键以及常用配置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/01/Sublime-Text-3-快捷键以及常用配置/" itemprop="url">Sublime Text 3 快捷键以及常用配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-01T16:15:01+08:00">
                2015-10-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="快捷键（Mac平台）"><a href="#快捷键（Mac平台）" class="headerlink" title="快捷键（Mac平台）"></a>快捷键（Mac平台）</h2><table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">⌘</td>
<td style="text-align:left">command</td>
</tr>
<tr>
<td style="text-align:left">⌃</td>
<td style="text-align:left">control</td>
</tr>
<tr>
<td style="text-align:left">⌥</td>
<td style="text-align:left">option/alt</td>
</tr>
<tr>
<td style="text-align:left">⇧</td>
<td style="text-align:left">shift</td>
</tr>
<tr>
<td style="text-align:left">↩</td>
<td style="text-align:left">enter</td>
</tr>
<tr>
<td style="text-align:left">⌫</td>
<td style="text-align:left">delete</td>
</tr>
</tbody>
</table>
<ul>
<li>打开Console：<code>⌃</code> `</li>
<li>打开命令模式：<code>⌘ ⇧ p</code></li>
<li>根据文件名打开文件：<code>⌘ p</code></li>
<li>定位函数方法：<code>⌘  r</code></li>
<li>多行游标：<code>⌘ d(选中)</code> <code>⌘ k(跳过)</code></li>
<li>快速跳行：<code>⌃ g</code></li>
<li>删除整行：<code>⌃ ⇧ k</code></li>
<li>剪切整行：<code>⌘ x</code></li>
<li>本文件查找：<code>⌘ f</code></li>
<li>全局查找：<code>⌘ ⇧ f</code></li>
<li>替换：<code>⌘ ⌥ f</code></li>
</ul>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="安装Package-Control："><a href="#安装Package-Control：" class="headerlink" title="安装Package Control："></a>安装<strong>Package Control</strong>：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.request,os,hashlib; h = <span class="string">'2915d1851351e5ee549c20394736b442'</span> + <span class="string">'8bc59f460fa1548d1514676163dafc88'</span>; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( <span class="string">'http://packagecontrol.io/'</span> + pf.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)).read(); dh = hashlib.sha256(by).hexdigest(); print(<span class="string">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class="keyword">if</span> dh != h <span class="keyword">else</span> open(os.path.join( ipp, pf), <span class="string">'wb'</span> ).write(by)</div></pre></td></tr></table></figure>
<h3 id="Emmet："><a href="#Emmet：" class="headerlink" title="Emmet："></a><strong>Emmet</strong>：</h3><p>提供了一种非常简练的语法规则，然后立刻生成对应的 HTML 结构或者 CSS 代码，同时还有多种实用的功能帮助进行前端开发。</p>
<ul>
<li>自动生成HTML5初始代码：<code>html:5</code></li>
<li>生成特定id节点：<code>span#idName</code></li>
<li>生成特定class节点：<code>span.className</code></li>
</ul>
<h3 id="AutoFileName"><a href="#AutoFileName" class="headerlink" title="AutoFileName:"></a><strong>AutoFileName</strong>:</h3><p>自动补全文件路径，非常方便。</p>
<h3 id="DocBlockr"><a href="#DocBlockr" class="headerlink" title="DocBlockr:"></a><strong>DocBlockr</strong>:</h3><p>DocBlockr会成为你编写代码文档的有效工具。当输入/**并且按下Tab键的时候，这个插件会自动解析任何一个函数并且为你准备好合适的模板。</p>
<h3 id="Alignment："><a href="#Alignment：" class="headerlink" title="Alignment："></a><strong>Alignment</strong>：</h3><p>代码对齐。</p>
<h3 id="jQuery："><a href="#jQuery：" class="headerlink" title="jQuery："></a><strong>jQuery</strong>：</h3><p>jQuery代码提示。</p>
<h3 id="JsFormat："><a href="#JsFormat：" class="headerlink" title="JsFormat："></a><strong>JsFormat</strong>：</h3><p>JavaScript代码格式化。</p>
<h3 id="Tag："><a href="#Tag：" class="headerlink" title="Tag："></a><strong>Tag</strong>：</h3><p>HTML/XML标签缩进、补全和校验。</p>
<h3 id="HTML-CSS-JS-Prettify："><a href="#HTML-CSS-JS-Prettify：" class="headerlink" title="HTML-CSS-JS Prettify："></a><strong>HTML-CSS-JS Prettify</strong>：</h3><p>代码美化。</p>
<h3 id="ConvertToUTF8："><a href="#ConvertToUTF8：" class="headerlink" title="ConvertToUTF8："></a><strong>ConvertToUTF8</strong>：</h3><p>通过本插件，可以编辑并保存目前编码不被 Sublime Text 支持的文件，特别是中日韩用户使用的 GB2312，GBK，BIG5，EUC-KR，EUC-JP 等。</p>
<h3 id="主题及配色"><a href="#主题及配色" class="headerlink" title="主题及配色"></a>主题及配色</h3><p>Material</p>
<h2 id="个人配置"><a href="#个人配置" class="headerlink" title="个人配置"></a>个人配置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">"auto_complete"</span> : true,</div><div class="line">	<span class="string">"auto_complete_selector"</span>: <span class="string">"source - comment"</span>,</div><div class="line">	<span class="string">"auto_complete_triggers"</span>: </div><div class="line">	[</div><div class="line">		&#123;</div><div class="line">			<span class="string">"characters"</span>: <span class="string">"."</span></div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			<span class="string">"characters"</span>: <span class="string">"&gt;"</span></div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			<span class="string">"characters"</span>: <span class="string">":"</span></div><div class="line">		&#125;</div><div class="line">	],</div><div class="line">	<span class="string">"bold_folder_labels"</span>: true,</div><div class="line">	<span class="string">"color_scheme"</span>: <span class="string">"Packages/Material Theme/schemes/Material-Theme.tmTheme"</span>,</div><div class="line">	<span class="string">"fade_fold_buttons"</span>: false,</div><div class="line">	<span class="string">"font_face"</span>: <span class="string">"Monaco"</span>,</div><div class="line">	<span class="string">"font_size"</span>: <span class="number">13</span>,</div><div class="line">	<span class="string">"highlight_line"</span>: true,</div><div class="line">	<span class="string">"highlight_modified_tabs"</span>: true,</div><div class="line">	<span class="string">"ignored_packages"</span>:</div><div class="line">	[</div><div class="line">		<span class="string">"Vintage"</span></div><div class="line">	],</div><div class="line">	<span class="string">"line_padding_bottom"</span>: <span class="number">1</span>,</div><div class="line">	<span class="string">"line_padding_top"</span>: <span class="number">1</span>,</div><div class="line">	<span class="string">"open_files_in_new_window"</span>: false,</div><div class="line">	<span class="string">"theme"</span>: <span class="string">"Material-Theme.sublime-theme"</span>,</div><div class="line">	<span class="string">"material_theme_accent_purple"</span>: true,</div><div class="line">	<span class="string">"material_theme_small_statusbar"</span>: true,</div><div class="line">	<span class="string">"material_theme_small_tab"</span>: true,</div><div class="line">	<span class="string">"material_theme_tabs_autowidth"</span>: true,</div><div class="line">	<span class="string">"overlay_scroll_bars"</span>: <span class="string">"enabled"</span>,</div><div class="line">	<span class="string">"smart_indent"</span>: true,</div><div class="line">	<span class="string">"word_wrap"</span>: true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="subl命令"><a href="#subl命令" class="headerlink" title="subl命令"></a>subl命令</h2><p>在Bash中执行下面语句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/subl</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://packagecontrol.io/installation" target="_blank" rel="external">Package Control Installation</a></li>
<li><a href="http://www.cnsecer.com/4112.html" target="_blank" rel="external">解决Mac下Sublime Text3因为pyV8无法加载导致Emmet无法使用的问题</a></li>
<li><a href="https://github.com/liveNo/Sublime-Tutorial?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">Sublime Text 插件与快捷键（Mac 版）</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/23/Google-s-Java-Style/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/23/Google-s-Java-Style/" itemprop="url">Google's Java Style</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-23T16:15:09+08:00">
                2015-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为何需要编程规范"><a href="#为何需要编程规范" class="headerlink" title="为何需要编程规范"></a>为何需要编程规范</h2><p>记得以前刚开始写C的时候，能写出来代码就好。后来看了好基友的代码后，感受到了满满的恶意，于是被教育了。后来开始慢慢理解编程规范的作用，以及它的必要性。编程规范多少算是软件工程领域里面的概念，很多程序员认为“编程规范是浪费时间的”、“我有自己的规范”等，其实我大部分是因为他们（她？）没有体会到编程规范所带来的好处。</p>
<p>按我的理解，遵循标准的编程规范有以下几个好处：</p>
<ul>
<li>容易理解代码。Always，如果一份代码遵循一定的规范，每个类、每个方法都声明了它的作用、参数意义等，那么很多时候我们只要看它的文件结构就知道了这些代码要干什么了。</li>
<li>增加代码好感度。面对陌生的东西，我们都会感到害怕。而有统一的规范，你看一眼代码，就会觉得它们很眼熟。那么畏难心理自然消退。</li>
<li>容易维护。</li>
</ul>
<p>目前，自己主要在学习Java方面的技术，而且是个Google粉，所以尝试完全去遵循Google的Java规范。下面是它们的规范文档，中文是由Hawstein大神翻译的。实践篇尤其值得一读。</p>
<h2 id="English"><a href="#English" class="headerlink" title="English"></a>English</h2><p><a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html" target="_blank" rel="external">Google Java Style</a></p>
<h2 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h2><p><a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="external">Hawstein’Blog:Google Java编程风格指南</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/22/什么是事务/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/22/什么是事务/" itemprop="url">什么是事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-22T11:04:30+08:00">
                2015-09-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>事务是DBMS中业务操作的执行单位，事务的ACID性质是数据库一致性的基本保证</strong>。保障并发执行时事务满足ACID的技术就是数据库的并发控制，保障在数据库发生故障时依然满足ACID的技术就是数据库的故障恢复。<strong>并发控制和故障恢复</strong>是数据库系统管理的基本内容，所以事务概念和事务ACID性质也就成为了数据库管理的重要基础。</p>
<h2 id="事务概念与性质"><a href="#事务概念与性质" class="headerlink" title="事务概念与性质"></a>事务概念与性质</h2><p>我们先来看一个例子：由账户A转账金额X到账户B。这是一个非常经典的例子。这个业务可以分解成2个基本的操作：</p>
<ol>
<li>从A中减少金额X；</li>
<li>在B中添加金额X；</li>
</ol>
<p>这2个动作构成了一个不可分割的整体，要么一起执行，要么都不执行。如果只执行前一个动作而忽略了后一个动作，那么将导致数据错乱。这种<strong>“不可分割”的业务单位</strong>对于数据库业务的并发控制和故障恢复非常重要、非常必要，这就是“事务”的基本概念。</p>
<h3 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h3><p>事务（transaction），是DBMS中的基本执行单位。根本特征在于集中了数据库应用方面的若干操作，这些操作构成一个操作序列，要么全做，要么全不做<strong>，整个序列是一个不可分割的“原子化”单位</strong>。</p>
<p>在数据库系统中，一个事务是指：由一系列数据库操作组成的一个完整的逻辑过程。例如银行转帐，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和，构成一个完整的逻辑过程，不可拆分。</p>
<h3 id="事务性质"><a href="#事务性质" class="headerlink" title="事务性质"></a>事务性质</h3><p>在数据库事务处理过程中，事务的正常状态是由“ACID”性质予以保证的。</p>
<ol>
<li><strong>原子性</strong>（<strong>Atomicity</strong>）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li><strong>一致性</strong>（<strong>Consistency</strong>）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
<li><strong>隔离性</strong>（<strong>Isolation</strong>）：多个事务并发执行与这些事务单独执行的结果“等效”。当两个或者多个事务并发访问（此处访问指查询和修改的操作）数据库的同一数据时所表现出的相互关系。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>持久性</strong>（<strong>Durability</strong>）：在事务完成以后，该事务对数据库所作的更改便持久地保存在数据库之中，并且是完全的。</li>
</ol>
<h2 id="事务操作与状态"><a href="#事务操作与状态" class="headerlink" title="事务操作与状态"></a>事务操作与状态</h2><p>在数据库运行过程中，事务可以由下述的4个基本部分组成：</p>
<ol>
<li>开始（begin）：开始执行事务。</li>
<li>执行（read and write）：事务对数据进行读或写操作。</li>
<li>提交（commit）：事务完成所有操作，同时保存结果，标志着事务的成功完成。</li>
<li>回滚（rollback）：事务未完成所有所做，重新返回到事务开始，标志着事务的撤销。</li>
</ol>
<p>根据事务的上述操作，可以得到事务的各种状态：</p>
<ol>
<li>活动状态（active）：事务处于运行当中。</li>
<li>局部提交状态（partial committed）：表明事务的最后语句已经被执行。</li>
<li>提交状态（committed）：事务执行成功，执行结果写入到数据库中。</li>
<li>失败状态（failed）：事务无法正常进行。</li>
<li>终止状态（abort）：回到事务执行前的初始状态。</li>
</ol>
<p>事务操作与状态之间的关系如下图：<br><img src="https://c2.staticflickr.com/6/5672/21623200401_2616631b8d_z.jpg" alt="事务操作与状态之间的关系"></p>
<p>可以得出以下结论：</p>
<ul>
<li>事务一般由“事务开始”启动，到“事务提交”或“事务回滚”结束。</li>
<li>在事务开始后，它不断做READ或WRITE操作，但此时WRITE操作仅将数据写入磁盘缓冲区，并不是真正写入到数据库中。</li>
<li>在事务执行过程中会产生2种情况：一是顺利执行，此时事务继续执行其后的操作；二是产生故障等原因而终止。</li>
</ul>
<h2 id="SQL事务机制"><a href="#SQL事务机制" class="headerlink" title="SQL事务机制"></a>SQL事务机制</h2><h3 id="事务处理语句"><a href="#事务处理语句" class="headerlink" title="事务处理语句"></a>事务处理语句</h3><ol>
<li>事务开始语句：<code>BEGIN TRANSACTION</code>.</li>
<li>事务提交语句：<code>COMMIT TRANSACTION</code>.</li>
<li>事务回滚语句：<code>ROLLBACK TRANSACTION</code>.</li>
<li>事务存储点语句：<code>SAVE TRANSACTION</code>, <code>RELEASE TRANSACTION</code>.</li>
</ol>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="">数据库系统教程 叶小平著 清华大学出版社</a></li>
<li><a href="https://zh.wikipedia.org/wiki/ACID" target="_blank" rel="external">维基百科：ACID</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/21/JVM-如何确定对象已死/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/21/JVM-如何确定对象已死/" itemprop="url">JVM 如何确定对象已死</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-21T11:44:12+08:00">
                2015-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Java堆里面存放着Java世界中几乎所有的对象实例，GC前，第一件事情就是确定这些对象中哪些嗨“存活”着，哪些已经“死去”(即不可能再被使用的对象)。</p>
<h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>一个常用的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它的时候，这个计数器+1；当引用失效的时候，这个计数器-1.当计数器=0的时候，则说明这个对象不可能再被使用。这个叫“引用计数算法”（Reference Counting）。</p>
<p>客观地说，RC算法的实现简单，效率也很高，在大部分情况下它都是一个不错的算法(Objective-C中就使用它来管理内存)。然后JVM中却没有使用它来管理内存，其中最主要的原因就是RC算法<strong>无法处理循环引用</strong>的问题（还有一个问题就是频繁的更新引用计数会降低运行效率）。</p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>在主流的商业程序语言（Java、C#、甚至古老的Lisp）的主流实现中，都是通过可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法的基本思路是：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没用任何引用链相连时（从图论的角度来看，就是GC Roots到这个对象不可达），则说明这个对象是不可用的。如下图所示，，对象object5、object6、objectt7虽然互相关联，但是它们到GC Roots是不可达的，所以它们会被判定是可回收对象。<br><img src="https://c2.staticflickr.com/6/5742/21386142560_90e6e43417.jpg" alt="可达性分析算法判定对象是否可回收"></p>
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li>
<li>本地方法栈中JNI（即一般说的native方法）引用的对象；(ps.栈中数据不受GC影响)</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
</ul>
<h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法来判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK1.2之前，Java中的引用的定义很传统：<strong>如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用</strong>。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用2种状态，对于一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：<strong>当内存空间还足够时，则能够保存在内存中；如果内存空间在进行GC后非常紧张，则可以抛弃这些对象</strong>。很多系统的缓存功能都符合这样的场景。</p>
<p>在JDK1.2后，Java对引用的概念进行了扩充，将引用分为<strong>强引用</strong>（Strong Reference）、<strong>软引用</strong>（Soft Reference）、<strong>弱引用</strong>（Weak Reference）、<strong>虚引用</strong>（Phantom Reference）4种，这4种引用的引用强度逐渐减弱。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>强引用</code></td>
<td style="text-align:left">就是指在代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，GC永远不会回收它们；</td>
</tr>
<tr>
<td style="text-align:left"><code>软引用</code></td>
<td style="text-align:left">用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之内进行二次GC。如果这次GC后还没有足够的内存，才会抛出OOM异常。在JDK1.2后，提供了SoftReference类来实现软引用；</td>
</tr>
<tr>
<td style="text-align:left"><code>弱引用</code></td>
<td style="text-align:left">也是用来描述非必需的对象的，但是它的强度比弱引用更弱一些，被弱引用关联的对象只能生存到下一次GC之前。当GC的时候，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2后，提供了WeakReference类来实现弱引用；</td>
</tr>
<tr>
<td style="text-align:left"><code>虚引用</code></td>
<td style="text-align:left">也称为幽灵或者幻影引用。它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过一个虚引用来取得一个对象实例。为一个对象引入虚引用关联的唯一目的就是能在这个对象被回收器回收之前收到一个系统通知。在JDK1.2后，提供了PhantomReference类实现虚引用。</td>
</tr>
</tbody>
</table>
<h2 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h2><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经过两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被<strong>第一次标记</strong>并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。然后这个对象会放置在一个叫做<code>F-Queue</code>的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的<code>Finalize线程</code>去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不会承诺会等待它运行结束，原因是如果一个对象的finalize()方法执行缓慢，或者发生了死循环，将很可能导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行<strong>第二次小规模的标记</strong>，如果对象在finalize()中成功拯救自己—只要重新与引用链上的任何一个对象建立关联即可，<strong>比如把自己（this关键字）赋值给某个类变量或者对象的成员变量</strong>，那么在第二次标记的时候它将被移除“即将回收”的队列；如果这个对象这个时候还没有逃脱，那基本上它就真的被回收了。来看演示代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.archerda.oom;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 代码演示的目的有2：1</div><div class="line"> *  1.对象可以在GC的时候自救；</div><div class="line"> *  2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统调用一次</div><div class="line"> *</div><div class="line"> * Created by Archerda on 15/9/21.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">        <span class="keyword">super</span>.finalize();</div><div class="line">        System.out.println(<span class="string">"finalize method executed."</span>);</div><div class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>; <span class="comment">// 拯救自己</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</div><div class="line"></div><div class="line">        SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line">        System.gc();</div><div class="line">        Thread.sleep(<span class="number">500</span>); <span class="comment">// 因为finalize线程的优先级很低，所有暂停0.5s来等地它</span></div><div class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"Yes, I'm still alive."</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"No, I'm dead."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">finalize method executed.</div><div class="line">Yes, I<span class="string">'m still alive.</span></div></pre></td></tr></table></figure></p>
<p>从上面的运行结果可以看出，SAVE_HOOK对象的finalize()方法确实被垃圾回收器触发过，并且在回收之前成功逃脱了。</p>
<p>如果我们把<code>FinalizeEscapeGC.SAVE_HOOK = this</code> 注释掉，那么运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">finalize method executed.</div><div class="line">No, I<span class="string">'m dead.</span></div></pre></td></tr></table></figure></p>
<p>这个时候SAVE_HOOK没有重新关联到引用链中，所以没有逃脱GC的回收。</p>
<p>还有个现象，我们把上面代码的main()方法改下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</div><div class="line"></div><div class="line">        SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line">        System.gc();</div><div class="line">        Thread.sleep(<span class="number">500</span>); <span class="comment">// 因为finalize线程的优先级很低，所有暂停0.5s来等地它</span></div><div class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"Yes, I'm still alive."</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"No, I'm dead."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 下面这段代码与上面的完全一样，但是这次自救却失败了</span></div><div class="line">        SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line">        System.gc();</div><div class="line">        Thread.sleep(<span class="number">500</span>); <span class="comment">// 因为finalize线程的优先级很低，所有暂停0.5s来等地它</span></div><div class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"Yes, I'm still alive."</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"No, I'm dead."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">finalize method executed.</div><div class="line">Yes, I'm still alive.</div><div class="line">No, I'm dead.</div></pre></td></tr></table></figure></p>
<p>代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次逃脱失败。这时因为<strong>一个对象的finalize()方法都只会被系统自动调通一次</strong>，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败。也就是说，<strong>对象只能自救一次</strong>。</p>
<p>值得注意的是，建议大家尽量避免使用finalize()方法。因为他不是C/C++中的析构函数，而是Java刚诞生的时候为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂、不确定性大，无法保证各个对象的调用顺序。有些教材中描述它适合做“关闭外部资源”之类的工作，这完全是对这个方法用途的一种安慰，finalize()方法能做的所有工作，使用try-catch或者其他方式都可以做的更好、更及时。所以，忘记这个方法吧！！！</p>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>很多人认为方法区（或者说HotSpot虚拟机中的永久代）是没有垃圾回收的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区中实现垃圾回收，而且在方法区中进行垃圾回收的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾回收一般可以回收70%~95%的空间，而永久代中的垃圾收集效率却远低于此。</p>
<p>永久代中的垃圾回收主要回收两部分内容：<strong>废弃常量和无用的类</strong>。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例：假如一个字符串“abc”已经进入常量池了，当时<strong>当前系统没有任何一个String对象是叫做“abc”，也没有其他地方引用了这个字面量</strong>，如果这时发生了GC，而且必要的话，这个“abc”常量就回被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否“无用”的条件则要苛刻很多。类需要同时满足下面3个条件才能算是“无用的类”：</p>
<ol>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li>
<li>加载该类的ClassLoader已经被回收；</li>
<li>该类队形的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ol>
<p>虚拟机<strong>可以</strong>对满足上述3个条件的无用类进行回收，这里所说的“可以”，而并不是和对象一样，对象的是不使用了就必然会回收。</p>
<p>在大量使用反射、动态代理、CGLib等字节码技术框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备卸载类的功能，以保证虚拟机永久代不会溢出。</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="">深入理解Java虚拟机(第二版) 周志明著</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0" target="_blank" rel="external">维基百科：引用计数</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%AE%9A%E7%BE%A9%E5%8F%AF%E9%81%94%E6%80%A7" target="_blank" rel="external">维基百科：定義可達性</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png"
               alt="archerda" />
          <p class="site-author-name" itemprop="name">archerda</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">68</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">37</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/archerda" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:luo.archer@gmail.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Email
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">archerda</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
