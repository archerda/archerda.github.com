<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="archerda, ArcherdaArcherda's BlogHexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Archerda&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Archerda&#39;s Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Archerda&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/"/>





  <title>Archerda's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Archerda's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Programmer. Meditating.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/16/详解HTTP超文本传送协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/16/详解HTTP超文本传送协议/" itemprop="url">详解HTTP超文本传送协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-16T15:12:16+08:00">
                2015-09-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HTTP协议定义了<strong>客户端怎么向服务器请求万维网文档，以及服务器怎么把文档传送到客户端</strong>。从层次的角度看，HTTP是面向事务(一系列的信息交换，而这一系列的信息交换是不可分割的，要么所有信息交换都完成，要么一次交换都不进行)的应用层协议，它是万维网上能够可靠地交换文件(包括文本、声音、图像等各种多媒体文件)的重要基础。</p>
<h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p>万维网的工作过程如图：<br><img src="https://farm1.staticflickr.com/607/21428977756_b4ecdbe779_z.jpg" alt=""></p>
<p>每个万维网网点都有一个服务器进程，它不断地监听TCP的80端口，以便发现是否有客户端向他发出建立连接请求。一旦监听到连接请求并建立了TCP连接后，客户端就向服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。最后，TCP连接被释放了。</p>
<p>在客户端和服务器之间的请求和响应的交互，必须按照规定的格式和遵循一定的规则。这个格式和规则就是超文本传送协议HTTP。</p>
<p>HTTP规定在客户端和服务器之间的每次交互，都由一个ASCII码串构成的请求和一个类似的通用因特网邮件扩充，即”类MIME(MIME-like)”的响应组成。</p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>用户浏览页面的方式有2种：一种是在浏览器的地址窗口中键入所要找的页面的URL。另一种是在某一个页面中用鼠标点击一个可选部分，这时浏览器会自动跳转在因特网上找到所要链接的页面。</p>
<p>假定上图中的用户用鼠标点击了屏幕上的一个可选部分。它使用的链接指向了一个URL<code>http:///www.tsinghua.edu.cn/chn/yxsz/index.html</code>，下面我们用HTTTP/1.0更具体地说明在用户点击鼠标后所发生的几件事件：</p>
<blockquote>
<ol>
<li>浏览器分析链接指向页面的URL；</li>
<li>浏览器向DNS请求解析www.tsinghua.edu.cn的IP地址；</li>
<li>域名系统DNS解析出清华大学服务器的IP是166.111.4.100；</li>
<li>浏览器与服务器建立TCP连接(在服务器端IP是166.111.4.100，端口是80)；</li>
<li>浏览器发出取文件命令：GET /chn/yxsz/index.html；</li>
<li>服务器www.tsinghua.edu.cn给出响应，把文件index.html发送给浏览器；</li>
<li>释放TCP连接；</li>
<li>浏览器显示文件index.html中所有的文本。</li>
</ol>
</blockquote>
<p>浏览器在下载文件时，可以设置为只下载其中的文本部分。这样可以使得下载的速度加快。在这种情况下，文件中原来嵌入的图像或者音频的地方只用一个小图标来显示。用户若要下载这些图像或音频，可用鼠标再分别点击这些图标。每点击一次鼠标，就重复执行一次类似与上面的8个步骤。也就是先建立TCP连接，再使用TCP连接传送命令和传送文件，最后释放TCP连接。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>HTTP通常使用TCP连接传送。HTTP使用了面向连接的TCP作为传输层协议，保证了数据的可靠传输。HTTP不必考虑数据在传输过程中被丢弃后又怎样被重传。但是，HTTP协议<strong>本身是无连接的</strong>。这就是说，虽然HTTP使用了TCP连接，但通信的双方在交换HTTP报文之前不需要先建立HTTP连接。</p>
<p>HTTP协议是<strong>无状态的</strong>(stateless)。也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同(假定现在服务器还没有把页面更新)，因为服务器并不记得曾经访问过的客户，也不记得为该客户服务过多少次。HTTP的无状态特性简化了服务器的设计，使服务器更容易支持大量并发的HTTP请求。</p>
<h2 id="请求一个文档所需时间"><a href="#请求一个文档所需时间" class="headerlink" title="请求一个文档所需时间"></a>请求一个文档所需时间</h2><p>下面我们粗略估算一下，从浏览器请求一个万维网文档到收到整个文档所需要的时间。如下图。用户在点击鼠标链接某个万维网文档时，HTTP协议首先要和服务器建立TCP连接。这需要使用三次握手。当三次握手的前两部分完成后(即经过一个RTT时间后)，<strong>万维网客户就把HTTP请求报文作为第三次握手的第三个报文的数据发送到服务器(第三次握手可以携带数据，但需要消耗一个序号)。服务器收到请求报文后，就把所请求的文档作为响应报文返回给客户</strong>。<br><img src="https://farm1.staticflickr.com/640/21444244112_ae7f8d9ebc_z.jpg" alt=""><br>从上图可看出，请求一个万维网文档所需要的时间是该文档的传输时间(与文档大小成正比)加上两倍往返时间RTT(一个RTT用于TCP连接，另一个RTT用于请求和接收文档。这里TCP建立连接的三次握手的第三个报文段捎带了客户对万维网文档的请求)。</p>
<blockquote>
<p>请求文档时间 = 2 * RTT + 文档传输时间</p>
</blockquote>
<h2 id="不足与解决方案"><a href="#不足与解决方案" class="headerlink" title="不足与解决方案"></a>不足与解决方案</h2><p>HTTP/1.0 的主要缺点，就是每请求一个文档就要有两倍RTT的开销。若一个主页上有很多链接的对象(如图片等)，那么每一次链接下载都导致2<em>RTT的开销。特别是万维网服务器往往要同时服务于大量的客户请求，所以这种 <em>*非持续性连接</em></em> 会使万维网服务器的负担很重。好在浏览器都提供了能够打开5~10个并行的TCP连接，而每一个TCP连接处理客户的一个请求。因此，使用并行的TCP连接可以缩短响应时间(然而服务端的负担没有任何减轻)。</p>
<p>HTTP/1.1 协议较好地解决了这个问题，它使用<strong>持续连接</strong>(persistent connection)。所谓持续连接就是万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户(浏览器)和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。这并不局限于传送同一个页面上链接的文档，而是只要这些文档在同一个服务器上就行了。目前大部分浏览器的默认设置就是使用HTTP/1.1.</p>
<p>HTTP/1.1协议的持续连接有2中工作方式：<strong>非流水线方式(without pipelining)和流水线方式(with pipelining)</strong>。</p>
<p>非流水线方式的特点，是客户在收到前一个响应后才能发出下一个请求。因此，在TCP连接已经建立后，客户每访问一次对象都要用去一个往返时间RTT。这比非持续性连接要用去2个RTT时间，节省了建立TCP连接的一个RTT时间。但非流水方式还是有缺点的，因为服务器在发送完一个对象后，其TCP连接就处于空闲状态，浪费了服务器资源。</p>
<p>流水线方式的特点，是客户在收到HTTP的响应报文之前就能够接着发送新的请求报文。于是一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。因此，使用流水线方式时，客户访问<strong>所有的对象只需要花费一个RTT时间</strong>。流水线工作方式使TCP连接中的空闲时间减少，提高了下载文档的效率。</p>
<h2 id="HTTP请求报文的常用方法"><a href="#HTTP请求报文的常用方法" class="headerlink" title="HTTP请求报文的常用方法"></a>HTTP请求报文的常用方法</h2><table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GET</td>
<td style="text-align:left">请求读取由URL所标识的信息</td>
</tr>
<tr>
<td style="text-align:left">POST</td>
<td style="text-align:left">给服务器发送信息</td>
</tr>
<tr>
<td style="text-align:left">OPTION</td>
<td style="text-align:left">请求一些选项信息</td>
</tr>
<tr>
<td style="text-align:left">HEAD</td>
<td style="text-align:left">请求读取由URL所标识的信息的首部</td>
</tr>
<tr>
<td style="text-align:left">PUT</td>
<td style="text-align:left">在指明的URL中存储一个文档</td>
</tr>
<tr>
<td style="text-align:left">DELETE</td>
<td style="text-align:left">删除指明URL所标识的资源</td>
</tr>
<tr>
<td style="text-align:left">TRACE</td>
<td style="text-align:left">用来进行环回测试的请求报文</td>
</tr>
<tr>
<td style="text-align:left">CONNECT</td>
<td style="text-align:left">用于代理服务器</td>
</tr>
</tbody>
</table>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><ul>
<li>1xx消息——请求已被服务器接收，继续处理</li>
<li>2xx成功——请求已成功被服务器接收、理解、并接受</li>
<li>3xx重定向——需要后续操作才能完成这一请求<ul>
<li>301：重定向，资源永久移动，客户端不应该再继续通过该 url 访问该资源</li>
<li>302：重定向，资源临时移动，以后可能仍然使用该 url</li>
<li>304：not modified，浏览器可以使用本地缓存</li>
</ul>
</li>
<li>4xx请求错误——请求含有词法错误或者无法被执行<ul>
<li>400：bad request，客户发送的请求不能理解</li>
<li>403：forbidden，无权限，服务器拒绝提供服务</li>
<li>404：not found，没找到资源</li>
</ul>
</li>
<li>5xx服务器错误——服务器在处理某个正确请求时发生错误<ul>
<li>500：internal server error，服务器内部错误</li>
<li>502 – 网关错误。常见的情况是反向代理后端的服务器(比如resin或tomcat)没有启动。</li>
<li>503：server unavaliable，服务暂不可用</li>
<li>504 – 网关超时。比如请求时长超出了服务器的响应时间限制</li>
</ul>
</li>
</ul>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="">计算机网路(第六版) 谢希仁著 电子工业出版社</a></li>
<li><a href="https://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5" target="_blank" rel="external">维基百科：HTTP持久连接</a></li>
<li><a href="http://novoland.github.io/%E7%BD%91%E7%BB%9C/2014/07/31/%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81.html" target="_blank" rel="external">克鲁斯卡尔的博客：常见的HTTP状态码</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/16/TCP释放连接-四次挥手/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/16/TCP释放连接-四次挥手/" itemprop="url">TCP释放连接-四次挥手</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-16T09:40:17+08:00">
                2015-09-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TCP连接释放过程比较复杂，我们需要结合双方状态去理解。</p>
<h2 id="四次挥手图"><a href="#四次挥手图" class="headerlink" title="四次挥手图"></a>四次挥手图</h2><p><img src="https://farm6.staticflickr.com/5781/21461116181_dbff398812_z.jpg" alt=""></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>数据传输结束后，通信双方都可以释放连接。现在A和B都处于<code>ESTABLISHED</code>状态。步骤如下：</p>
<ul>
<li>A的应用进程先向其TCP发出连接释放报文段，并停止发送数据，主动关闭TCP连接。A把连接释放报文段(FIN包)首部的终止控制位<code>FIN = 1</code>，其序号<code>seq = u</code>，它等于前面已传送过的数据的最后一个字节+1。这时A进入<code>FIN-WAIT-1</code>状态。<del>注意，FIN报文段即使不携带数据，也要消耗一个序号</del>。</li>
<li>B收到连接释放报文段后立即发出确认，确认号<code>ack = u + 1</code>，这个报文段自己的 序号<code>seq = v</code>，等于B前面已传送过的数据的最后一个字节的序号+1。然后B就进入<code>CLOSE-WAIT</code>(关闭等待)状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于<code>半关闭</code>(half-close)状态，也就是A已经没有数据要发送了，但是B若发送数据，A仍要接收。也就是说，从B到A这个方向的连接并未关闭，这个状态可能会持续一些时间。</li>
<li>A接收来自B的确认后，就进入<code>FIN-WAIT-2</code>(终止等待2)状态，等待B发出的连接释放报文段。</li>
<li>直到B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使<code>FIN = 1</code>。假定B的序号<code>seq = w</code>(在半关闭状态B可能还发送了一些数据)。B还必须重复确认上次发送过的确认号<code>ack = u + 1</code>。这时B进入<code>LAST-ACK</code>(最后确认)状态，等待A的确认。</li>
<li>A收到来自B的连接释放报文后，必须对此发出确认。在确认报文段中设置<code>ACK = 1</code>，确认号<code>ack = w + 1</code>，而自己的序号为<code>seq = u + 1</code>(根据TCP标准，前面发送过的FIN报文段要消耗一个序号)。然后进入<code>TIME-WAIT</code>(时间等待)状态。请注意，现在TCP连接还没有释放掉，必须经过<strong>时间等待计数器</strong>设置的时间2MSL(MSL，Maximum Segment Lifetime，叫做最长报文段寿命，RFC793建议设置为2分钟.)后因此，从A进入到TIME-WAIT后，要经过4分钟才能进入<code>CLOSE</code>状态，才能开始建立下一个新的连接。</li>
<li>B接收到来自A的确认报文段，进入<code>CLOSE</code>状态。</li>
</ul>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul>
<li>为什么A在TIME-WAIT状态必须等待2MSL的时间？<blockquote>
<ol>
<li>为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段极有可能丢失，因而使得处在<code>LAST-ACK</code>状态的B收不到确认。B会超时重传FIN+ACK报文段，而A就能在2MSL时间内收到这个重传报文。接着A重传一次确认，重新启动2MSL计时器。最后A和B都能正常进入到CLOSED状态。相反滴，如果A在TIME-WAIT不等待一段时间，而是发送完ACK报文段后就立即释放连接进入CLOSED状态，那么就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法释放连接了。</li>
<li>防止”已失效的连接请求报文段”出现在本连接中。经过时间2MSL，就可以使本连接的时间所产生的所有报文段从网络中消失，这样就可以使下一个新的连接中不会出现旧的连接请求报文段。</li>
</ol>
</blockquote>
</li>
</ul>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="">计算机网络(第六版) 谢希仁著 电子工业出版社</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/16/TCP建立连接-Three-way-Handshake/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/16/TCP建立连接-Three-way-Handshake/" itemprop="url">TCP建立连接-Three-way Handshake</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-16T01:57:09+08:00">
                2015-09-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TCP 是面向连接的协议。运输连接是用来传送TCP报文的。TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。因此，运输连接就有3个阶段，即：<strong>建立连接、数据传送、释放连接</strong>。运输连接的管理就是使运输连接的建立和释放都能够正常进行。</p>
<p>在TCP建立连接过程中主要要解决3个问题：</p>
<blockquote>
<ol>
<li>要使每一方都能够确认对方的存在。</li>
<li>要允许双方协商一些参数(如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等)。</li>
<li>能够对传输实体资源(如缓存大小等)进行分配。</li>
</ol>
</blockquote>
<p> TCP连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做<strong>客户</strong>(client)，而被动等待连接建立的应用进程叫做<strong>服务器</strong>(server)。</p>
<h2 id="三次握手图"><a href="#三次握手图" class="headerlink" title="三次握手图"></a>三次握手图</h2><p><img src="https://farm6.staticflickr.com/5682/21432332432_2274d0fe5c_z.jpg" alt=""></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>上图画出了TCP的建立连接的过程。假定主机A运行的是TCP客户程序，而主机B运行的是TCP服务器程序。最初两端的TCP进程都处于<code>CLOSED</code>(关闭)状态。图中在主机下面的方框是TCP进程所处的状态。需要注意的是，<strong>A主动打开连接</strong>，而<strong>B被动打开连接</strong>。</p>
<p>连接过程如下：</p>
<blockquote>
<ol>
<li>B的TCP服务器进程先创建<code>传输控制块</code>TCB(Transmission Control Block)，准备接受客户进程的连接请求。然后服务器进程就处于<code>LISTEN</code>(监听)状态，等待客户的连接请求。如有，立即做出响应。</li>
<li>A的TCP客户进程也是首先创建TCB，然后想B发出连接请求的报文段(SYN包,表明需要得到回应)，这时<code>SYN = 1</code>，同时选择一个初始序列号<code>seq = x</code>。<del>该报文不能携带数据但要消耗一个序号</del>。这时，TCP客户进程进入<code>SYN-SENT</code>(同步已发送)状态。(ps.同步的意思就是想要收到回应。)</li>
<li>B收到连接请求报文段后，如果同意连接，则向A发送确认。在确认报文段(SYN+ACK包，回应确认连接并需要得到回应)中应设置<code>SYN = 1, ACK = 1</code>，并设置确认号<code>ack = x + 1</code>，同时自己也选择一个初始序号<code>seq = y</code>。<del>注意该报文段也不能携带数据并需要消耗一个序号</del>。这时TCP服务器进程进入<code>SYN-RCVD</code>状态。</li>
<li>TCP客户进程收到B确认后，还要回应B的请求。确认报文段(ACK包)中<code>ACK = 1, ack = y + 1</code>，而自己的序号为<code>seq = x + 1</code>。这个时候，<del>TCP标准规定，ACK报文段可以携带数据，但如果不携带则不消耗序号(这时下一个报文段的序号仍是seq = x + 1)</del>。这时，TCP连接已经建立，A进入<code>ESTAB-LISHED</code>状态。</li>
<li>当B收到A的确认后，也进入<code>ESTAB-LISHEB</code>状态。</li>
</ol>
</blockquote>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol>
<li>为什么A还要发送一次确认呢(也就是第三次握手)？</li>
</ol>
<blockquote>
<p>简单来说，是为了”让两边的请求都能被识别到，所以逻辑上需要3次”。</p>
<p>详细的说， 主要是为了”防止已经失效的连接请求报文段突然又传送到B，因而发生错误”。考虑这么一种情况：A发出连接请求，但因连接请求报文丢失而未收到确认。于是A再重传一次连接请求，后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了2个连接请求报文段，其中一个丢失，第二个到达了B。没有“已失效的连接请求报文段”。 现在，我们假定出现了一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某个网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到达B。本来这是一个早已失效的报文段。但是B收到此失效的连接报文段后，误以为是A又发出了一个新的连接请求。于是就向A发送了确认报文段，同意建立连接。假定不采用三次握手，那么只要B确认，新的连接就建立了。</p>
<p>由于现在A并没有发送建立连接的请求，因此不予理会B的确认，也不会向B发送数据。但是B却以为连接已经建立，并一直等待A发来数据，B的许多资源就这样浪费了。</p>
<p>采用第三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A不会向B的请求确认发出确认。B由于收不到确认，就知道A并没有要求建立连接。</p>
</blockquote>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="">计算机网络(第六版) 谢希仁著 电子工业出版社</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/15/7种经典排序算法总结和实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/15/7种经典排序算法总结和实现/" itemprop="url">7种经典排序算法总结和实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-15T20:15:07+08:00">
                2015-09-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>基于比较的7种排序算法</p>
<h2 id="冒泡排序BubbleSort"><a href="#冒泡排序BubbleSort" class="headerlink" title="冒泡排序BubbleSort"></a>冒泡排序BubbleSort</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>冒泡排序的原理比较简单，主要是两两比较，每次把比较大的数据放在后面，这样一次下来，最大的数就放在数组最后了。然后依次类推。</p>
<p>主要特性如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">排序算法</th>
<th style="text-align:left">平均情况</th>
<th style="text-align:left">最好情况</th>
<th style="text-align:left">最坏情况</th>
<th style="text-align:left">辅助空间</th>
<th style="text-align:left">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">冒泡排序</td>
<td style="text-align:left">O(n^2)</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(n^2)</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">稳定</td>
</tr>
</tbody>
</table>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>从索引为0的位置开始，往后依次两两比较，把大的数放在后面，小的数放在前面，这样一次下来最大的数就在数组末尾了(n)；</li>
<li>最后一个数完成排序，退出排序工作，也就是令n–；</li>
<li>重复第一步，直到n=0；</li>
</ul>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++)&#123;<span class="comment">// 遍历第i次，每一次排好后面的1个</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - i - <span class="number">1</span>; j++)&#123;<span class="comment">// 从a[0]开始，依次去后面尚未排序的元素两两比较，大的置后</span></div><div class="line">                <span class="keyword">if</span>(a[j] &gt; a[j + <span class="number">1</span>])&#123;</div><div class="line">                    temp = a[j];</div><div class="line">                    a[j] = a[j + <span class="number">1</span>];</div><div class="line">                    a[j + <span class="number">1</span>] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ul>
<li>每次排序，如果没有发生任何一次交换位置，说明已经是有序的了。因此可以用一个标识位记录是否交换了位置，如果没有则直接结束排序工作。</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2015/09/15/7种经典排序算法总结和实现/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/11/Java-正则表达式详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/11/Java-正则表达式详解/" itemprop="url">Java 正则表达式详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-11T02:21:27+08:00">
                2015-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在实际开发过程中,总会遇到很多<strong>有关字符串的查找、匹配、替换、判断等操作</strong>(参加中兴的笔试时也遇到一道相关题目,泪~~),而有时候情况还比较复杂,如果直接用编程的方式来处理,代码量稍多且麻烦,往往效率低下。而这个时候,正则表达式（Regex）就是解决这类问题的利器。</p>
<p>正则表达式是一种模式匹配和替换的规范,一个正则就是由普通的字符（如a-zA-Z0-9）以及特殊字符（元字符）组成的文字模式,它用以描述文字主体的一个或者多个待匹配的字符。正则表达式作为表达式的一个模板,将某个字符模式与所给字符主题进行匹配。</p>
<p>需要说明的是,几乎每个语言都提供了正则表达式的功能,但不同语言之间的正则表达式可能略微有些差别。本文主要讲解Java中的正则表达式。</p>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><p>有关正则表达式的类在<code>java.util.regex</code>中,主要包括三个类：<code>Pattern、Matcher、PatternSyntaxException</code>。</p>
<h3 id="Pattern（模式）"><a href="#Pattern（模式）" class="headerlink" title="Pattern（模式）"></a>Pattern（模式）</h3><p>pattern对象是一个正则表达式的编译表示形式。指定为字符串的正则表达式必须先编译为此类的实例。然后,将得到的模式用于创建Matcher对象（匹配器）。依照正则表达式,该对象可以和任意的字符序列匹配。执行匹配所涉及的状态都驻留在匹配器中,所以多个匹配器可以共用一个模式。</p>
<ul>
<li>临时使用Pattern</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex, CharSequence input)</span></span></div></pre></td></tr></table></figure>
<p>matches()方法编译给定正则表达式并尝试将给定输出与其匹配。其中regex是要编译的表达式,input是要匹配的字符序列。调用此便捷方法的形式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> b = Pattern.matches(<span class="string">"a*b"</span>, <span class="string">"aaaaab"</span>);</div></pre></td></tr></table></figure></p>
<ul>
<li>复用Pattern</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pattern <span class="title">compile</span><span class="params">(String regex)</span></span></div><div class="line"><span class="keyword">public</span> Matcher <span class="title">matcher</span><span class="params">(CharSequence input)</span></div></pre></td></tr></table></figure>
<p>其中compile将给定的正则表达式编译到模式中,而matcher则根据给定的字符序列创建与此模式的匹配器。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Pattern p = Pattern.compile(<span class="string">"a*b"</span>);</div><div class="line"> Matcher m = p.matcher(<span class="string">"aaaaab"</span>);</div><div class="line"> <span class="keyword">boolean</span> b = m.matches();</div></pre></td></tr></table></figure>
<h3 id="Matcher（匹配器）"><a href="#Matcher（匹配器）" class="headerlink" title="Matcher（匹配器）"></a>Matcher（匹配器）</h3><p>通过编译pattern对字符序列执行匹配操作的引擎。通过调用模式的matcher()方法创建匹配器。</p>
<h3 id="RegexSyntaxException"><a href="#RegexSyntaxException" class="headerlink" title="RegexSyntaxException"></a>RegexSyntaxException</h3><p>抛出未检查的异常,说明正则表达式中存在语法错误。</p>
<h2 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h2><p>捕获组是把多个字符当一个独立单元进行处理的方法,它通过括号内的字符分组来创建。例如,正则表达式(dog)创建了一个单一的捕获组,组里包含’d’、’o’、’g’。</p>
<p>捕获组是通过从左到右计算其括号来编号。例如,在表达式<code>( (A) ( B (C) ) )</code>中,有4个捕获组：</p>
<ul>
<li>((A)(B(C)))</li>
<li>(A)</li>
<li>(B(C))</li>
<li>(C)</li>
</ul>
<p>可以通过matcher对象的groupCount()方法来查看有多少个捕获组。groupCount()返回一个int值,表示matcher对象当前有多少个捕获组。</p>
<p>还有一个特殊的组（组0）,它总是代表整个表达式。该组不包括在groupCount()的返回值中。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><img src="https://farm1.staticflickr.com/750/21115610099_6e52dbfc33_c.jpg" alt=""><br><img src="https://farm6.staticflickr.com/5661/21291904852_d504878375_c.jpg" alt=""><br><img src="https://farm1.staticflickr.com/585/21114641598_c992430fbb_c.jpg" alt=""><br><img src="https://farm1.staticflickr.com/606/21276261466_2c254a28f6_c.jpg" alt=""></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.regex.Matcher;</div><div class="line"><span class="keyword">import</span> java.util.regex.Pattern;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexMatches</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span></span>&#123;</div><div class="line"></div><div class="line">      <span class="comment">// 按指定模式在字符串查找</span></div><div class="line">      String line = <span class="string">"This order was placed for QT3000! OK?"</span>;</div><div class="line">      String pattern = <span class="string">"(.*)(\\d+)(.*)"</span>;</div><div class="line"></div><div class="line">      <span class="comment">// 创建 Pattern 对象</span></div><div class="line">      Pattern r = Pattern.compile(pattern);</div><div class="line"></div><div class="line">      <span class="comment">// 现在创建 matcher 对象</span></div><div class="line">      Matcher m = r.matcher(line);</div><div class="line">      System.out.println(<span class="string">"groupCount: "</span> + m.groupCount());</div><div class="line">      <span class="keyword">if</span> (m.find( )) &#123;</div><div class="line">         System.out.println(<span class="string">"Found value: "</span> + m.group(<span class="number">0</span>) );</div><div class="line">         System.out.println(<span class="string">"Found value: "</span> + m.group(<span class="number">1</span>) );</div><div class="line">         System.out.println(<span class="string">"Found value: "</span> + m.group(<span class="number">2</span>) );</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">         System.out.println(<span class="string">"NO MATCH"</span>);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上实例编译运行结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">groupCount: <span class="number">3</span></div><div class="line">Found value: This order was placed <span class="keyword">for</span> QT3000! OK?</div><div class="line">Found value: This order was placed <span class="keyword">for</span> QT300</div><div class="line">Found value: <span class="number">0</span></div></pre></td></tr></table></figure></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Java正则的功用还有很多,事实上只要是字符处理,就没有正则做不到的事情存在。（当然,正则解释时较耗时间就是了|||……）</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://blog.csdn.net/kdnuggets/article/details/2526588" target="_blank" rel="external">CSDN：Java正则表达式入门</a></li>
<li><a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="external">RUNOOB.com：Java 正则表达式</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/10/Tomcat的类加载器架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/10/Tomcat的类加载器架构/" itemprop="url">Tomcat的类加载器架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-10T10:23:50+08:00">
                2015-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Web服务器需要解决的几个问题"><a href="#Web服务器需要解决的几个问题" class="headerlink" title="Web服务器需要解决的几个问题"></a>Web服务器需要解决的几个问题</h2><p>主流的Java Web服务器，如Tomcat、Jetty、WebLogic、WebSphere或其他没有列举的服务器，都实现了自己定义的类加载器，而且一般还不止一个。因为一个功能健全的Web服务器，要解决如下几个问题：</p>
<ul>
<li><strong>部署在同一服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离</strong>。这是最基本的需求，两个不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求一个类库在一个服务器中只有一份，服务器应当保证两个应用程序的类库可以互相独立使用。</li>
<li><strong>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以互相共享</strong>。这个需求也很常见，例如，用户可能有10个使用Spring组织的应用程序部署在同一台服务器上，如果把10份Spring分别存放在各个应用程序的隔离目录，将会是很大的资源浪费-这主要不是磁盘空间的问题，而是指类库在使用时都要被加载到服务器内存中，如果类库不能共享，虚拟机的方法区就会容易出现过度膨胀的风险。</li>
<li><strong>服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响</strong>。目前，有许多主流的Web服务器自身也是使用Java语言来实现的。因此服务器本身也有类库依赖的问题，一般来说，基于安全考虑，服务器所使用的类库应该与应用程序的类库互相独立。</li>
<li><strong>支持JSP应用的Web服务器，大多数都需要支持HotSwap功能</strong>。我们知道，JSP文件最终要编译成Java Class才能由虚拟机执行，但JSP文件由于其纯文本存储的特性，运行时修改的概率远远大于第三方类库或程序自身的Class文件。而且ASP、PHP和JSP这些网页应用也把修改后无须重启作为一个很大的“优势”来看待。因此主流的Web服务器都会支持JSP生成类的热替换，当然也有非主流的，如运行在生产模式（Production Mode）下的WebLogic服务器默认就不会处理JSP文件的变化。</li>
</ul>
<p>由于存在上述问题，在部署Web引用时，单独的一个ClassPath就无法满足需求了，所以各种Web服务器都“不约而同”地提供了好几个ClassPath路径使得用户存放第三方类库，这些路径一般都以“lib”或者“classes”命名。被放置在不同路径中的类库，具备不同的访问范围和服务对象，通常，每一个目录都会有一个相对应的自定义类加载器去加载放置在里面的Java类库。下面我们来看看Tomcat服务器，看看Tomcat具体是如何规划用户类库结构和类加载器的。（ps.这里用的是Tomcat5.x版本，在Tomcat6.x的默认配置下，/common、/server、/shared三个目录已经合并在一起了。）</p>
<h2 id="Tomcat的类库结构"><a href="#Tomcat的类库结构" class="headerlink" title="Tomcat的类库结构"></a>Tomcat的类库结构</h2><p>在Tomcat目录结构中，有3组目录<code>/common/*、/server/*、/shared*</code>，可以存在Java类库，另外还可以加上Web应用程序自身的目录<code>/WEB-INF/*</code>，一共4组，把Java类库放置在这些目录中的含义如下。</p>
<table>
<thead>
<tr>
<th style="text-align:left">目录</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">common</td>
<td style="text-align:left">类库对Tomcat和所有的Web应用程序可见</td>
</tr>
<tr>
<td style="text-align:left">server</td>
<td style="text-align:left">类库对Tomcat可见，对Web应用程序不可见</td>
</tr>
<tr>
<td style="text-align:left">shared</td>
<td style="text-align:left">类库对Tomcat不可见，对所有Web应用程序可见</td>
</tr>
<tr>
<td style="text-align:left">WEB-INF</td>
<td style="text-align:left">类库对Tomcat和其他Web应用不可见，只对Web程序本身可见</td>
</tr>
</tbody>
</table>
<h2 id="Tomcat的类加载器架构"><a href="#Tomcat的类加载器架构" class="headerlink" title="Tomcat的类加载器架构"></a>Tomcat的类加载器架构</h2><p>为了支持这套目录结构，并对目录里面的类库进行加载和隔离，Tomcat自定义了多个类加载器，这个类加载器按照经典的双亲委派模式来实现，其关系如下图。<br><img src="https://farm6.staticflickr.com/5731/21246810966_210ae9b257_b.jpg" alt=""></p>
<p>顶层3个类加载器是JDK默认提供的类加载器，这3个加载器的作用在这里有解析<a href="http://www.luohuida.com/2015/09/09/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">JVM-类加载机制</a>.而CommonClassLoader、CatalinaClassLoader、SharedClassLoader、WebAppClassLoader则是Tomcat自定义的类加载器，它们分别加载<code>/common/*、/server/*、/shared/*、/WEB-INF/*</code>中的类库。其中WebApp类加载器和Jsp类加载器通常会存在多个实例，每一个Web应用对应一个WebApp类加载器，每一个Jsp文件对应一个Jsp类加载器。</p>
<p>从上图的委派关系中可以看出，<strong>CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader使用，而CatalineClassLoader和SharedClassLoader自己能加载的类则与双方相互隔离。</strong> WebAppClassLoader可以使用ShareClassLoader加载到的类，，但各个WebAppClassLoader实例之间相互隔离。而JasperClassLoader的加载范围仅仅是这个JSP文件所编译出来的那一个Class文件，它出现的目的就是为了被丢弃：当服务器检测到JSP文件被修改的时候，会替换掉目前的JasperClassLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能（那究竟是如何实现的？）。</p>
<p>对于Tomcat的6.x版本，只有指定了<code>tomcat/conf/catalina.properties</code>配置文件的server.loader和shared.loader项后才会真正建立CatalinaClassLoader和SharedClassLoader的实例，否则会用到这两个类的地方都会用CommonClassLoader的实例代替，而默认的配置文件中没有设置这两个项。所以Tomcat6.x顺理成章地把/common、/shared和/server三个目录合并成了一个/lib目录，这个目录里的类库相当于以前的/common目录中类库的作用。这是Tomcat设计团队为了简化大多数的部署场景所做的一项改进，如果默认的设置不能满足需求，用户可以通过修改配置文件指定server.loader和shared.loader的方式重新启动Tomcat5.x的类加载器架构。</p>
<h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><p>思考一个问题：前面曾经提到过一个场景，如果有10个Web应用程序都是用Spring来进行组织和管理的话，可以把Spring放在Common或者Shared目录下让这些程序共享。Spring要对用户程序的类进行管理，自然要能访问到用户程序的类，而用户的程序显示是放在/WebApp/WEB-INF目录中的，那么被CommonClassLoader或SharedClassLoader加载的Spring如何访问并不在其加载范围内的用户程序呢？</p>
<blockquote>
<p>解答：按照我的理解，类的加载是双亲委派模型，当需要加载Spring时，Tomcat会优先使用WebAppClassLoader去加载Spring，然后会委托父类加载器SharedClassLoader，这时SharedClassLoader加载/shared里面的Spring类库，所以在WebAppClassLoader加载Spring成功。而每个WebAppClassLoader是隔离的，它们加载的Spring互不影响。</p>
</blockquote>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/09/JVM-类加载机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/09/JVM-类加载机制/" itemprop="url">JVM 类加载机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-09T02:39:13+08:00">
                2015-09-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>虚拟机是如何加载Class文件的？Class文件加载到虚拟机后会发生什么变化？这些问题都牵涉到虚拟机的类加载机制。虚拟机把描述类的数据从Class文件中加载到内存中，并对数据进行校验（为什么要校验？）、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型（怎么样的才能直接使用呢？），这就是虚拟机的类加载机制。</p>
<p>与那些在编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的。这种策略虽然会令类加载时稍微增加一些性能开销（这里指定是时间上的开销吧？），但是会为Java程序提供高度的灵活性，<strong>Java天生可以动态扩展（怎么算动态扩展？）的语言特性就是依赖运行期间动态加载和动态连接这个特点实现的</strong>。</p>
<hr>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a><strong>类加载的时机</strong></h2><p>类从被加载到虚拟机内存中开始使用，到卸载出内存位置，它的整个生命周期如下图。<br><img src="https://farm6.staticflickr.com/5794/21033863319_d6946a3dc9_b.jpg" alt="类的生命周期"></p>
<p>上图中，加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始。<strong>但是解析阶段却不一定，它在某些情况下可以在初始化阶段之后再开始</strong>，这是为了支持Java语言的运行时绑定（这是什么鬼？？？）。</p>
<p>什么时候需要开始类加载过程的第一个阶段：加载。Java虚拟机规范中并没有进行强制约束，这点可以由虚拟机自由把握。但是<strong>对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行”初始化”</strong>（而加载、验证、准备自然需要在此之前开始）。</p>
<ol>
<li>遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类没有进行过类的初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候、调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包的方法堆类进行反射调用的时候，如果类没有进行初始化过，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动的时候，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个类。</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法的句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。（这里只能呵呵了，句柄是什么鬼？？？）</li>
</ol>
<p>对于这5种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定词：”有且只有”，<strong>这5种场景中的行为成为对一个类进行主动引用</strong>。除此之外，所有引用类的方法都不会触发初始化，成为被动引用。</p>
<h3 id="被动引用场景-1：通过子类引用父类的静态字段，不会导致子类初始化。"><a href="#被动引用场景-1：通过子类引用父类的静态字段，不会导致子类初始化。" class="headerlink" title="被动引用场景-1：通过子类引用父类的静态字段，不会导致子类初始化。"></a>被动引用场景-1：<strong>通过子类引用父类的静态字段，不会导致子类初始化</strong>。</h3><p><img src="https://farm6.staticflickr.com/5708/21034022708_e7d1c442fb_o.png" alt=""></p>
<p>输出结果：</p>
<blockquote>
<p>SuperClass init.<br>123</p>
</blockquote>
<p>类加载列表：</p>
<blockquote>
<p>[Loaded test1 from file:]<br>[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]<br>[Loaded SuperClass from file:]<br>[Loaded SubClass from file:]<br>SuperClass init.<br>123<br>[Loaded java.lang.Shutdown from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]<br>[Loaded java.lang.Shutdown$Lock from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]</p>
</blockquote>
<p>分析：</p>
<blockquote>
<p>上面的代码之所以没有输出“SubClass init.”，是因为对于静态字段，只有直接定义了这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否要触发子类的加载和验证，在虚拟机规范中并未规定。对于HotSpot虚拟机来说，可通过-XX:+TraceClassLoading参数来观察此操作会导致子类的加载。</p>
</blockquote>
<h3 id="被动引用场景-2：通过数组定义来引用类，不会触发此类的初始化。"><a href="#被动引用场景-2：通过数组定义来引用类，不会触发此类的初始化。" class="headerlink" title="被动引用场景-2：通过数组定义来引用类，不会触发此类的初始化。"></a>被动引用场景-2：<strong>通过数组定义来引用类，不会触发此类的初始化</strong>。</h3><p><img src="https://farm1.staticflickr.com/690/21034481358_a1788f6c88_o.png" alt=""></p>
<p>输出结果：（无）</p>
<p>类加载列表：</p>
<blockquote>
<p>[Loaded test2 from file:]<br>[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]<br>[Loaded SuperClass from file:]<br>[Loaded java.lang.Shutdown from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]<br>[Loaded java.lang.Shutdown$Lock from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]</p>
</blockquote>
<p>分析：</p>
<blockquote>
<p>运行之后发现没有输出“SuperClass init.”，说明没有触发类SuperClass的初始化阶段。但是这段代码里面触发了另一个名为”[LSuperClass”的类的初始化阶段，对于用户来说，这并不是一个合法的累名称，它是一个又虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令anewarray触发。这个类代表了一个元素类型为SuperClass的一维数组，数组中应有的属性和方法（用户可直接只用的只有被修饰未public的length属性和clone方法）都实现在这个类里面。Java语言中对数组的访问比C/C++相对安全是因为这个类封装了数组元素的访问方法（准确地说，越界检查不是封装在数组元素访问的类中，而是封装在数组访问的xaload、xastore字节码指令中），而C/C++直接翻译为对数组指针的移动。在java语言中，当检查发生数组越界时会抛出java.lang.ArrayIndexOutOfBoundsException异常。</p>
</blockquote>
<h3 id="被动引用场景-3：使用父类常量不会触发定义常量的类的初始化"><a href="#被动引用场景-3：使用父类常量不会触发定义常量的类的初始化" class="headerlink" title="被动引用场景-3：使用父类常量不会触发定义常量的类的初始化"></a>被动引用场景-3：<strong>使用父类常量不会触发定义常量的类的初始化</strong></h3><p><img src="https://farm6.staticflickr.com/5696/20600709404_7c953b20ab_b.jpg" alt=""></p>
<p>输出结果：</p>
<blockquote>
<p>Hello World.</p>
</blockquote>
<p>类加载列表：</p>
<blockquote>
<p>[Loaded test from file:]<br>[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]<br>Hello World.<br>[Loaded java.lang.Shutdown from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]<br>[Loaded java.lang.Shutdown$Lock from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]</p>
</blockquote>
<p>分析：</p>
<blockquote>
<p>上述代码运行之后，也没有输出“ConstClass init.”，这是因为虽然在Java源码中引用了ConstClass类中的常量HW，但其实在编译阶段通过<strong>常量传播优化</strong>，已经将此常量的值“Hello World.”存储到<strong>test类的常量池</strong>中，以后test对常量ConstClass.HW的引用实际都被转化为test类对自身常量池（每个类都有自己的常量池？？）的引用了。也就是说，实际上test的Class文件中没有ConstClass类的<strong>符号引用入口</strong>，这两个类在翻译成Class之后就不存在任何联系了。</p>
</blockquote>
<p><strong>PS</strong>：接口的加载过程与类加载稍有一些不同，针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的，上面的代码块都是用<code>static {}</code>来输出初始化信息的，而接口中不能使用，但是编译器仍然会为接口生成 <code>&lt;clinit&gt;()</code>类构造器（方法构造器是<code>&lt;init&gt;()</code>），用于初始化接口中所定义的成员变量。<br><strong>PSS</strong>：接口与类真正有所区别的是前面讲述的5种“有且仅有”需要开始初始化的第3种：当一个类在初始化，要求其父类全部都已经初始化过了。但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（比如引用接口中定义的常量）才会初始化。</p>
<hr>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a><strong>类加载过程</strong></h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a><strong>加载</strong></h3><p>“加载”是“类加载”（Class Loading）过程的一个阶段。在加载阶段，虚拟机需要完成3件事：</p>
<ol>
<li>通过一个<strong>类的全限定名</strong>（java.lang.Object的全限定名为java/lang/Object）来获取定义此类的二进制字节流；</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；</li>
</ol>
<p>虚拟机规范的这3点要求其实不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的。例如“通过类的全限定名来获取此类的二进制字节流”这条，它没有指明二进制字节流要从一个Class文件获取，准确地说根本没有指明要从哪里获取、怎样获取。虚拟机设计团队在加载阶段搭建了一个相当开放的、广阔的“舞台”，许多举足轻重的Java技术都建立在这基础上，例如：</p>
<ul>
<li>从ZIP包中获取，这很常见，最终成为JAR、EAR、WAR格式的基础。</li>
<li>从WEB中获取，这种场景最典型的应用就是Applet了。</li>
<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerateProxyClass来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景就是JSP应用，即由JSP文件生成对应的Class类。</li>
<li>从数据库中读取，这种场景相对少见，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成代码在集群间的分发。</li>
<li>….<br>说这么多，其实就是要说明二进制字节流来源多。。。</li>
</ul>
<p>相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发者可以通过自定义的类加载器去控制字节流的获取方式（也就是重写一个类加载器的loadClass()方法）。</p>
<p>对于数组类而言，情况就有所不同，<strong>数组类本身不通过类加载器创建</strong>，它是由Java虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，一个数组类（下面简称C）创建过程遵循以下规则：</p>
<ul>
<li>如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类型，那就递归采用上面定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识（！important，一个类必须与类加载器一起唯一确定性）。</li>
<li>如果数组的组件不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与引导类加载器关联。</li>
<li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将被默认为public。</li>
</ul>
<p>关于类加载器，可以查看后续段落。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象（<strong>并没有规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面</strong>），这个对象作为程序访问方法区中的这些类型数据的外部接口。</p>
<p>加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这2个阶段的开始时间仍然保持这固定的先后顺序。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h3><p>验证的目的是为了确保Class文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>Java语言本身是相对安全的语言，使用纯碎的Java代码无法做到诸如访问数组边界外的数据、将一个对象转换未它并未实现的类型、跳转到不存在的代码行之类的事情。如果做了，编译器将拒绝编译。但前面说过，Class文件并不一定要求用Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写产生Class文件。在字节码语言层面，上述Java代码无法做到的事情都是可以实现的，至少语义上是可以表达出来的。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机堆自身安全的一项重要工作。</p>
<p>验证阶段是非常重要的，这个阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代码的攻击，从执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载子系统又占了相当大的一部分。《Java虚拟机规范（第二版）》对这个阶段的限制、指导还是比较笼统的，规范中列举了一些Class文件格式中的静态和结构化约束，如果验证到输入的字节流不符合Class文件格式的约束，虚拟机就应该抛出一个java.lang.VerifyError异常或者其子类异常，但具体应当检查哪些方面、如何检查、何时检查，都没有足够具体的要求和明确的说明。直到2011年发布的《Java虚拟机规范（Java SE 7版）》大幅增加了描述验证过程的篇幅（从不足10页到130页），这时约束和验证规则才变得具体起来。下面从整体上看，验证阶段大致会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
<h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a><strong>文件格式验证</strong></h4><p>第一阶段验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这个阶段可能包括下面这些验证点：</p>
<ul>
<li>是否以魔数0xCAFEBABE（为了方便虚拟机识别文件是否是class格式的文件，JVM规定每个class文件都必须以一个word(4个字节)来开始，这个数字就称为魔数）开头。</li>
<li>主、次版本号是否在当前虚拟机的处理范围之内（魔数后续的内容就是一个word的长度来表示生成的class文件的版本号，版本号分为主版本号和次版本号，其中前两个字节表示次版本号，后两个字节表示主版本号，排列的顺序遵从高位在前，低位在后的原则）。</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。</li>
<li>Class文件中各个部分及文件本身是否有被删除或附加的其他信息。</li>
<li>…..</li>
</ul>
<p>实际上，第一阶段的验证点还远不止这些，上面这些只是从HotSpot虚拟机源码中摘抄的一小部分，<strong>该验证阶段的主要是保证输入的字节流能正确地解析并存储于方法区中，格式上符合描述一个Java类型信息的要求</strong>。<em>这阶段的验证是基于二进制字节流进行的，只有通过这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面3个验证阶段全部都是基于方法区的存储结构进行的，不会再直接操作字节流。</em></p>
<h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a><strong>元数据验证</strong></h4><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，这个阶段可能包括的验证点如下：</p>
<ul>
<li>这个类是否有父类（除了java.lang.Object之外，所有类都应当有父类）。</li>
<li>这个类的父类是否抽象了不允许被继承的类（被final修饰的类）。</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段、出现了不符合规则的方法重载比如方法参数都一样但返回值类型不同等）。</li>
<li>……</li>
</ul>
<p><strong>第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</strong></p>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a><strong>字节码验证</strong></h4><p>第三阶段是整个验证过程中最复杂的一个阶段，<strong>主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</strong>在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如：</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载如本地变量表中。</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li>
<li>保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，只是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</li>
<li>……</li>
</ul>
<p>如果类方法体的字节码没有通过字节码验证，那肯定有问题；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。即使字节码验证之中进行了大量的检验，也不能保证这一点，这里涉及了一个离散数学中很著名的问题“Halting Problem”：通俗的说就是，通过程序去校验程序逻辑是无法做到绝对准确的–不能通过程序准确地检查出程序是否能在有限的时间内结束运行。</p>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a><strong>符号引用验证</strong></h4><p>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接第三阶段—解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性检验，通过需要校验一下内容：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段、方法的访问性（public、default、protectd、private）是否可以被当前类访问。</li>
<li>……</li>
</ul>
<p><strong>符号引用验证的目的是确保解析动作能正常执行</strong>，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p>
<p>对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要的（因为对程序运行期没有影响）阶段。如果所运行的全部代码（包括自己编写的以及第三方的代码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用<code>-Xverify:none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h3><p>准备阶段<strong>是正式为类变量分配内存并且设置类变量初始值的阶段，这些变量所使用的内存将在方法区进行分配</strong>。这个阶段中有2个容易产生混淆的概念需要强调一些，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p>
<blockquote>
<p>public static int value = 123;</p>
</blockquote>
<p>那变量value在准备阶段的初始值是0而不是123，因为这时候尚未开始任何Java方法，而把value赋值为123的<code>putstatic</code>指令是在程序被编译后，存放于类构造器<clint>()方法中，所以把value赋值未123的动作将在初始化阶段才会执行。下表是Java中所有基本数据类型的零值。<br>|数据类型|零值|<br>|:-|:-|<br>|byte|(byte)0|<br>|short|(short)0|<br>|int|0|<br>|long|0L|<br>|float|0.0f|<br>|double|0.0d|<br>|char|’\u0000’|<br>|boolean|false|<br>|reference|null|</clint></p>
<p>上面提到，在“通常情况”下，初始值是零值，相对的“特殊情况”就是：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就回被初始化为ConstantValue属性所指定的值，假如有：</p>
<blockquote>
<p>public static <strong>final</strong> int value = 123;</p>
</blockquote>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值未123.</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a><strong>解析</strong></h3><p>解析阶段是<strong>虚拟机将常量池内的符号引用替换为直接引用的过程</strong>。那解析阶段中的所说的直接引用与符号引用有什么关联呢？</p>
<ul>
<li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时无歧义地定位到目标即可。<strong>符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中</strong>。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</li>
<li>直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。<strong>直接引用是和虚拟机实现的内存布局相关的</strong>，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。<strong>如果有了直接引用，那引用的目标必定已经存在内存中</strong>。</li>
</ul>
<p>虚拟机规范并未规定解析阶段发生的具体时间，只要求在执行</p>
<blockquote>
<p>anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield、putstatic</p>
</blockquote>
<p>这16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p>
<h4 id="类或接口解析"><a href="#类或接口解析" class="headerlink" title="类或接口解析"></a><strong>类或接口解析</strong></h4><p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要一下3个步骤：D（N -&gt; C）</p>
<ol>
<li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或者实现的接口。一旦这个加载过程出现任何异常，解析过程就宣告失败。</li>
<li>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型，那么需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。</li>
<li>如果上面的步骤没有任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IIlegalAccessError异常。</li>
</ol>
<h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a><strong>字段解析</strong></h4><p>要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项中索引中的CONSTANT_Class_info符号引用，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口的符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按如下步骤对C进行后续字段的搜索。</p>
<ol>
<li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符斗鱼目标相匹配的字段，则返回这个字符的直接引用，查找结束。</li>
<li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</li>
</ol>
<p>如果成功返回了直接引用，还要对直接引用进行权限验证，如果没有相应的权限，则会抛出java.lang.IIlegalAccessError异常。</p>
<h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a><strong>类方法解析</strong></h4><p>类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。</p>
<ol>
<li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，搜索结束。</li>
<li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li>
</ol>
<h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a><strong>接口方法解析</strong></h4><p>接口方法解析的第一个步骤与字段解析一样，也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。</p>
<ol>
<li>与类方法解析不同，如果在接口方法表现class_index中索引C是个类而不是接口，就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，搜索结束。</li>
<li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li>
</ol>
<p>由于接口中的所有方法默认都是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lang.IIlegalAccessError异常。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h3><p>类的初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全有虚拟机主导控制。到了初始化阶段，才真正开始执行类中定义的java代码（或者说是字节码）。</p>
<p>在准备阶段，变量已经赋值过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器&lt; clinit &gt;()方法的过程。我们迟点会解析这个方法是如何生成的，but for now，我们先看这个方法执行过程中一些可能会影响程序运行行为的特点和细节，这部分相对比较贴近普通程序开发者。</p>
<ul>
<li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（statci{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，<strong>静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</strong>。如下代码<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        i = <span class="number">0</span>; <span class="comment">// 给变量赋值可以正常编译通过</span></div><div class="line">        System.out.println(i); <span class="comment">// 这句会提示"非法前向引用"错误</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>Test.java:4: 错误: 非法前向引用<br>        System.out.println(i); // 这句会提示”非法向前引用”<br>                           ^<br>1 个错误</p>
</blockquote>
<ul>
<li><code>&lt;clinit&gt;()</code>方法与类的构造函数（或者说是实例构造器<code>&lt;init&gt;()</code>方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此在虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法肯定是java.lang.Object的。</li>
<li><p>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的赋值操作。如下代码，字段B的值是2而不是1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		System.out.println(Sub.B);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</div><div class="line">		<span class="keyword">static</span> &#123;</div><div class="line">			A = <span class="number">2</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</p>
</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法并不需要执行父类的<code>&lt;clinit&gt;()</code>方法。只有当使用父接口中定义的变量时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</li>
<li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要线程阻塞等待，知道活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</li>
</ul>
<hr>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a><strong>类加载器</strong></h2><p>虚拟机团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放在Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<p>类加载器可以说是Java语言创新的一项创新，也是Java语言流行的重要原因之一，它最初是为了满足Java Applet的需求而开发出来的。虽然现在Applet技术基本已经“死亡”，但类加载器却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为Java技术体系中一块重要的基石。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a><strong>类与类加载器</strong></h3><p>类加载器虽然只用于实现类的加载动作，但是它在Java程序中起到的作用却远远不限于类加载阶段。对于任意类，都需要由它的类加载器和这个类本身一同确定其在Java虚拟机中的唯一性，<strong>每一个类加载器，都拥有一个独立的类命名空间</strong>。这句话可以表达得更通俗一些：比较2个类是否“相等”，只有在这2个类是由同一个类加载器加载的前提下才有意义，否则，即使这2个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这2个类必定不相等。</p>
<p>这里所谓的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果。以下代码演示了不同类加载器堆instanceof关键字运算的结果的影响。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 类加载器与instanceof关键字演示</div><div class="line">**/</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">		ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</div><div class="line">					InputStream is = <span class="keyword">this</span>.getClass().getResourceAsStream(fileName);</div><div class="line">					<span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</div><div class="line">						<span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</div><div class="line">					is.read(bs);</div><div class="line">					<span class="keyword">return</span> defineClass(name, bs, <span class="number">0</span>, bs.length);</div><div class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		Object obj = myLoader.loadClass(<span class="string">"ClassLoaderTest"</span>).newInstance();</div><div class="line">		System.out.println(obj.getClass());</div><div class="line">		System.out.println(obj <span class="keyword">instanceof</span> ClassLoaderTest);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<blockquote>
<p>class ClassLoaderTest<br>false</p>
</blockquote>
<p>上面代码构造了一个简单的类加载器，尽管很简单，但是很简单，但是对于这个演示还是够用了。它可以加载与自己在同一路径下的Class文件。我们使用这个类加载器去加载了一个名为”ClassLoaderTest”的类，并实例化了这个类的对象。2行输出中，从第1行我们可以看出，这个对象确实是类ClassLoaderTest实例化出来的对象，但从第2行可以发现，这个对象与ClassLoaderTest做所属类型检查的时候却返回了false，这是因为虚拟机中存在了2个ClassLoaderTest类，一个由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都来自同一个Class文件，但依然是2个独立的类，做对象所属类型检查时结果自然为false。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a><strong>双亲委派模型</strong></h3><p>从Java虚拟机的角度来讲，只存在2种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++实现（这里指的是HotSpot，想MRP、Maxine等虚拟机，整个虚拟机都是由Java编写的，自然Bootstrap ClassLoader也是由Java而不是C++实现。退一步讲，除了HotSpot以外的2个高性能虚拟机JRockit和J9都有一个代表Bootstrap ClassLoader的Java类存在，但是关键方法的实现还是利用JNI回调到C（注意不是C++）的实现上，这个Bootstrap ClassLoader的实例也无法被用户获取到），是虚拟机自身的一部分；另外一种就是所有其他的类加载器，这些类加载器都Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</p>
<p>从开发人员的角度来看，类加载器还可以分的更细致一些，绝大部分程序都会使用到以下3种系统提供的类加载器。</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：前面介绍过，这个类负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录下也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器的时候，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。</li>
<li>扩展类加载器（Extension ClassLoader）：这个加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader）：这个类加载器由<code>sun.misc.Launcher$ApplClassLoader</code>实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，<strong>如果程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</strong>。</li>
</ul>
<p>我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这几种类加载器之间的关系如下图。<br><img src="https://farm6.staticflickr.com/5793/21250745705_5cf57d4632.jpg" alt=""></p>
<p>上图所示的类加载器之间的这种层次关系，称为类加载器的<code>双亲委派模型</code>(Parents Delegation Model)。双亲委派模型要求除了顶层的BC之外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。</p>
<p>类加载器的双亲委派模型在JDK1.2期间被引入并广泛只用于几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，二是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。因此所有的加载请求最终都应该传送到顶层的BC中，只有当父类加载器反馈自己无法完成加载时（它的搜索范围没有找到所需的类），子加载器才会尝试自己去加载。</p>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都是委派给处于顶层的BC进行加载，因此Object类在程序的各个类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，哪系统将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也会变得一片混乱。可以尝试去编写一个与rt.jar类库中已有类重名的Java类，将会发现可以正常编译，但永远无法加载。</p>
<p>双亲委派模型对于保证Java程序的稳定运作很重要，但它的实现却非常简单，实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass()方法中。</p>
<h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a><strong>破坏双亲委派模型</strong></h3><hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>本文介绍了类加载过程的“加载”、“验证”、“准备”、“解析”、“初始化”5个阶段中虚拟机进行了哪些操作，也介绍了类加载器的工作原理及其堆虚拟机的意义。</p>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/08/JVM体系结构(图文版)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/08/JVM体系结构(图文版)/" itemprop="url">JVM体系结构(图文版)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-08T11:38:27+08:00">
                2015-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="https://farm6.staticflickr.com/5794/21224115322_9895561ba6_b.jpg" alt=""></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://www.zhangsr.cn/it/blog_read.action?id=2012" target="_blank" rel="external">JVM 体系结构</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/07/HotSpot虚拟机主要参数表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/07/HotSpot虚拟机主要参数表/" itemprop="url">HotSpot虚拟机主要参数表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-07T17:17:59+08:00">
                2015-09-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>摘自《深入理解Java虚拟机-JVM高级特性与最佳实践 第二版》周志明著</p>
</blockquote>
<p><img src="https://farm1.staticflickr.com/598/21186240906_db3173f21a_b.jpg" alt=""></p>
<p><img src="https://farm6.staticflickr.com/5725/21186231036_835b9b559d_b.jpg" alt=""></p>
<p><img src="https://farm6.staticflickr.com/5797/21202103392_4802673a81_b.jpg" alt=""></p>
<p><img src="https://farm1.staticflickr.com/720/21186210926_d15c1e9145_b.jpg" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/07/虚拟机字节码指令表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/07/虚拟机字节码指令表/" itemprop="url">虚拟机字节码指令表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-07T17:17:07+08:00">
                2015-09-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>摘自《深入理解Java虚拟机-JVM高级特性与最佳实践 第二版》周志明著</p>
</blockquote>
<p><img src="https://farm1.staticflickr.com/708/21202195802_d43a68a789_b.jpg" alt=""></p>
<p><img src="https://farm6.staticflickr.com/5726/21024641578_230acfb1b9_b.jpg" alt=""></p>
<p><img src="https://farm1.staticflickr.com/601/21025733259_4c2b8c3d29_b.jpg" alt=""></p>
<p><img src="https://farm1.staticflickr.com/605/20591402633_5f424b95c4_b.jpg" alt=""></p>
<p><img src="https://farm1.staticflickr.com/731/21212515255_1d558796fc_b.jpg" alt=""></p>
<p><img src="https://farm1.staticflickr.com/734/21212504835_f929691dac_b.jpg" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png"
               alt="archerda" />
          <p class="site-author-name" itemprop="name">archerda</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">66</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">37</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/archerda" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:luo.archer@gmail.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Email
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">archerda</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
