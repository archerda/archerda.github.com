<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="archerda, ArcherdaArcherda's BlogHexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Archerda&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Archerda&#39;s Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Archerda&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/"/>





  <title>Archerda's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Archerda's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Programmer. Meditating.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/07/虚拟机字节码指令表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/07/虚拟机字节码指令表/" itemprop="url">虚拟机字节码指令表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-07T17:17:07+08:00">
                2015-09-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>摘自《深入理解Java虚拟机-JVM高级特性与最佳实践 第二版》周志明著</p>
</blockquote>
<p><img src="https://farm1.staticflickr.com/708/21202195802_d43a68a789_b.jpg" alt=""></p>
<p><img src="https://farm6.staticflickr.com/5726/21024641578_230acfb1b9_b.jpg" alt=""></p>
<p><img src="https://farm1.staticflickr.com/601/21025733259_4c2b8c3d29_b.jpg" alt=""></p>
<p><img src="https://farm1.staticflickr.com/605/20591402633_5f424b95c4_b.jpg" alt=""></p>
<p><img src="https://farm1.staticflickr.com/731/21212515255_1d558796fc_b.jpg" alt=""></p>
<p><img src="https://farm1.staticflickr.com/734/21212504835_f929691dac_b.jpg" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/06/JVM-垃圾回收算法及垃圾回收器详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/06/JVM-垃圾回收算法及垃圾回收器详解/" itemprop="url">JVM 垃圾回收算法及垃圾回收器详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-06T11:30:32+08:00">
                2015-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Java与C++之间有一堵由内存动态分配和垃圾回收技术所围成的”高墙”，墙外的人想进去，墙里面的人想出来。<br>— 摘自《深入理解Java虚拟机》</p>
</blockquote>
<p>垃圾回收（Garbags Collection，GC），大部分人说起GC，第一反应都是想到Java吧。其实GC技术的历史比Java悠久，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾回收技术的语言。GC需要完成的3件事：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<p>之前介绍过Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈这3个区域随线程而生，随线程而亡；栈中的栈帧随着方法的进入和退出而有条不紊的执行着进栈和出栈操作。每一个栈帧中分配多少内存基本上实在类结构确定下来就已知的(尽管在运行期间JIT编译器进行一些优化，但大体上可以认为在编译期可知的。)，<strong>因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存也自然跟着回收了。</strong>而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样。我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。后续所指的<strong>内存</strong>分配和回收也仅指这一部分内存。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事就是确定哪些对象还”存活”着，哪些已经”死去”(既不可能再被任何途径使用)。</p>
<h3 id="引用计数算法-Reference-Counting"><a href="#引用计数算法-Reference-Counting" class="headerlink" title="引用计数算法(Reference Counting)"></a>引用计数算法(Reference Counting)</h3><p>原理：给对象添加一个引用计数器，每当有一个地方引用它时，计数器的值+1，当引用失效时，计数器的值-1；任何时候计数器未0的对象就是不可能再被使用的。于是引用计数算法通知GC收集器来回收它们。</p>
<p>客观地说，引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的案例，比如微软的COM技术、使用AS3的FlashPlayer、Python语言和在游戏脚本领域被广泛使用的Squirrel中都使用引用计数算法来进行内存管理。但是，主流的JVM里面没有选用引用计数算法来管理内存，其中最重要的原因就是它很难解决对象循环引用的问题。</p>
<p>一个简单的循环引用问题描述如下：有对象A和对象B，对象A中含有对象B的引用，对象B中含有对象A的引用。此时，对象A和对象B的引用计数都不为0。但是在系统中却不存在第三个对象引用了A或B，A和B是应该被回收的垃圾对象，但由于垃圾对象的相互引用，从而使得垃圾回收期无法识别，引起内存泄露。</p>
<h3 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h3><p>最基础的回收算法，后续的收集算法都是基于它的思路并对其不足进行改进而得到的。如同它的名字一样，算法分为”<strong>标记</strong>“和”<strong>清除</strong>“2个阶段。<br><strong>标记阶段</strong>：在标记阶段首先通过根节点，标记所有从根节点开始的较大对象。因此，未被标记的对象就是未被引用的对象。<br><strong>清除阶段</strong>：回收所有未被标记的对象。<br>标记-清除算法的执行过程如下图所示。<br><img src="https://farm1.staticflickr.com/564/20536042733_ac422639c3.jpg" alt="标记-清除算法的执行过程"><br>然而，它有2个不足的地方：<br>一个是效率问题，标记和清除两个过程的效率都不高；<br>二是空间问题，标记清除之后会产生大量不连续空间的内存碎片，空间碎片太多会导致以后在程序运行过程中需要分配较大对象的时候，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<h3 id="复制算法-Coping"><a href="#复制算法-Coping" class="headerlink" title="复制算法(Coping)"></a>复制算法(Coping)</h3><p>为了解决效率问题，一种称为”复制”的收集算法出现了，它将可用内存按容量分为大小相等的两块。每次只使用其中的一块。当这一块的内存用完了，就将存活的对象复制到另外一块内存上，然后再把已使用的这一块内存一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。复制算法的执行过程如图。<br><img src="https://farm6.staticflickr.com/5748/21131173196_bb466db3df.jpg" alt="复制算法示意图"><br>然而，这种算法的代价是将内存缩小未原来的一半，代价未免太高了。</p>
<p><strong>现在的商业JVM都采用这种收集算法来回收新生代</strong>。 IBM公司的专门研究表明，新生代中的对象98%是”朝生夕死”的，所以不需要按照1：1比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8：1，也就是每次新生代中可用内存空间为整个新生代容量的80%+10%，只有10%的内存会被”浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survior空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。<br><img src="https://farm1.staticflickr.com/640/20969743238_1159236a8d_b.jpg" alt=""></p>
<h3 id="标记-压缩算法-Mark-Compact"><a href="#标记-压缩算法-Mark-Compact" class="headerlink" title="标记-压缩算法(Mark-Compact)"></a>标记-压缩算法(Mark-Compact)</h3><p>复制收集算法在对象存活率较高的时候进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代不能直接选用这种算法。</p>
<p><strong>根据老年代的特点，”标记-压缩”算法出现了</strong>，标记过程依然与”标记-清除”算法一样，但后续步骤不是直接对可回收对象进行回收，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。标记-压缩算法示意图如下。<br><img src="https://farm1.staticflickr.com/754/21131661626_d9cd6219e6.jpg" alt="标记-压缩算法示意图"></p>
<h3 id="分代收集算法-Generational-Collection"><a href="#分代收集算法-Generational-Collection" class="headerlink" title="分代收集算法(Generational Collection)"></a>分代收集算法(Generational Collection)</h3><p>当前商业虚拟机的垃圾手机都采用”分代收集”算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存区域划分为几块。一般是把Java堆氛围新生代和老年代，这样 就可以根据各个年代的特点采用最适当的收集算法，在新生代中每次垃圾收集时都会有大批的对象死去，只有少量存活，所以选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象的存活率高、没有额外空间对它进行分配担保，就必须使用”标记-清理”或者”标记-压缩”算法来进行回收。</p>
<h2 id="JVM-垃圾回收器分类"><a href="#JVM-垃圾回收器分类" class="headerlink" title="JVM 垃圾回收器分类"></a>JVM 垃圾回收器分类</h2><p>如果说回收算法是内存回收的方法论，那么垃圾回收器就是内存回收的具体实现。JVM规范中对垃圾回收器应该如何实现并没有任何规定，因此不同厂商，不同版本的虚拟机所提供的垃圾回收器都可能有很大区别，并且一般都会提供参数供用户根据自己的特点和要求组合出各个年代所使用的回收器。HotSpot虚拟机所包含的所有回收器如图。（G1是在JDK1.7 Update14之后才正式商用，之前都是实验状态。）<br><img src="https://farm6.staticflickr.com/5625/21166385081_d65e779695.jpg" alt="HotSpot虚拟机的垃圾回收器"></p>
<p>上图展示的7种不同分代的回收器，如果2个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新<br>生代回收器还是老年代回收器。</p>
<p>在介绍这些收集器各自的特性前，我们需要明确一个观点：虽然我们实在对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到目前为止仍然还没有最好的回收器，更加没有万能的回收器，所以我们选择的只是具体应用场景下最合适的回收器。不然，HotSpot虚拟机就没必要实现那么多不同的回收器了。</p>
<h3 id="Serial回收器"><a href="#Serial回收器" class="headerlink" title="Serial回收器"></a>Serial回收器</h3><p>Serial回收器是最基本、发展历史最悠久的回收器。曾经(JDK1.3前)是虚拟机新生代回收的唯一选择。看名字就知道，这个回收器是一个单线程的回收器，但它的”单线程”的意义并不仅仅说明它只会使用一个CPU或者一条回收线程去完成垃圾回收的工作，更重要的是它在进行垃圾回收的过程中，必须暂停所以其他的工作县城，直到它回收结束。”Stop The World”这个名字听起来或许很酷，但这项工作实际上是有虚拟机在后台自动发起和自动完成的，在用户完全不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。Serial/Serial Old回收器的运行过程如下。<br><img src="https://farm6.staticflickr.com/5632/20977917250_56ea7e4842_z.jpg" alt="Serial/Serial Old回收器运行示意图"></p>
<p>写到这里，Serial看起来被描述成了一个”老而无用”的鸡肋了，但实际上到目前为止，它依然是虚拟机运行在Client模式下的默认新生代回收器。它也有优于其他回收器的地方：简单而高效(与其他回收器的单线程比)。</p>
<h3 id="ParNew回收器"><a href="#ParNew回收器" class="headerlink" title="ParNew回收器"></a>ParNew回收器</h3><p>ParNew回收器其实就是Serial回收器的多线程版本，除了使用多条线程进行垃圾回收之外，其他行为包括Serial回收器可用的所有控制参数(例如：-XX:SurvivorRation、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailue等)、回收算法、Stop The World、对象分配规则、回收策略等都与Serial回收器完全一样。在实现上，这2中回收器也共用了很多代码。ParNew回收器的工作流程如图。<br><img src="https://farm6.staticflickr.com/5807/21140032716_897d61ae95_z.jpg" alt="ParNew回收器的工作流程"></p>
<p>ParNew回收器除了多线程回收之外，其他与Serial回收器相比并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代回收器，其中有一个与性能无关但很重要的原因是，除了Serial回收器外，目前只有它能与CMS回收器配合工作。在JDK1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾回收器-CMS回收器(Concurrent Mark Sweep)，这款回收器是HotSpot虚拟机中第一款真正意义上的并发(Concurrent)回收器，它第一次实现了让回收器回收线程和用户线程（基本上）同时工作。</p>
<p>不幸的是，CMS作为老年代的回收器，却无法与JDK1.4中已经存在的新生代回收器Parallel Scavenge回收器配合工作(Parallel Scavenge回收器及后面提到的G1回收器都没有使用传统的GC回收器代码框架，而另外独立实现，其余几种回收器则共用了部分的框架的代码)。所以在JDK 1.5 中使用CMS来回收老年代的时候，新生代只能选择Serial或者ParNew中的一个。ParNew回收器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代回收器，也可以使用-XX:UseParNewGC选项来强制指定它。</p>
<blockquote>
<p>从ParNew回收器开始，后面还会接触到几款并发和并行的回收器，有必要先解释下这2个名词。它们都是并发编程中的概念，在讨论垃圾回收器的上下文语境中，它们可以解释如下：</p>
<ul>
<li>并行（Parallel）：指多条垃圾回收线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li>并发（Concurrent）：指用户线程和垃圾回收线程同时执行（但不一定是并行，可能会交替进行），用户程序继续运行，而垃圾回收程序运行在另一个CPU上。</li>
</ul>
</blockquote>
<h3 id="Parallel-Scavenge回收器"><a href="#Parallel-Scavenge回收器" class="headerlink" title="Parallel Scavenge回收器"></a>Parallel Scavenge回收器</h3><p>PS回收器是一个新生代回收器，它也是使用复制算法的回收器，又是并行的多线程回收器….看上去和PerNew回收器都一样，那它们有什么不同之处呢？</p>
<p>PS回收器的特点是它的关注点和其他回收器不同，CMS等回收器的关注点是尽可能缩短垃圾回收时用户线程的等待时间，而PS回收器的目标则是达到一个可控制的吞吐量（Throughput）（=运行用户/(用户线程时间+垃圾回收时间)）。</p>
<p><strong>停顿时间越短就越适合需要与用户交互的程序，良好的响应时间能提升用户体验，而高吞吐量则可以高效率利用cpu时间，尽快完成程序的运算任务，主要适合在后台运行而不需要太多交互的任务。</strong></p>
<p>PS回收器提供了2个参数用于精确控制吞吐量，分别是控制最大垃圾回收停顿时间的-XX:MaxGCPauseMillis以及设置吞吐量大小的-XX:GCTimeRatio参数。MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，回收器将尽可能保证内存回收花费的时间不超过设定值。GCTimeRatio参数的值是一个大于0且小于100的数，也就是垃圾回收时间占总时间的比率，相当于吞吐率的倒数，默认值是99，就是允许最大1%（即1/(1+99)）的垃圾回收时间。</p>
<p>由于PS回收器与吞吐量关系密切，因此也被称为”吞吐量优先”的回收器。除上述2个参数外，PS回收器还有一个参数：-XX:UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开以后，就不需要手动指定新生代的大小-Xmn、Eden与Survivor的比例-XX:SurvivorRadio、晋升老年代对象年龄-XX:PretenureSizeThreshold等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量。这种调节方式成为GC自适应的调节策略(GC Ergonmics)。<strong>自适应调节也是PS回收器与PerNew回收器的一个重要区别</strong>。</p>
<h3 id="Serial-Old-回收器"><a href="#Serial-Old-回收器" class="headerlink" title="Serial Old 回收器"></a>Serial Old 回收器</h3><p>Serial Old是Serial的回收器的老年代版本，同样是一个单线程回收器，使用”标记-压缩”算法。</p>
<p>这个回收器的主要意义也是在给Client模式下的虚拟机使用。如果在Server模式下，主要有2大用途：一是在JDK 1.5 以及之前的版本中与PS回收器配合使用；二是作为CMS回收器的后备方案，在并发回收发生Concurrent Mode Failure时使用。Serial Old的工作过程如图。<br><img src="https://farm6.staticflickr.com/5671/21167620535_5fed69f189_z.jpg" alt=""></p>
<h3 id="Parallel-Old回收器"><a href="#Parallel-Old回收器" class="headerlink" title="Parallel Old回收器"></a>Parallel Old回收器</h3><p>PO回收器是PS回收器的老年代版本，使用”标记-压缩”算法。这个回收器是在jdk 1.6 才开始提供的，在此之前，新生代的PS回收器一直处于比较尴尬的地位。原因是，如果新生代选择了PS回收器，老年代除了Serial Old回收器外别无选择。由于老年代Serial Old回收器在服务器应用性能上的”拖累”，使用了PS回收器也未必能在整体上获得吞吐量最大化的效果。</p>
<p>直到PO回收器的出现，“吞吐量优先”回收器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑PS+PO回收器。PO回收器的工作流程如下图。<br><img src="https://farm1.staticflickr.com/609/20546629683_ff7aecbffa_z.jpg" alt=""></p>
<h3 id="CMS-回收器"><a href="#CMS-回收器" class="headerlink" title="CMS 回收器"></a>CMS 回收器</h3><p><strong>CMS（Concurrent Mark Sweep）回收器是一种以获取最短停顿时间为目标的回收器。</strong> 目前很大一部分的Java应用集中在互联网或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统的停顿时间最短，以给用户较好的体验。CMS回收器就非常符合这类应用的需求。</p>
<p>从名字就可以看出，CMS回收器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种回收器来说更复杂些。整个过程分为4个步骤，包括：</p>
<blockquote>
<ul>
<li>初始标记CMS initial mark</li>
<li>并发标记CMS concurrent mark</li>
<li>重新标记CMS remark</li>
<li>并发清除CMS concurrent sweep</li>
</ul>
</blockquote>
<p>其中初始标记和重新标记都需要“stop the world”。初始标记仅仅只是标记一下GC Roots能关联到的对象，速度很快；并发标记阶段就是进行GC Roots Tracing的过程；而重新标记则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿会比初始标记稍长，但远比并发标记的时间短。</p>
<p>由于整个过程中耗时最长的并发标记和并发清除都可以和用户进程一齐工作，所以总体来说，CMS回收器的内存回收工作是与用户线程一齐并发执行的。由下图可以清楚地看到CMS回收器的运作步骤中并发和需要停顿的时间。<br><img src="https://farm1.staticflickr.com/732/20980112470_79e722bf06_z.jpg" alt=""></p>
<p>3个明显的缺点：</p>
<blockquote>
<ol>
<li>CMS回收器对CPU资源非常敏感。</li>
<li>CMS回收器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC出现。</li>
<li>基于“标记-清除”算法带来的内存碎片。</li>
</ol>
</blockquote>
<h3 id="G1-回收器"><a href="#G1-回收器" class="headerlink" title="G1 回收器"></a>G1 回收器</h3><p>G1（Garbage-First）是一款面向服务端应用的垃圾回收器，在JDK 1.7的HotSpot虚拟机中正式商用。HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK1.5中发布的CMS垃圾回收器。与其他GC回收器相比，G1具备如下特点：</p>
<blockquote>
<ul>
<li><strong>并行与并发</strong>：G1能充分利用多CPU、多核环境下的硬件优势，以此来缩短Stop-The-World停顿时间，部分回收器原本需要停顿Java线程执行的GC操作，G1可以通过并发的方式让Java程序继续运行。</li>
<li><strong>分代回收</strong>：与其他回收器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他回收器就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活一段时间、熬过多次GC的旧对象以取得更好的收集效果。</li>
<li><strong>空间整合</strong>：与CMS回收器的标记-清理算法不同，G1从整体上看是基于标记-压缩算法实现的回收器，从局部（两个Region之间）上看是基于复制算法实现的，但无论如何，这两种算法都意味着G1运行期间不会产生内存空间碎片，回收后能提供完整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</li>
<li><strong>可预测的停顿</strong>：这个G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿之外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度未M毫秒的时间片段内，消耗在垃圾回收上的时间不得超过N毫秒，这几乎是实时Java（RTSJ）的垃圾回收器的特征了。</li>
</ul>
</blockquote>
<p>在G1之前的其他回收器进行回收的范围都是整个新生代或者老年代，而G1不再是这样。使用G1回收器时，Java堆的内存布局就与其他回收器有很大区别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p>
<p>G1回收器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾回收。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的回收时间，优先回收价值大的Region（这也就是Garbage-First名称的由来）。这种使用Region划分内存以及有优先级的区域回收方式，保证了G1回收器在有限的时间内可以获取尽可能高的收集效率。</p>
<p>在G1回收器中，Region之间的对象引用以及其他回收器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查老年代中的对象引用了新生代的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>
<p>如果不计算维护Remembered Set的操作，G1回收器的运作大致可划分为一下几个步骤：</p>
<blockquote>
<ul>
<li>初始标记 Initial Marking</li>
<li>并发标记 Concurrent Marking</li>
<li>最终标记 Final Marking</li>
<li>筛选回收 Live Date Counting and Evacuation</li>
</ul>
</blockquote>
<p>我们可以发现，G1的前几个步骤的运作过程和CMS有很多相似之处。初始标记阶段只是标记一下GC Roots能直接关联到的对象，并且修改TAMS(Next Top at Mark Start)的值，让下阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。并发标记阶段是从GC Roots开始对堆中对象进行可达性分析，找出存活对象，这阶段耗时长，但可以与用户程序并发执行。最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动那一部分标记记录，虚拟机将这段时间对象变化记录到线程Remembered Set Logs中。然后需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿操作，但是可以并发执行。最后在筛选阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来指定回收计划，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高效率。G1回收器的运作步骤中并发和需要的停顿的阶段如图：<br><img src="https://farm6.staticflickr.com/5628/20555231414_d0254702f9_z.jpg" alt=""></p>
<h2 id="垃圾回收的时机"><a href="#垃圾回收的时机" class="headerlink" title="垃圾回收的时机"></a>垃圾回收的时机</h2><p>通过上面的学习，我们已经堆垃圾回收机制有了一个比较全面的了解。下面堆垃圾回收的时机总结一下。</p>
<ul>
<li>对象优先分配在Eden区，当Eden区没有足够的空间时，虚拟机将发生一次<strong>Minor GC</strong>。因为大部分在Eden区的对象都是“朝生夕亡”，所以Minor GC执行非常频繁，而且速度也很快。</li>
<li>当老年代没有足够的空间时及时发生<strong>Full GC</strong>，发生Full GC的时候一般都会有一次Minor GC。大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个<strong>-XX:PretenureSizeThreadhold</strong>来使得大于这个参数值的对象直接在老年代中分配内存，避免在Eden区和Survivor区发生大量的内存拷贝。</li>
<li>发生Minor GC的时候，虚拟机会检测之前每次晋升到老年代的平均大小是否大于当前老年代的剩余大小，如果大于，说明老年代可能不够空间，所以会先执行一次Full GC；如果小于，则查看<strong>HandlePromotionFailure</strong>是否允许担保失败，如果允许则只进行Minor GC，如果不允许，则改为进行一次Full GC。</li>
</ul>
<h2 id="垃圾回收器参数总结"><a href="#垃圾回收器参数总结" class="headerlink" title="垃圾回收器参数总结"></a>垃圾回收器参数总结</h2><p><img src="https://farm6.staticflickr.com/5625/21166385081_d65e779695.jpg" alt="HotSpot虚拟机的垃圾回收器"></p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">UseSerialGC</td>
<td style="text-align:left">虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的回收器组合进行内存回收。</td>
</tr>
<tr>
<td style="text-align:left">UseParNewGC</td>
<td style="text-align:left">打开此开关后，使用ParNew+CMS+Serial Old的回收器组合进行内存回收。</td>
</tr>
<tr>
<td style="text-align:left">UseConcMarkSweepGC</td>
<td style="text-align:left">打开此开关后，使用ParNew+CMS+Serial Old组合进行内存回收。Serial Old 讲作为CMS出现Concurrent Mode Failure失败后的后备回收器。</td>
</tr>
<tr>
<td style="text-align:left">UseParallelGC</td>
<td style="text-align:left">虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge+Serial Old组合。</td>
</tr>
<tr>
<td style="text-align:left">UseParallelOldGC</td>
<td style="text-align:left">打开此开关，使用Parallel Scavenge+Parallel Old组合。</td>
</tr>
<tr>
<td style="text-align:left">SurvivorRation</td>
<td style="text-align:left">新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden：Survivor=8：1。</td>
</tr>
<tr>
<td style="text-align:left">PretenureSizeThreshold</td>
<td style="text-align:left">直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配。</td>
</tr>
<tr>
<td style="text-align:left">MaxTenuringThreshold</td>
<td style="text-align:left">直接晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就+1，当超过这个参数值就进入老年代。</td>
</tr>
<tr>
<td style="text-align:left">UseAdaptiveSizePolicy</td>
<td style="text-align:left">动态调整Java堆中各个区域的大小以及进入老年代的年龄。</td>
</tr>
<tr>
<td style="text-align:left">HandlePromotionFailure</td>
<td style="text-align:left">是否允许分配担保失败，即老年代的剩余空间不足以应对新生代的整个Eden和Survivor区的所有对象都存活的极端情况。</td>
</tr>
<tr>
<td style="text-align:left">ParallelGCThreads</td>
<td style="text-align:left">设置并行GC时进行内存回收的线程数。</td>
</tr>
<tr>
<td style="text-align:left">GCTimeRatio</td>
<td style="text-align:left">GC时间占总时间的比率，默认值是99，即允许1%的GC时间。仅在使用Parallel Scavenge回收器生效。</td>
</tr>
<tr>
<td style="text-align:left">MaxGCPauseMillis</td>
<td style="text-align:left">设置GC的最大停顿时间。仅在使用Parallel Scavenge回收器时生效。</td>
</tr>
<tr>
<td style="text-align:left">CMSInitiatingOccupancyFraction</td>
<td style="text-align:left">设置CMS回收器在老年代空间被使用多少后触发GC。默认值为68%，仅在使用CMS回收器生效。</td>
</tr>
<tr>
<td style="text-align:left">UseCMSCompactAtFullCollection</td>
<td style="text-align:left">设置CMS回收器在完成GC后是否要进行一次内存碎片整理。仅在使用CMS生效。</td>
</tr>
<tr>
<td style="text-align:left">CMSFullGCBeforeCompaction</td>
<td style="text-align:left">设置CMS回收器在进行若干次GC后再启动一次内存碎片整理。仅在使用CMS生效。</td>
</tr>
</tbody>
</table>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="">深入理解Java虚拟机 第二版 周志明著</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/" target="_blank" rel="external">JVM 垃圾回收器工作原理及使用实例介绍</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/31/Java发展历程-图文版/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/31/Java发展历程-图文版/" itemprop="url">Java发展历程(图文版)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-31T10:43:25+08:00">
                2015-08-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://farm6.staticflickr.com/5688/20398542974_320e0e569a_o.jpg" alt="Java发展历程"></p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://blog.b13technology.com/2015/08/19/java-history/" target="_blank" rel="external">The History of the Java Programming Language (Infographic)</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/28/Java-内存模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/28/Java-内存模型/" itemprop="url">Java 内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-28T17:10:59+08:00">
                2015-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java虚拟机规范中试图定义一种Java内存模型（Java Memony Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。经过长时间的验证和修补，在JDK1.5（实现了JSR-133）发布后，Java内存模型已经成熟和完善起来。</p>
<h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><p>Java内存模型规定了所有的变量都存储在主内存（Main Memony）中。每条线程还有自己的工作内存（Working Memony），线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在（读取、赋值等）工作内存中进行，而不能直接读写主内存的变量（volatile变量也一样）。不同线程之间也无法访问对方工作内存中的变量，线程间变量值的传递主要是通过主内存来完成。线程、主内存、工作内存交互图如下。<br><img src="https://farm6.staticflickr.com/5699/20944071295_03d6a1e5e7.jpg" alt=""></p>
<p>这里所说的主内存、工作内存与之前<a href="http://www.baidu.com" target="_blank" rel="external">JVM 内存区域</a>所说的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的。如果要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈的部分区域。从更低层次来说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。</p>
<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>关于主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了8中操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外）。</p>
<ul>
<li><p>lock（锁定）：</p>
<blockquote>
<p>作用于主内存的变量，把一个变量标志为一条线程独占的状态。</p>
</blockquote>
</li>
<li><p>unlock（解锁）：</p>
<blockquote>
<p>作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>
</blockquote>
</li>
<li><p>read（读取）：</p>
<blockquote>
<p>作用于主内存的变量，把一个变量的值从主内存中传输到线程的工作内存中，以便随后的load动作使用。</p>
</blockquote>
</li>
<li><p>load（载入）：</p>
<blockquote>
<p>作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p>
</blockquote>
</li>
<li><p>use（使用）：</p>
<blockquote>
<p>作用于工作内存的变量，把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码时将会执行这个操作。</p>
</blockquote>
</li>
<li><p>assign（赋值）：</p>
<blockquote>
<p>作用于工作内存的变量，把一个从执行引擎接受到的值赋值给工作内存中变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p>
</blockquote>
</li>
<li><p>store（存储）：</p>
<blockquote>
<p>作用于工作内存的变量，把工作内存中的一个变量传送到主内存中，以便随后的write操作使用。</p>
</blockquote>
</li>
<li><p>write（写入）：</p>
<blockquote>
<p>作用于主内存的变量，把store操作从工作内存中的得到的变量的值放入主内存的变量中。</p>
</blockquote>
</li>
</ul>
<p>如果要把一个变量从主内存拷贝到工作内存中，那就要顺序地执行read和load操作，如果要把工作内存中的变量同步回主内存，就要顺序的执行store和write操作。注意，Java内存模型只要求上述2个操作必须顺序执行，而没有保证是连续执行。也就是说，read和load之间、store和write之间是可以插入其他指令的。除此之外，Java内存模型还规定了在执行上述8中基本操作时必须满足如下规则：<br><img src="https://farm1.staticflickr.com/765/20322329054_33e1c41474.jpg" alt=""></p>
<ul>
<li>不允许read和load、store和write操作之一单独出现。即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起了回写但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它最近的assign操作。即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存回写到主内存中。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。换句话说，就是对一个变量执行use、store操作之前，必须执行过了assign和load操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>如果对一个变量lock操作，那么会清空工作内存中此变量的值，在执行引擎使用这个变量的时候，必须重新load或assign来初始化该变量。</li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它进行unlock，也不允许unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock之前，必须先把变量同步回主内存（执行store、write）。</li>
</ul>
<h2 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h2><p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是并不容易理解。</p>
<p>当一个变量定义为volatile时，它将具备2种特性：<strong>第一是保证此变量对所有线程的可见性</strong>，这里的可见性是指一条线程修改了这个变量的值，新值对于其他线程来说是立即得知的。而普通变量做不到这点，普通变量的值在线程间传递需要通过主内存来完成。“volatile变量对所有线程是立即可见的，对volatile变量的所有写操作都能立刻反应到其他线程中，换句话说，volatile变量在各个线程中是一致的，但是基于volatile变量的运算在并发下却不一定安全”。<br>由于volatile变量只保证可见性，在不符合一下2条规则的运算场景中，我们仍然要通过加锁（synchronized或JUC中的原子类）来保证原子性。</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能确保只有单一的线程改变变量的值；</li>
<li>变量不需要与其他状态变量共同参与不变约束；</li>
<li>在访问变量时不需要加锁;        </li>
</ul>
<p><strong>第二是禁止指令重排序</strong>。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到指点，这就是Java内存模型描述的所谓的“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）</p>
<h2 id="对于long和double型变量的特殊规则"><a href="#对于long和double型变量的特殊规则" class="headerlink" title="对于long和double型变量的特殊规则"></a>对于long和double型变量的特殊规则</h2><p>JMM要求lock、unlock等8个操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机讲没有被volatile修饰的64位数据的读写规则划分为2次32位的操作来进行，即允许虚拟机实现选择不保证64位数据类型的laod、store、read、write这4个操作的原子性，这点就是所谓的long和double的<em>非原子协定</em>。</p>
<p>如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对他们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。</p>
<p>不过这种读取到“半个变量”的情况非常罕见（在目前商用Java虚拟机中不会楚翔），因为JMM虽然允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样做。在实际开发中，目前各平台下商用虚拟机几乎都选择把64位数据类型的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的long和double声明为volatile。</p>
<h2 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h2><p>JMM是围绕在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。我们逐一看下这3个特性。</p>
<h3 id="原子性（Atomicity）："><a href="#原子性（Atomicity）：" class="headerlink" title="原子性（Atomicity）："></a>原子性（Atomicity）：</h3><p>有JMM来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据的访问读写是具有原子性的。</p>
<p>如果应用场景需要一个更大范围的原子性保证（经常遇到），JMM还提供了lock和unlock操作来满足这种需求，尽管虚拟机还没有把lock和unlock操作直接开发给开发者使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式使用者2个操作，这2个字节码指令反应到Java代码中就是同步块-synchronized关键字，因此在synchronized块之间的操作也具备原子性。</p>
<h3 id="可见性（Visibility）："><a href="#可见性（Visibility）：" class="headerlink" title="可见性（Visibility）："></a>可见性（Visibility）：</h3><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。volatile变量能够保证新值能立即同步到主内存中，以及每次使用前立即从主内存刷新。因此可以说volatile保证了多线程操作时变量的可见性。</p>
<p>除了volatile之外，Java还有2个关键字能够实现可见性，即synchronized和final。同步块的可见性是由“对一个变量执行unlock之前，必须先把此变量同步回主内存中”这条规则获得的。而final关键字可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见final字段的值。</p>
<h3 id="有序性（Ordering）："><a href="#有序性（Ordering）：" class="headerlink" title="有序性（Ordering）："></a>有序性（Ordering）：</h3><p>Java程序中天然的有序性可以归结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行化的语义”，后半句是指“指令重排序”现象和“工作内存和主内存同步延迟”现象。</p>
<p>Java语言提供了volatile和synchronized来保证线程之间操作的有序性，volatile本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的2个同步块只能串行的进入。</p>
<p>呵呵，synchronized真是万能啊，所有3个特性都能由它来保证。的确，大部分并发控制操作都能使用synchronized来完成，也就间接造成了滥用，越“万能”的并发控制，也伴随了越大的性能影响。</p>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>如果JMM中所有的有序性都仅仅靠volatile和synchronized来完成，那么有一些操作将会变得很繁琐，但是我们在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发生”（happens-before）原则。这个原则非常重要，他是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个规则，我们可以通过几条规则一揽子解决并发环境下2个操作之间是否可能存在冲突的素有问题。</p>
<p>下面是JMM下一些“天然的”先行发生关系，这些先行发生关系无需任何同步器协助就已经存在，可以在编码中直接使用。如果2个操作之间的关系不在此列，并且无法从下列规则推到出来，他们的顺序就没有顺序性的保障，虚拟机可以对他们随意地进行重排序。</p>
<ul>
<li><p>程序次序规则（Program Order Rule）：</p>
<blockquote>
<p>在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。 </p>
</blockquote>
</li>
<li><p>管程锁定规则（Monitor Lock Rule）：</p>
<blockquote>
<p>一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”同样指的是时间上的先后顺序。</p>
</blockquote>
</li>
<li><p>volatile变量规则（Volatile Variable Rule）：</p>
<blockquote>
<p>对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的后面同时指的是时间上得先后顺序。</p>
</blockquote>
</li>
<li><p>线程启动规则（Thread Start Rule）：</p>
<blockquote>
<p>Thread对象的start()方法先行发生于此线程的每一个动作。</p>
</blockquote>
</li>
<li><p>线程终止规则（Thread Termination Rule）：</p>
<blockquote>
<p>线程中所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行了。</p>
</blockquote>
</li>
<li><p>线程中断规则（Thread Interruption Rule）：</p>
<blockquote>
<p>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</p>
</blockquote>
</li>
<li><p>对象终结规则（Finallizer Rule）：</p>
<blockquote>
<p>一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</p>
</blockquote>
</li>
<li><p>传递性（Transitivity）：</p>
<blockquote>
<p>如果操作A先行发生于操作B，操作B先行发生于操作C，那么可以推断出操作A先行发生于操作C的结论。</p>
</blockquote>
</li>
</ul>
<p>以上。</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li>《深入理解Java虚拟机-JVM高级特性与最佳实践》第二版 周志明著</li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/28/JVM-内存区域/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/28/JVM-内存区域/" itemprop="url">JVM 内存区域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-28T14:07:24+08:00">
                2015-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于Java来说，在JVM自动内存管理机制的帮助下，不再需要为每一个new操作去手动管理内存空间，不容易出现内存泄露和内存溢出的问题，由JVM管理内存这一切看上去很美好，不过也正是因为Java把内存控制的权利交给了JVM，一旦出现内存泄露和溢出方面的问题，如果不了解JVM是如何使用内存的，那么排查错误将会成为一个异常艰难的工作。所以了解JVM内存区域是非常有用且必要的。</p>
<hr>
<p>JVM在执行Java程序的过程中会把它管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，各自的生命周期，有的区域岁JVM进程的启动而存在，有些区域则依赖用户线程的启动和结束而创建和销毁。根据《Java虚拟机规范(Java SE 7版)》的规定，JVM所管理的内存将会包括以下几个运行时区域，如下图所示。<br><img src="https://farm6.staticflickr.com/5706/20779779755_12f06f3ddd.jpg" alt=""></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是<code>当前线程所执行字节码的行号指示器</code>。由于JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。在任何一个时刻，一个处理器（对多核来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的PC，各条线程之间的PC互不影响，独立存储，这种类型的内存区域也成为<code>线程私有</code>的内存，线程间不可见。</p>
<p>另外，如果线程正在执行的是一个Java方法，这个PC记录的是正在执行的JVM字节码指令的地址；如果正在执行的是Native方法，那么这个PC则置空(Undefined)。此内存区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p><img src="https://farm6.staticflickr.com/5759/20756845859_470b1c3d2f.jpg" alt=""><br>与PC一样，JVM栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个帧栈(Stack Frame)，<code>用于存储局部变量表、操作数栈、动态链接、方法出口等信息</code>。每一个方法从调用到执行完成的过程，对应着一个帧栈在虚拟机栈中进栈到出栈的过程。</p>
<p>网上有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种划分方式比较简单，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大部分程序员最关注的、与对象内存分配关系最密切的内存区是这2块。其中所指的“堆”会在后面解释，而所指的“栈”就是现在所说的虚拟机栈，或者说是虚拟机栈中局部变量的部分。</p>
<p>局部变量表存放了编译器可知的各种基本数据类型（byte、short、int、long、float、double、boolean、char）、对象引用（Reference类型，它不等同于对象本身，可能是一个对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向一条指令码指令的地址）。</p>
<p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot）（在多线程环境中，long和double是比较特殊的，很多操作或许会跟其他基本类型不一样，可能会引起额外的问题，这里先提及一下），其余的数据类型只占用1个Slot。<code>局部变量表所需的空间在编译期间完成分配</code>，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>在Java虚拟机规范中，对这个区域规定了2中异常状况：如果线程请求的栈深度大于虚拟机允许的深度，将会抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前的大部分的Java虚拟机都可以动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈（Native Method Stack）与虚拟机所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机过管理的内存中最大的一块。<code>Java堆是被所有线程共享的一块内存区域，在JVM启动时创建。
此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存</code>。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配内存(The heap is the runtime data area from which memory for all class instances and arrays is allocated)。但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在对上也逐渐变得不是那么“绝对”了。</p>
<p>Java堆是GC管理的主要区域，因此很多时候也被称作“GC堆”。从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步的划分的目的是为了更好地回收内存，或者更快地分配内存。</p>
<p>根据JLS的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的。不过当前主流的JVM都是按照可扩展来实现的(通过-Xmx和-Xms控制)。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被JVM加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。虽然JVM规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Head（非堆），目的应该是与Java堆区分开来。</p>
<p>对于习惯在HotSpot JVM上开发、部署程序的开发者来说，很多人愿意把方法区成为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot JVM的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。对于其他JVM如BEA JRockit、IBM J9等，是不存在永久代的概念的。原则上，如何实现方法区属于虚拟机实现细节，不受虚拟机规范约束，但使用永久代来实现方法区，现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题（永久代有-XX:MaxPermSize的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4G，就不会出现问题），而且有极少数方法（例如String.intern()）会因为这个原因导致不同虚拟机下有不同的表现。因此，对于HotSpot虚拟机，根据官方发布的路线图信息，现在也有放弃永久代并逐步改为Native Memory来实现方法区的规划了，在目前已经发布的JDK1.7的Hot Spot中，已经把原本放在永久代中的字符串常量池异常。而在目前最新的JDK1.8的Hot Spot，已经移除了永久代了。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p>Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中的描述的符号引用外，还会把翻译出来的直接引用也存储到运行时常量池中。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有在编译器才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多得便是String类的intern()方法。</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时便会抛出OutOfMemoryError异常。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以说明下。</p>
<p>在JDK1.4中新加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用来进行操作。这样能在一些场合显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<p>显然，本机直接分配内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是受到本机总内存（包括RAM和SWAP区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li>《深入理解Java虚拟机-JVM高级特性与最佳实践》第二版 周志明著</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/25/Linux&Mac常用命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/25/Linux&Mac常用命令/" itemprop="url">Linxu&Mac 常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-25T00:22:40+08:00">
                2015-08-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="文件-文件夹-磁盘管理"><a href="#文件-文件夹-磁盘管理" class="headerlink" title="文件/文件夹/磁盘管理"></a>文件/文件夹/磁盘管理</h2><ul>
<li>由第一行开始显示档案内容(n为显示行号)：<code>cat [-n] &lt;file-name&gt;</code></li>
<li>从最后一行开始显示(Mac无)：<code>tac &lt;file-name&gt;</code> </li>
<li>查看头几行：<code>head [-lineNumber] &lt;file-name&gt;</code></li>
<li>查看尾几行：<code>tail [-lineNumber] &lt;file-name&gt;</code> </li>
<li>以二进制的方式读取档案内容：<code>od &lt;file-name&gt;</code></li>
<li>分页显示文件(space下一页，b上一页)：<code>more &lt;file-name&gt;</code></li>
<li>分页显示文件(支持PageDown和PageUp)：<code>less &lt;file-name&gt;</code></li>
<li>创建软链接(inode不一样): <code>ln -s &lt;from-file-with-absolute-path&gt; &lt;soft-link-file-with-absolute-path&gt;</code></li>
<li>创建硬链接(inode一样): <code>ln &lt;from-file-with-absolute-path&gt; &lt;hard-link-file-with-absolute-path&gt;</code></li>
<li>查看文件的inode信息: <code>stat &lt;file&gt;</code></li>
<li>查看硬盘分区的inode总数和已经使用的数量: <code>df -i</code></li>
<li>查看每个inode节点的大小: <code>sudo dumpe2fs -h /dev/hda | grep &quot;Inode size&quot;</code></li>
<li>查看文件的inode号码: <code>ls -i &lt;file&gt;</code></li>
<li>查看当前文件夹磁盘占用情况：<code>du -shc *</code></li>
<li>查看磁盘使用情况：<code>df -lh</code></li>
<li>查看inode使用情况： <code>df -hi</code></li>
<li>找某个文件并打印内容：<code>find . -name &quot;&lt;file-name&gt;&quot; -exec cat {} \;</code></li>
<li>在当前目录下查找某个字符串并打印行号：<code>find ./* | xargs grep -n &#39;&lt;string-you-find&gt;&#39;</code></li>
</ul>
<hr>
<h2 id="压缩文件管理"><a href="#压缩文件管理" class="headerlink" title="压缩文件管理"></a>压缩文件管理</h2><ul>
<li>创建tar文件：<br><code>tar -cvf &lt;archive-name.tar&gt; &lt;file1-OR-file2-OR-both-to-archive&gt;</code></li>
<li>查看tar文件：<code>tar -tvf &lt;archive-to-view.tar&gt;</code></li>
<li>提取tar文件：<code>tar -xvf &lt;archive-to-extract.tar&gt;</code></li>
<li>创建和提取gzip压缩文件：<code>gzip &lt;filename&gt;</code></li>
<li>对gzip文档进行解压：<code>unzip &lt;archive-to-extract.zip&gt;</code></li>
<li>查看gzip文件：<code>unzip -l &lt;archive-to-extract.zip&gt;</code></li>
</ul>
<hr>
<h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><ul>
<li>启动crond服务：<code>service crond start</code></li>
<li>停止crond服务：<code>service crond stop</code></li>
<li>重启crond服务：<code>service crond restart</code></li>
<li>为某个使用者建立/移除crontab任务： <code>crontab -u username</code></li>
<li>编辑crontab任务内容：<code>crontab -e</code></li>
<li>查看crontab任务内容：<code>crontab -l</code></li>
<li>移除crontab所有任务：<code>crontab -r</code></li>
<li>crontab内容格式：<ul>
<li><code>* * * * *    path</code></li>
<li>前面5个 <code>*</code> 代表：分(0-59)、时(0-23)、日(1-31)、月(1-12)、周(0-7)</li>
<li><code>*</code> 号代表任何时间都能接受的意思，任意；</li>
<li>如果是一段时间，用<code>-</code>连接</li>
<li>如果是隔开几个时间，用<code>,</code>连接</li>
<li>如果是某个时间单位每隔多久，用<code>/&lt;interval&gt;</code>连接</li>
</ul>
</li>
<li>例如：<br><code>* */12 * * * /Users/Archerda/Configuration/Script/CodingBit/coding.sh</code><br>代表每隔12个小时执行一次coding.sh</li>
<li>Mac下的cron日志会在<code>/var/mail/&lt;username&gt;</code>中记录，可以用cat查看。每次cron任务有标准输出时都会记录在该文件中，并且在终端会提醒<code>You have new mail in /var/mail/&lt;username&gt;</code></li>
</ul>
<hr>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><ul>
<li>列出当前用户名：<code>who</code></li>
<li>查看用户登录状态：<code>w</code></li>
<li>快速查找某用户信息：<code>finger &lt;user-name&gt;</code></li>
<li>切换用户(switch user)：<code>su &lt;user-name&gt;</code></li>
<li>修改用户密码：<code>passwd</code></li>
<li>查看UID等：<code>id &lt;user-name&gt;</code></li>
</ul>
<hr>
<h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><ul>
<li>显示系统内核版本：<code>uname</code></li>
<li>显示系统所有信息：<code>uname -a</code></li>
<li>显示发行版信息： <code>cat /etc/issue</code></li>
</ul>
<hr>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><ul>
<li>查看系统资源使用情况并排序：<code>top</code></li>
<li>可视化查看系统资源使用情况：<code>sudo htop</code> </li>
<li>使用homebrew安装htop：<code>brew intall htop</code></li>
<li>列出活跃进程：<code>ps</code></li>
<li>列出所有系统运行命令并分页：<code>ps -A | less</code></li>
<li>列出指定进程名的进程(BSD格式输出：USER , PID , %CPU , %MEM , VSZ , RSS , TTY , STAT , START , TIME , COMMAND)：<code>ps aux | grep &lt;pname&gt; --color=auto</code></li>
<li>列出指定进程名的进程(标准格式输出：UID , PID , PPID , C , STIME , TTY , TIME , CMD)：<code>ps -ef | grep &lt;pname&gt; --color=auto</code></li>
<li>根据ID杀死进程：<code>kill &lt;pid&gt;</code></li>
<li>根据关键字查询PID：<code>pgrep -f &lt;key-word&gt;</code></li>
<li>根据进程名称杀死一个进程：<code>pkill &lt;name&gt;</code> <code>killall &lt;name&gt;</code></li>
<li>杀死图形界面程序(Mac默认没有这个工具)：<code>xkill</code></li>
<li>改变线程nice值(优先级，-19最高，19最低，0默认)：<code>renice &lt;nice-value&gt; &lt;pid&gt;</code></li>
<li>在后台不挂断地运行命令(日志默认写在当前目录的nohup.out)：<code>nohup &lt;command&gt; &lt;arg&gt; [&gt; &lt;filename&gt; 2&gt;&amp;1] &amp;</code></li>
<li>建立一个处于断开模式下的会话：<code>screen -dmS &lt;session-name&gt;</code></li>
<li>列出所有会话：<code>screen -list</code></li>
<li>重新连接会话：<code>screen -r &lt;session-name&gt;</code></li>
<li>跟踪进程执行时的系统调用和所接收的信号 (在调试的时候一般是从后往前看strace命令的结果，这样更容易找到有价值的信息): <code>strace &lt;command&gt;</code></li>
</ul>
<hr>
<h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><ul>
<li>查看文件的MD5(Mac)：<code>md5 &lt;file-name&gt;</code></li>
<li>查看文件的SHA1(Mac): <code>shasum -a 1 &lt;file-name&gt;</code></li>
<li>查看文件的SHA256(Mac): <code>shasum -a 256 &lt;file-name&gt;</code></li>
<li>查看文件的MD5(Linux)：<code>md5sum &lt;file-name&gt;</code></li>
<li>查看文件的SHA：<code>shasum &lt;file-name&gt;</code></li>
<li>查看文件的SHA1：<code>sha1sum &lt;file-name&gt;</code></li>
<li>生成RSA的SSH： <code>ssh-keygen -t rsa</code></li>
</ul>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><ul>
<li>输出重定向到剪贴板(Mac): <code>&lt;command&gt; | pbcopy</code></li>
</ul>
<hr>
<h2 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h2><ul>
<li>ssh登录：<code>ssh [-p &lt;port&gt;] &lt;user&gt;@&lt;host&gt;&#39;</code></li>
<li>ssh免密码登录(公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾)：<code>ssh &lt;user&gt;@&lt;host&gt; &#39;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code></li>
<li>ssh禁用密码登录并启用ssh密钥登录：<code>vim /etc/ssh/sshd_config</code> <code>PubkeyAuthentication yes;AuthorizedKeysFile .ssh/authorized_keys;PasswordAuthentication no</code> <code>service sshd restart</code></li>
</ul>
<hr>
<h2 id="CPU管理"><a href="#CPU管理" class="headerlink" title="CPU管理"></a>CPU管理</h2><ul>
<li>显示CPU信息：<code>cat /proc/cpuinfo</code></li>
<li>显示CPU信息：<code>lscpu</code></li>
<li>显示CPU占用最多的前10个进程：<code>ps auxw|head -1;ps auxw|sort -rn -k3|head -10</code></li>
</ul>
<hr>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ul>
<li>显示内存信息：<code>free -m</code> </li>
<li>显示内存信息：<code>cat /proc/meminfo</code></li>
<li>显示内存消耗最多的前10个进程：<code>ps auxw|head -1;ps auxw|sort -rn -k4|head -10</code></li>
<li>显示虚拟内存使用最多的前10个进程：<code>ps auxw|head -1;ps auxw|sort -rn -k5|head -10</code></li>
<li>释放buffer和cache: <code>echo 3 &gt; /proc/sys/vm/drop_caches</code></li>
<li>每隔一秒高亮显示内存变化情况: <code>watch -n 1 -d &quot;free&quot;</code></li>
</ul>
<hr>
<h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><ul>
<li>查看已用端口：<code>netstat -pltn</code></li>
<li>查看某个端口被哪个进程占用: <code>lsof -i:&lt;port&gt;</code></li>
<li>显示机器所属域名: <code>hostname -d</code></li>
<li>显示完整的主机名和域名: <code>hostname –f</code></li>
<li>显示当前机器的ip地址: <code>hostname –i</code></li>
<li>互动式地查询域名记录: <code>nslookup</code></li>
<li>查询域名对应的IP: <code>dig &lt;domain-name&gt;</code></li>
<li>查询IP对应的域名: <code>dig -x &lt;ip&gt;</code></li>
<li>查看网络是否联通: <code>ping &lt;ip|domain-name&gt;</code></li>
<li>查看公网IP: <code>curl http://members.3322.org/dyndns/getip</code></li>
<li>每隔一秒高亮显示网络链接数: <code>watch -n 1 -d &quot;netstat -ant&quot;</code></li>
<li>查看一下当前的网络连接情况: <code>netstat -nt | awk &#39;/^tcp/ {++state[$NF]} END {for(key in state) print key,&quot;t&quot;,state[key]}&#39;</code></li>
<li>telnet: <code>telnet &lt;ip&gt; &lt;port&gt;</code></li>
</ul>
<hr>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li>光标回到行首：<code>ctrl + a(ahead)</code></li>
<li>光标回到行尾：<code>ctrl + e(end)</code></li>
<li>光标向行首移动一个字符：<code>ctrl + b(backwards)</code></li>
<li>光标向行尾移动一个字符：<code>ctrl + f(forwards)</code></li>
<li>删除光标到行首的字符：<code>ctrl + w</code></li>
<li>删除光标到行尾的字符：<code>ctrl + k</code></li>
<li>删除整个命令行文本字符：<code>ctrl + u</code></li>
<li>向行首删除一个字符：<code>ctrl + h</code></li>
<li>向行尾删除一个字符：<code>ctrl + d</code></li>
<li>粘贴ctrl+u,ctrl+k,ctrl+w删除的字符：<code>ctrl + y</code></li>
<li>上一个使用的历史命令：<code>ctrl + p</code></li>
<li>下一个使用的历史命令：<code>ctrl + n</code></li>
<li>快速检索历史命令：<code>ctrl + r</code></li>
<li>交换光标所在和其前的字符：<code>ctrl + t</code></li>
<li>使终端静止，停止输出：<code>ctrl + s</code></li>
<li>退出ctrl+q引起的静止：<code>ctrl + q</code></li>
<li>使正在运行的任务运行于后台：<code>ctrl + z</code></li>
<li>空命令行状态下退出终端：<code>ctrl + d</code></li>
<li>显示所有终端支持的命令：<code>esc + esc + esc</code></li>
</ul>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="external">SSH原理与运用（一）：远程登录</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html" target="_blank" rel="external">SSH原理与运用（二）：远程操作与端口转发</a></li>
<li><a href="http://my.oschina.net/goberl/blog/85816" target="_blank" rel="external">linux下查看最消耗CPU、内存的进程</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/22/JVM-参数设置及分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/22/JVM-参数设置及分析/" itemprop="url">JVM 参数设置及分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-22T15:44:35+08:00">
                2015-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JVM-相关参数"><a href="#JVM-相关参数" class="headerlink" title="JVM 相关参数"></a>JVM 相关参数</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>含义</th>
<th>默认值</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Xms</td>
<td>初始堆大小</td>
<td>物理内存的1/64且&lt;1G</td>
<td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td>
</tr>
<tr>
<td>-Xmx</td>
<td>最大堆大小</td>
<td>物理内存的1/4且&lt;1G</td>
<td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制.</td>
</tr>
<tr>
<td>-Xmn</td>
<td>新生代大小（JDK 1.4 or lator）</td>
<td></td>
<td>此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>Eden区与Survivor区的大小比值</td>
<td></td>
<td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td>
</tr>
<tr>
<td>-XX:+TraceClassLoading</td>
<td>输出虚拟机的类加载列表</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>-verbose:gc</td>
<td>输出JVM的GC情况</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>打印GC的详细情况</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>-XX:+HeapDumpOnOutOfMemoryError</td>
<td>让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>-Xss</td>
<td>设置每个线程的栈大小</td>
<td>1024k</td>
<td>*</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/22/JavaEE-Servlet核心接口解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/22/JavaEE-Servlet核心接口解析/" itemprop="url">JavaEE Servlet核心接口解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-22T00:12:02+08:00">
                2015-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Java中，每一个Servlet程序都必须直接或间接实现<code>javax.servlet.Servlet</code>这个接口。当编写一个Servlet类时，直接实现它，当扩展一个实现这个接口的类时(如GenericServlet)，则间接实现它。它独立于协议，控制着每个Servlet的生命周期。</p>
<p>Servlet接口是Servlet与Servlet容器(如Tomcat)之间的一个约定。这个约定总结起来就是说：Servlet容器会把Servlet类加载到内存中，并在Servlet实例中调用<strong>特定的方法</strong>。而且在一个应用中，<strong>每个Servlet类型只能有一个实例</strong>。</p>
<hr>
<h2 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h2><h4 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h4><p>封装Servlet的配置信息。Servlet容器初始化一个Servlet对象时，会为这个Servlet对象创建一个ServletConfig对象,包含了Servlet的初始化参数信息。此外，ServletConfig对象还与ServletContext对象关联。ServletContext对象有以下方法：</p>
<blockquote>
<ul>
<li><code>public String getServletName()</code>;   返回servlet的名字，即web.xml中的servlet-name的子元素的值。如果没有配置这个子元素，则返回servlet类的名字。</li>
<li><code>public ServletContext getServletContext()</code>;<br>返回一个servletContext()对象.</li>
<li><code>public String getInitParameter(String name)</code>;<br>根据给定的初始化参数，返回匹配的初始化参数值。</li>
<li><code>public Enumeration&lt;String&gt; getInitParameterNames()</code>;<br>返回一个Enumeration对象，里面包含了所有的初始化参数。</li>
</ul>
</blockquote>
<h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><p>ServletContext是Servlet和Servlet容器之间直接通信的接口。Servlet容器在启动一个Web应用时，会为这个应用创建一个ServletContext对象。每一个Web应用有且只有一个ServletContext对象。同一个Web应用中的各个Servlet对象共享一个ServletContext对象。Servlet对象可以通过ServletContext来共享各种资源。</p>
<p>Web应用范围具有2层含义:</p>
<blockquote>
<ul>
<li>表示由Web应用的生命周期构成的时间段；</li>
<li>表示在Web应用生命周期内所有Web组件的集合；</li>
</ul>
</blockquote>
<p>ServletContext对象的3种获取方式：</p>
<blockquote>
<ol>
<li>Javax.servlet.http.HttpSession.getServletContext();</li>
<li>Javax.servlet.jsp.PageContext.getServletContext(); PageContext是JSP的隐式对象，所以可以在JSP页面直接获取ServletContext对象。</li>
<li>Javax.servlet.ServletConfig.getServletContext();<br>这就是ServletConfig和ServletContext关联的地方。</li>
</ol>
</blockquote>
<h4 id="ServletRequest"><a href="#ServletRequest" class="headerlink" title="ServletRequest"></a>ServletRequest</h4><p>封装当前的请求的配置和数据，以便Servlet开发者不必解析和操作原始的请求数据。</p>
<h4 id="ServletResponse"><a href="#ServletResponse" class="headerlink" title="ServletResponse"></a>ServletResponse</h4><p>当前请求的响应，它的作用是使得将响应传回用户更容易。</p>
<hr>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>init()、service()、destroy()是Servlet生命周期方法。Servlet容器将会按照以下原则调用这3个方法。</p>
<h4 id="init"><a href="#init" class="headerlink" title="init()"></a>init()</h4><p><code>public void init(ServletConfig config) throws ServletException</code><br>如果Servlet的配置参数<code>load-on-startup=1</code>，那么Servlet容器启动时就会调用这个方法。如果<code>load-on-startup=0</code>，那么第一次请求Servlet时，Servlet容器才会调用这个方法。在后续的请求中，<strong>将不会再调用这个方法</strong>。</p>
<p>可以利用这个方法来编写一些应用程序初始化相关的代码。在调用这个方法时，Servlet容器会传递一个ServletConfig参数。一般来说，会将ServletConfig参数赋值给一个类级变量，以便Servlet类中其他方法也可以使用这个对象。</p>
<h4 id="service"><a href="#service" class="headerlink" title="service()"></a>service()</h4><p><code>public void service(ServletRequest req, ServletResponse res)throws ServletException, IOException</code>；<br>每次请求Servlet时，容器都会调用这个方法。必须在这里编写要Servlet完成的响应的代码。<strong>第一次请求Servlet时，容器会调用init方法和service方法；对于后续的请求，容器只调用service方法</strong>。</p>
<h4 id="destroy"><a href="#destroy" class="headerlink" title="destroy()"></a>destroy()</h4><p><code>public void destroy();</code><br>要销毁Servlet时，容器就会调用这个方法。它通常发生在卸载应用程序，或者关闭Servlet容器的时候。一般来说，可以在这个方法中编写一些资源清理相关的代码。</p>
<h4 id="getServletConfig"><a href="#getServletConfig" class="headerlink" title="getServletConfig()"></a>getServletConfig()</h4><p><code>public ServletConfig getServletConfig();</code><br>返回由Servlet容器传给init方法的ServletConfig。但是为了让getServletConfig()返回非null值，<strong>你肯定已经为传给init方法的ServletConfig赋给了一个类级变量</strong>。</p>
<h4 id="getServletInfo"><a href="#getServletInfo" class="headerlink" title="getServletInfo()"></a>getServletInfo()</h4><p><code>public String getServletInfo();</code><br>返回Servlet的描述。可以返回可能有用的任意字符串，甚至可能是null。</p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>必须要注意的一点是线程安全性。因为一个Web应用中所有的用户将公用一个Servlet实例，所以不建议使用类级变量，以免引起资源争夺导致混乱。除非它们是只读的，比如JUC. atomic包中的成员。</p>
<p>以上。</p>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/21/Java-自带工具常用命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/21/Java-自带工具常用命令/" itemprop="url">Java 自带工具常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-21T15:52:47+08:00">
                2015-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Javap"><a href="#Javap" class="headerlink" title="Javap"></a>Javap</h2><p>javap是JDK自带的反汇编器，可以查看java编译器为我们生成的字节码。通过它，我们可以对照源代码和字节码，从而了解很多编译器内部的工作.</p>
<ul>
<li>查看帮助信息：<code>javap -help</code></li>
<li>查看版本：<code>javap -version</code></li>
<li>输出行和局部变量表：<code>javap -l</code></li>
<li>仅显示public类和成员：<code>javap -public</code></li>
<li>显示protected/public类和成员：<code>javap -protected</code></li>
<li>显示package/protected/public类和成员 (默认)：<code>javap -package</code></li>
<li>显示所有类和成员：<code>javap -p</code> <code>javap -private</code></li>
<li>输出内部类型签名：<code>javap -s</code></li>
<li>对代码进行反汇编：<code>javap -c</code></li>
<li>输出堆栈大小、各方法的 locals 及 args 数,以及class文件的编译版本：<code>javap -v</code> <code>javap -verbose</code></li>
<li>显示正在处理的类的系统信息 (路径, 大小, 日期, MD5散列)：<code>javap -sysinfo</code></li>
<li>显示静态最终常量：<code>javap -constants</code></li>
</ul>
<hr>
<h2 id="JPs"><a href="#JPs" class="headerlink" title="JPs"></a>JPs</h2><p>jps（Java Process Status），虚拟机进程状态工具。可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()方法所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier，LVMID）。</p>
<blockquote>
<p>jps [options][hostid]</p>
</blockquote>
<ul>
<li>只输出LVMID，不输出主类名字：<code>jps -q</code></li>
<li>输出虚拟机进程启动时传递给主类main函数的参数：<code>jps -m</code></li>
<li>输出主类的全名，如果是jar包则输出jar包路径：<code>jps -l</code></li>
<li>输出虚拟机进程启动时JVM参数：<code>jps -v</code></li>
</ul>
<hr>
<h2 id="JStat"><a href="#JStat" class="headerlink" title="JStat"></a>JStat</h2><p>jstat（Java Statistics Monitoring Tool），虚拟机统计信息监视工具。用于监视虚拟机各种运行状态信息的命令行工具，它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾回收、JIT编译等运行数据。在没有GUI情况下，这是运行期定位虚拟机性能问题的首选工具。</p>
<blockquote>
<p>jstat [option vmid [interval[s|ms] [count]]]</p>
</blockquote>
<p>命令格式中的VMID和LVMID需要说明下，如果是本地虚拟机进程，那么VMID和LVMID是一致的，如果是远程虚拟机进程，那VMID格式是</p>
<blockquote>
<p>[protocol:][//]lvmid [@hostname[:port] / servername]</p>
</blockquote>
<p>参数interval和count代表查询间隔和次数，如果省略这两个参数，那么只查询一次。option代表用户希望查询的虚拟机信息，主要包括3类：类装载、垃圾回收、运行期变异状况。具体如下。</p>
<ul>
<li>监视类装载、卸载数量、总空间以及类装载所耗费时间：<code>jstat -class</code></li>
<li>监视Java堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等：<code>jstat -gc</code></li>
<li>输出Java堆各个区域使用到的最大、最小空间：<code>jstat -gccapacity</code></li>
<li>输出已使用空间占总空间的百分比：<code>jstat -gcutil</code></li>
<li>输出上一次GC的原因：<code>jstat -gccause</code></li>
<li>监视新生代GC状况：<code>jstat -gcnew</code></li>
<li>监视新生代GC状况，关注使用到的最大、最小空间：<code>jstat -gcnewcapacity</code></li>
<li>监视老年代GC状况：<code>jstat -gcold</code></li>
<li>监视老年代GC状况，关注使用到的最大、最小空间：<code>jstat -gcoldcapacity</code></li>
<li>输出永久代的最大、最小空间：<code>jstat -gcpermcapacity</code></li>
<li>输出JIT编译器编译过的方法、耗时等信息：<code>jstat -compiler</code></li>
<li>输出已经被JIT编译的方法：<code>jstat -printcompilation</code></li>
</ul>
<hr>
<h2 id="JInfo"><a href="#JInfo" class="headerlink" title="JInfo"></a>JInfo</h2><p>jinfo（Configuration Info for Java），Java配置信息工具。作用是可以实时地查看和调整虚拟机各项参数。</p>
<blockquote>
<p>jinfo [ option ] &lt; pid &gt;</p>
</blockquote>
<ul>
<li>查看所有参数：<code>jinfo -flags &lt;pid&gt;</code></li>
<li>查看未被显示指定的参数的系统默认值：<code>jinfo -flag [name] &lt;pid&gt;</code></li>
<li>查看未被显示指定的参数的系统默认值(JDK1.6-)：<code>java -XX:+PrintFlagsFinal</code></li>
<li>修改运行期虚拟机参数：<code>jinfo -flag [+/-] name</code> <code>jinfo -flag &lt;name&gt;=&lt;value&gt;</code></li>
<li>输出虚拟机进程的System.getProperties()的内容：<code>jinfo -sysprops &lt;pid&gt;</code></li>
</ul>
<hr>
<h2 id="JMap"><a href="#JMap" class="headerlink" title="JMap"></a>JMap</h2><p>jmap（Memory Map for Java），Java内存映像工具，用于生成堆转储快照（一般称为heapdump文件或dump文件）。jmap的作用不仅仅是获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细，如空间使用率、当前用的是哪种回收器等。</p>
<blockquote>
<p>jmap [ option ] vmid</p>
</blockquote>
<ul>
<li>生成Java堆转储快照：<code>jmap -dump [live, ] format=b, file=&lt;filename&gt;</code></li>
<li>当虚拟机对-hump 选项没有响应时，强制生成dump快照，只在Linux/Solaris平台有效：<code>jmap -F</code></li>
<li>显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台有效：<code>jmap -finalizerinfo</code></li>
<li>显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台有效：<code>jmap -heap</code></li>
<li>显示堆中对象统计信息，包括类、实例对象、合计容量：<code>jmap -histo</code></li>
<li>以ClassLoader为统计口径显示永久代内存状态，只在Linux/Solaris平台有效：<code>jmap permstat</code></li>
</ul>
<hr>
<h2 id="JHat"><a href="#JHat" class="headerlink" title="JHat"></a>JHat</h2><p>jhatzhuanch （JVM Heap Analyisi Tool），虚拟机堆转储快照分析工具。</p>
<hr>
<h2 id="JStack"><a href="#JStack" class="headerlink" title="JStack"></a>JStack</h2><p>jstack（Stack Trace for Java），Java堆栈工具，用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内为每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。</p>
<p>线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待什么资源。</p>
<blockquote>
<p>jstack [ option ] &lt; vmid &gt;</p>
</blockquote>
<ul>
<li>当正常输出的请求不被响应是，强制输出线程堆栈：<code>jstack -F</code></li>
<li>除堆栈外，显示显示关于锁的附加信息：<code>jstack -l</code></li>
<li>如果调用本地方法，显示C/C++的堆栈：<code>jstack -m</code></li>
</ul>
<p>在JDK1.5中，java.lang.Thread新增了一个getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码就完成了jstack的大部分功能，在实际项目中可以调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈。</p>
<hr>
<h2 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h2><p>JConsole（Java Monitoring and Management Console），是一种基于JMX的可视化监视、管理工具。它管理部分的功能是针对JMX MBean进行管理，由于MBean可以使用代码、中间件服务器的管理控制台或者所有符合JMX规范的软件进行访问，所以重点是使用JConsole的监视功能。</p>
<hr>
<h2 id="JVisualVM"><a href="#JVisualVM" class="headerlink" title="JVisualVM"></a>JVisualVM</h2><p>JVisualVM（All-in-One Java Troubleshooting Tool），Java多合一故障处理工具。是目前为止随JDK发布的功能最强大的运行监视和故障处理程序，并且可以预见在未来一段时间内都是官方主力发展的虚拟机故障处理工具。而且还有很多高效的插件可以使用。</p>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/18/Git-常用命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/18/Git-常用命令/" itemprop="url">Git 常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-18T08:11:31+08:00">
                2015-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><ul>
<li>设置全局用户名：<code>git config --global user.name &lt;your-user-name&gt;</code></li>
<li>设置全局邮箱：<code>git config --global user.email &lt;your-email&gt;</code></li>
<li>查看全局设置：<code>git config --global --list</code></li>
<li>设置项目用户名：<code>git config user.name &lt;your-user-name&gt;</code></li>
<li>设置项目邮箱：<code>git config user.email &lt;your-email&gt;</code></li>
<li>查看项目设置：<code>git config --list</code></li>
</ul>
<hr>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li>查看Git状态：<code>git status</code></li>
<li>查看日志：<code>git log</code></li>
<li>查看常用帮助：<code>git help</code></li>
<li>查看全部帮助：<code>git help -a</code></li>
<li>查看某个命令帮助：<code>git help &lt;command-name&gt;</code></li>
<li>查看版本：<code>git --version</code></li>
</ul>
<hr>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>初始化：<code>git init</code></li>
<li>关联远程仓库：<code>git remote add origin &lt;git-url&gt;</code></li>
<li>克隆项目到本地：<code>git clone &lt;git-url&gt;</code></li>
</ul>
<hr>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><ul>
<li>更新：<code>git pull</code></li>
</ul>
<hr>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul>
<li>添加某个文件到版本控制中：<code>git add [dir-name/]&lt;file-name&gt;</code></li>
<li>添加某个文件夹到版本控制中：<code>git add &lt;dir-name&gt;</code></li>
<li>添加所有文件到版本控制中：<code>git add .</code></li>
<li>从版本控制中删除某个文件：<code>git rm [dir-name/]&lt;file-name&gt;</code></li>
<li>提交修改：<code>git commit -m &quot;&lt;your-commit-note&gt;&quot;</code></li>
<li>推送到远程仓库：<code>git push [origin master]</code></li>
</ul>
<hr>
<h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><blockquote>
<p><strong>工作目录</strong>：git clone 后获得的一份本地的代码，也包括新编辑的，尚未加入版本控制的代码;<br><strong>暂存区域</strong>：git add 后暂存起来，尚未 git commit 的代码;<br><strong>本地仓库</strong>：git commit 后正式被版本控制记录起来的代码；</p>
</blockquote>
<ul>
<li>查看工作目录和暂存区域区别：<code>git diff</code></li>
<li>查看暂存区域和本地仓库区别：<code>git diff --staged</code> <code>git diff --cached</code></li>
</ul>
<hr>
<h3 id="取消修改"><a href="#取消修改" class="headerlink" title="取消修改"></a>取消修改</h3><ul>
<li>取消尚未add的修改：<code>git checkout -- &lt;file-name&gt;</code></li>
<li>取消已经add到未commit的修改：<code>git reset HEAD &lt;file-name&gt;</code></li>
<li>覆盖上次提交，用于已commit：<code>git commit --amend</code></li>
<li>撤销本地commit(回滚到某次commit): <code>git log</code> + <code>git reset [--hard] &lt;commit-id&gt;</code></li>
</ul>
<hr>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="http://pm.readthedocs.org/zh_CN/latest/vcs/git/usage.html" target="_blank" rel="external">Git常用命令：程序员的场景</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的网站：Git教程</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg"
               alt="archerda" />
          <p class="site-author-name" itemprop="name">archerda</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">57</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/archerda" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:luo.archer@gmail.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Email
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">archerda</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
