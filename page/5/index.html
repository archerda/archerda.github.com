<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="archerda, ArcherdaArcherda's BlogHexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Archerda&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Archerda&#39;s Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Archerda&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/"/>





  <title>Archerda's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Archerda's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Programmer. Meditating.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/31/Java发展历程-图文版/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/31/Java发展历程-图文版/" itemprop="url">Java发展历程(图文版)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-31T10:43:25+08:00">
                2015-08-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://farm6.staticflickr.com/5688/20398542974_320e0e569a_o.jpg" alt="Java发展历程"></p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://blog.b13technology.com/2015/08/19/java-history/" target="_blank" rel="external">The History of the Java Programming Language (Infographic)</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/28/Java-内存模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/28/Java-内存模型/" itemprop="url">Java 内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-28T17:10:59+08:00">
                2015-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java虚拟机规范中试图定义一种Java内存模型（Java Memony Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。经过长时间的验证和修补，在JDK1.5（实现了JSR-133）发布后，Java内存模型已经成熟和完善起来。</p>
<h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><p>Java内存模型规定了所有的变量都存储在主内存（Main Memony）中。每条线程还有自己的工作内存（Working Memony），线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在（读取、赋值等）工作内存中进行，而不能直接读写主内存的变量（volatile变量也一样）。不同线程之间也无法访问对方工作内存中的变量，线程间变量值的传递主要是通过主内存来完成。线程、主内存、工作内存交互图如下。<br><img src="https://farm6.staticflickr.com/5699/20944071295_03d6a1e5e7.jpg" alt=""></p>
<p>这里所说的主内存、工作内存与之前<a href="http://www.baidu.com" target="_blank" rel="external">JVM 内存区域</a>所说的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的。如果要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈的部分区域。从更低层次来说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。</p>
<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>关于主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了8中操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外）。</p>
<ul>
<li><p>lock（锁定）：</p>
<blockquote>
<p>作用于主内存的变量，把一个变量标志为一条线程独占的状态。</p>
</blockquote>
</li>
<li><p>unlock（解锁）：</p>
<blockquote>
<p>作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>
</blockquote>
</li>
<li><p>read（读取）：</p>
<blockquote>
<p>作用于主内存的变量，把一个变量的值从主内存中传输到线程的工作内存中，以便随后的load动作使用。</p>
</blockquote>
</li>
<li><p>load（载入）：</p>
<blockquote>
<p>作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p>
</blockquote>
</li>
<li><p>use（使用）：</p>
<blockquote>
<p>作用于工作内存的变量，把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码时将会执行这个操作。</p>
</blockquote>
</li>
<li><p>assign（赋值）：</p>
<blockquote>
<p>作用于工作内存的变量，把一个从执行引擎接受到的值赋值给工作内存中变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p>
</blockquote>
</li>
<li><p>store（存储）：</p>
<blockquote>
<p>作用于工作内存的变量，把工作内存中的一个变量传送到主内存中，以便随后的write操作使用。</p>
</blockquote>
</li>
<li><p>write（写入）：</p>
<blockquote>
<p>作用于主内存的变量，把store操作从工作内存中的得到的变量的值放入主内存的变量中。</p>
</blockquote>
</li>
</ul>
<p>如果要把一个变量从主内存拷贝到工作内存中，那就要顺序地执行read和load操作，如果要把工作内存中的变量同步回主内存，就要顺序的执行store和write操作。注意，Java内存模型只要求上述2个操作必须顺序执行，而没有保证是连续执行。也就是说，read和load之间、store和write之间是可以插入其他指令的。除此之外，Java内存模型还规定了在执行上述8中基本操作时必须满足如下规则：<br><img src="https://farm1.staticflickr.com/765/20322329054_33e1c41474.jpg" alt=""></p>
<ul>
<li>不允许read和load、store和write操作之一单独出现。即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起了回写但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它最近的assign操作。即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存回写到主内存中。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。换句话说，就是对一个变量执行use、store操作之前，必须执行过了assign和load操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>如果对一个变量lock操作，那么会清空工作内存中此变量的值，在执行引擎使用这个变量的时候，必须重新load或assign来初始化该变量。</li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它进行unlock，也不允许unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock之前，必须先把变量同步回主内存（执行store、write）。</li>
</ul>
<h2 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h2><p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是并不容易理解。</p>
<p>当一个变量定义为volatile时，它将具备2种特性：<strong>第一是保证此变量对所有线程的可见性</strong>，这里的可见性是指一条线程修改了这个变量的值，新值对于其他线程来说是立即得知的。而普通变量做不到这点，普通变量的值在线程间传递需要通过主内存来完成。“volatile变量对所有线程是立即可见的，对volatile变量的所有写操作都能立刻反应到其他线程中，换句话说，volatile变量在各个线程中是一致的，但是基于volatile变量的运算在并发下却不一定安全”。<br>由于volatile变量只保证可见性，在不符合一下2条规则的运算场景中，我们仍然要通过加锁（synchronized或JUC中的原子类）来保证原子性。</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能确保只有单一的线程改变变量的值；</li>
<li>变量不需要与其他状态变量共同参与不变约束；</li>
<li>在访问变量时不需要加锁;        </li>
</ul>
<p><strong>第二是禁止指令重排序</strong>。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到指点，这就是Java内存模型描述的所谓的“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）</p>
<h2 id="对于long和double型变量的特殊规则"><a href="#对于long和double型变量的特殊规则" class="headerlink" title="对于long和double型变量的特殊规则"></a>对于long和double型变量的特殊规则</h2><p>JMM要求lock、unlock等8个操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机讲没有被volatile修饰的64位数据的读写规则划分为2次32位的操作来进行，即允许虚拟机实现选择不保证64位数据类型的laod、store、read、write这4个操作的原子性，这点就是所谓的long和double的<em>非原子协定</em>。</p>
<p>如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对他们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。</p>
<p>不过这种读取到“半个变量”的情况非常罕见（在目前商用Java虚拟机中不会楚翔），因为JMM虽然允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样做。在实际开发中，目前各平台下商用虚拟机几乎都选择把64位数据类型的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的long和double声明为volatile。</p>
<h2 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h2><p>JMM是围绕在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。我们逐一看下这3个特性。</p>
<h3 id="原子性（Atomicity）："><a href="#原子性（Atomicity）：" class="headerlink" title="原子性（Atomicity）："></a>原子性（Atomicity）：</h3><p>有JMM来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据的访问读写是具有原子性的。</p>
<p>如果应用场景需要一个更大范围的原子性保证（经常遇到），JMM还提供了lock和unlock操作来满足这种需求，尽管虚拟机还没有把lock和unlock操作直接开发给开发者使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式使用者2个操作，这2个字节码指令反应到Java代码中就是同步块-synchronized关键字，因此在synchronized块之间的操作也具备原子性。</p>
<h3 id="可见性（Visibility）："><a href="#可见性（Visibility）：" class="headerlink" title="可见性（Visibility）："></a>可见性（Visibility）：</h3><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。volatile变量能够保证新值能立即同步到主内存中，以及每次使用前立即从主内存刷新。因此可以说volatile保证了多线程操作时变量的可见性。</p>
<p>除了volatile之外，Java还有2个关键字能够实现可见性，即synchronized和final。同步块的可见性是由“对一个变量执行unlock之前，必须先把此变量同步回主内存中”这条规则获得的。而final关键字可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见final字段的值。</p>
<h3 id="有序性（Ordering）："><a href="#有序性（Ordering）：" class="headerlink" title="有序性（Ordering）："></a>有序性（Ordering）：</h3><p>Java程序中天然的有序性可以归结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行化的语义”，后半句是指“指令重排序”现象和“工作内存和主内存同步延迟”现象。</p>
<p>Java语言提供了volatile和synchronized来保证线程之间操作的有序性，volatile本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的2个同步块只能串行的进入。</p>
<p>呵呵，synchronized真是万能啊，所有3个特性都能由它来保证。的确，大部分并发控制操作都能使用synchronized来完成，也就间接造成了滥用，越“万能”的并发控制，也伴随了越大的性能影响。</p>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>如果JMM中所有的有序性都仅仅靠volatile和synchronized来完成，那么有一些操作将会变得很繁琐，但是我们在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发生”（happens-before）原则。这个原则非常重要，他是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个规则，我们可以通过几条规则一揽子解决并发环境下2个操作之间是否可能存在冲突的素有问题。</p>
<p>下面是JMM下一些“天然的”先行发生关系，这些先行发生关系无需任何同步器协助就已经存在，可以在编码中直接使用。如果2个操作之间的关系不在此列，并且无法从下列规则推到出来，他们的顺序就没有顺序性的保障，虚拟机可以对他们随意地进行重排序。</p>
<ul>
<li><p>程序次序规则（Program Order Rule）：</p>
<blockquote>
<p>在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。 </p>
</blockquote>
</li>
<li><p>管程锁定规则（Monitor Lock Rule）：</p>
<blockquote>
<p>一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”同样指的是时间上的先后顺序。</p>
</blockquote>
</li>
<li><p>volatile变量规则（Volatile Variable Rule）：</p>
<blockquote>
<p>对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的后面同时指的是时间上得先后顺序。</p>
</blockquote>
</li>
<li><p>线程启动规则（Thread Start Rule）：</p>
<blockquote>
<p>Thread对象的start()方法先行发生于此线程的每一个动作。</p>
</blockquote>
</li>
<li><p>线程终止规则（Thread Termination Rule）：</p>
<blockquote>
<p>线程中所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行了。</p>
</blockquote>
</li>
<li><p>线程中断规则（Thread Interruption Rule）：</p>
<blockquote>
<p>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</p>
</blockquote>
</li>
<li><p>对象终结规则（Finallizer Rule）：</p>
<blockquote>
<p>一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</p>
</blockquote>
</li>
<li><p>传递性（Transitivity）：</p>
<blockquote>
<p>如果操作A先行发生于操作B，操作B先行发生于操作C，那么可以推断出操作A先行发生于操作C的结论。</p>
</blockquote>
</li>
</ul>
<p>以上。</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li>《深入理解Java虚拟机-JVM高级特性与最佳实践》第二版 周志明著</li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/28/JVM-内存区域/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/28/JVM-内存区域/" itemprop="url">JVM 内存区域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-28T14:07:24+08:00">
                2015-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于Java来说，在JVM自动内存管理机制的帮助下，不再需要为每一个new操作去手动管理内存空间，不容易出现内存泄露和内存溢出的问题，由JVM管理内存这一切看上去很美好，不过也正是因为Java把内存控制的权利交给了JVM，一旦出现内存泄露和溢出方面的问题，如果不了解JVM是如何使用内存的，那么排查错误将会成为一个异常艰难的工作。所以了解JVM内存区域是非常有用且必要的。</p>
<hr>
<p>JVM在执行Java程序的过程中会把它管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，各自的生命周期，有的区域岁JVM进程的启动而存在，有些区域则依赖用户线程的启动和结束而创建和销毁。根据《Java虚拟机规范(Java SE 7版)》的规定，JVM所管理的内存将会包括以下几个运行时区域，如下图所示。<br><img src="https://farm6.staticflickr.com/5706/20779779755_12f06f3ddd.jpg" alt=""></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是<code>当前线程所执行字节码的行号指示器</code>。由于JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。在任何一个时刻，一个处理器（对多核来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的PC，各条线程之间的PC互不影响，独立存储，这种类型的内存区域也成为<code>线程私有</code>的内存，线程间不可见。</p>
<p>另外，如果线程正在执行的是一个Java方法，这个PC记录的是正在执行的JVM字节码指令的地址；如果正在执行的是Native方法，那么这个PC则置空(Undefined)。此内存区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p><img src="https://farm6.staticflickr.com/5759/20756845859_470b1c3d2f.jpg" alt=""><br>与PC一样，JVM栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个帧栈(Stack Frame)，<code>用于存储局部变量表、操作数栈、动态链接、方法出口等信息</code>。每一个方法从调用到执行完成的过程，对应着一个帧栈在虚拟机栈中进栈到出栈的过程。</p>
<p>网上有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种划分方式比较简单，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大部分程序员最关注的、与对象内存分配关系最密切的内存区是这2块。其中所指的“堆”会在后面解释，而所指的“栈”就是现在所说的虚拟机栈，或者说是虚拟机栈中局部变量的部分。</p>
<p>局部变量表存放了编译器可知的各种基本数据类型（byte、short、int、long、float、double、boolean、char）、对象引用（Reference类型，它不等同于对象本身，可能是一个对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向一条指令码指令的地址）。</p>
<p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot）（在多线程环境中，long和double是比较特殊的，很多操作或许会跟其他基本类型不一样，可能会引起额外的问题，这里先提及一下），其余的数据类型只占用1个Slot。<code>局部变量表所需的空间在编译期间完成分配</code>，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>在Java虚拟机规范中，对这个区域规定了2中异常状况：如果线程请求的栈深度大于虚拟机允许的深度，将会抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前的大部分的Java虚拟机都可以动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈（Native Method Stack）与虚拟机所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机过管理的内存中最大的一块。<code>Java堆是被所有线程共享的一块内存区域，在JVM启动时创建。
此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存</code>。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配内存(The heap is the runtime data area from which memory for all class instances and arrays is allocated)。但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在对上也逐渐变得不是那么“绝对”了。</p>
<p>Java堆是GC管理的主要区域，因此很多时候也被称作“GC堆”。从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步的划分的目的是为了更好地回收内存，或者更快地分配内存。</p>
<p>根据JLS的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的。不过当前主流的JVM都是按照可扩展来实现的(通过-Xmx和-Xms控制)。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被JVM加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。虽然JVM规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Head（非堆），目的应该是与Java堆区分开来。</p>
<p>对于习惯在HotSpot JVM上开发、部署程序的开发者来说，很多人愿意把方法区成为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot JVM的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。对于其他JVM如BEA JRockit、IBM J9等，是不存在永久代的概念的。原则上，如何实现方法区属于虚拟机实现细节，不受虚拟机规范约束，但使用永久代来实现方法区，现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题（永久代有-XX:MaxPermSize的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4G，就不会出现问题），而且有极少数方法（例如String.intern()）会因为这个原因导致不同虚拟机下有不同的表现。因此，对于HotSpot虚拟机，根据官方发布的路线图信息，现在也有放弃永久代并逐步改为Native Memory来实现方法区的规划了，在目前已经发布的JDK1.7的Hot Spot中，已经把原本放在永久代中的字符串常量池异常。而在目前最新的JDK1.8的Hot Spot，已经移除了永久代了。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p>Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中的描述的符号引用外，还会把翻译出来的直接引用也存储到运行时常量池中。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有在编译器才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多得便是String类的intern()方法。</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时便会抛出OutOfMemoryError异常。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以说明下。</p>
<p>在JDK1.4中新加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用来进行操作。这样能在一些场合显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<p>显然，本机直接分配内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是受到本机总内存（包括RAM和SWAP区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li>《深入理解Java虚拟机-JVM高级特性与最佳实践》第二版 周志明著</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/25/Linux&Mac常用命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/25/Linux&Mac常用命令/" itemprop="url">Linxu&Mac 常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-25T00:22:40+08:00">
                2015-08-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="文件-文件夹-磁盘管理"><a href="#文件-文件夹-磁盘管理" class="headerlink" title="文件/文件夹/磁盘管理"></a>文件/文件夹/磁盘管理</h2><ul>
<li>由第一行开始显示档案内容(n为显示行号)：<code>cat [-n] &lt;file-name&gt;</code></li>
<li>从最后一行开始显示(Mac无)：<code>tac &lt;file-name&gt;</code> </li>
<li>查看头几行：<code>head [-lineNumber] &lt;file-name&gt;</code></li>
<li>查看尾几行：<code>tail [-lineNumber] &lt;file-name&gt;</code> </li>
<li>以二进制的方式读取档案内容：<code>od &lt;file-name&gt;</code></li>
<li>分页显示文件(space下一页，b上一页)：<code>more &lt;file-name&gt;</code></li>
<li>分页显示文件(支持PageDown和PageUp)：<code>less &lt;file-name&gt;</code></li>
<li>创建软链接(inode不一样): <code>ln -s &lt;from-file-with-absolute-path&gt; &lt;soft-link-file-with-absolute-path&gt;</code></li>
<li>创建硬链接(inode一样): <code>ln &lt;from-file-with-absolute-path&gt; &lt;hard-link-file-with-absolute-path&gt;</code></li>
<li>查看文件的inode信息: <code>stat &lt;file&gt;</code></li>
<li>查看硬盘分区的inode总数和已经使用的数量: <code>df -i</code></li>
<li>查看每个inode节点的大小: <code>sudo dumpe2fs -h /dev/hda | grep &quot;Inode size&quot;</code></li>
<li>查看文件的inode号码: <code>ls -i &lt;file&gt;</code></li>
<li>查看当前文件夹磁盘占用情况：<code>du -shc *</code></li>
<li>查看磁盘使用情况：<code>df -lh</code></li>
<li>查看inode使用情况： <code>df -hi</code></li>
<li>找某个文件并打印内容：<code>find . -name &quot;&lt;file-name&gt;&quot; -exec cat {} \;</code></li>
<li>在当前目录下查找某个字符串并打印行号：<code>find ./* | xargs grep -n &#39;&lt;string-you-find&gt;&#39;</code></li>
</ul>
<hr>
<h2 id="压缩文件管理"><a href="#压缩文件管理" class="headerlink" title="压缩文件管理"></a>压缩文件管理</h2><ul>
<li>创建tar文件：<br><code>tar -cvf &lt;archive-name.tar&gt; &lt;file1-OR-file2-OR-both-to-archive&gt;</code></li>
<li>查看tar文件：<code>tar -tvf &lt;archive-to-view.tar&gt;</code></li>
<li>提取tar文件：<code>tar -xvf &lt;archive-to-extract.tar&gt;</code></li>
<li>创建和提取gzip压缩文件：<code>gzip &lt;filename&gt;</code></li>
<li>对gzip文档进行解压：<code>unzip &lt;archive-to-extract.zip&gt;</code></li>
<li>查看gzip文件：<code>unzip -l &lt;archive-to-extract.zip&gt;</code></li>
</ul>
<hr>
<h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><ul>
<li>启动crond服务：<code>service crond start</code></li>
<li>停止crond服务：<code>service crond stop</code></li>
<li>重启crond服务：<code>service crond restart</code></li>
<li>为某个使用者建立/移除crontab任务： <code>crontab -u username</code></li>
<li>编辑crontab任务内容：<code>crontab -e</code></li>
<li>查看crontab任务内容：<code>crontab -l</code></li>
<li>移除crontab所有任务：<code>crontab -r</code></li>
<li>crontab内容格式：<ul>
<li><code>* * * * *    path</code></li>
<li>前面5个 <code>*</code> 代表：分(0-59)、时(0-23)、日(1-31)、月(1-12)、周(0-7)</li>
<li><code>*</code> 号代表任何时间都能接受的意思，任意；</li>
<li>如果是一段时间，用<code>-</code>连接</li>
<li>如果是隔开几个时间，用<code>,</code>连接</li>
<li>如果是某个时间单位每隔多久，用<code>/&lt;interval&gt;</code>连接</li>
</ul>
</li>
<li>例如：<br><code>* */12 * * * /Users/Archerda/Configuration/Script/CodingBit/coding.sh</code><br>代表每隔12个小时执行一次coding.sh</li>
<li>Mac下的cron日志会在<code>/var/mail/&lt;username&gt;</code>中记录，可以用cat查看。每次cron任务有标准输出时都会记录在该文件中，并且在终端会提醒<code>You have new mail in /var/mail/&lt;username&gt;</code></li>
</ul>
<hr>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><ul>
<li>列出当前用户名：<code>who</code></li>
<li>查看用户登录状态：<code>w</code></li>
<li>快速查找某用户信息：<code>finger &lt;user-name&gt;</code></li>
<li>切换用户(switch user)：<code>su &lt;user-name&gt;</code></li>
<li>修改用户密码：<code>passwd</code></li>
<li>查看UID等：<code>id &lt;user-name&gt;</code></li>
</ul>
<hr>
<h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><ul>
<li>显示系统内核版本：<code>uname</code></li>
<li>显示系统所有信息：<code>uname -a</code></li>
<li>显示发行版信息： <code>cat /etc/issue</code></li>
</ul>
<hr>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><ul>
<li>查看系统资源使用情况并排序：<code>top</code></li>
<li>可视化查看系统资源使用情况：<code>sudo htop</code> </li>
<li>使用homebrew安装htop：<code>brew intall htop</code></li>
<li>列出活跃进程：<code>ps</code></li>
<li>列出所有系统运行命令并分页：<code>ps -A | less</code></li>
<li>列出指定进程名的进程(BSD格式输出：USER , PID , %CPU , %MEM , VSZ , RSS , TTY , STAT , START , TIME , COMMAND)：<code>ps aux | grep &lt;pname&gt; --color=auto</code></li>
<li>列出指定进程名的进程(标准格式输出：UID , PID , PPID , C , STIME , TTY , TIME , CMD)：<code>ps -ef | grep &lt;pname&gt; --color=auto</code></li>
<li>根据ID杀死进程：<code>kill &lt;pid&gt;</code></li>
<li>根据关键字查询PID：<code>pgrep -f &lt;key-word&gt;</code></li>
<li>根据进程名称杀死一个进程：<code>pkill &lt;name&gt;</code> <code>killall &lt;name&gt;</code></li>
<li>杀死图形界面程序(Mac默认没有这个工具)：<code>xkill</code></li>
<li>改变线程nice值(优先级，-19最高，19最低，0默认)：<code>renice &lt;nice-value&gt; &lt;pid&gt;</code></li>
<li>在后台不挂断地运行命令(日志默认写在当前目录的nohup.out)：<code>nohup &lt;command&gt; &lt;arg&gt; [&gt; &lt;filename&gt; 2&gt;&amp;1] &amp;</code></li>
<li>建立一个处于断开模式下的会话：<code>screen -dmS &lt;session-name&gt;</code></li>
<li>列出所有会话：<code>screen -list</code></li>
<li>重新连接会话：<code>screen -r &lt;session-name&gt;</code></li>
<li>跟踪进程执行时的系统调用和所接收的信号 (在调试的时候一般是从后往前看strace命令的结果，这样更容易找到有价值的信息): <code>strace &lt;command&gt;</code></li>
</ul>
<hr>
<h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><ul>
<li>查看文件的MD5(Mac)：<code>md5 &lt;file-name&gt;</code></li>
<li>查看文件的SHA1(Mac): <code>shasum -a 1 &lt;file-name&gt;</code></li>
<li>查看文件的SHA256(Mac): <code>shasum -a 256 &lt;file-name&gt;</code></li>
<li>查看文件的MD5(Linux)：<code>md5sum &lt;file-name&gt;</code></li>
<li>查看文件的SHA：<code>shasum &lt;file-name&gt;</code></li>
<li>查看文件的SHA1：<code>sha1sum &lt;file-name&gt;</code></li>
<li>生成RSA的SSH： <code>ssh-keygen -t rsa</code></li>
</ul>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><ul>
<li>输出重定向到剪贴板(Mac): <code>&lt;command&gt; | pbcopy</code></li>
</ul>
<hr>
<h2 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h2><ul>
<li>ssh登录：<code>ssh [-p &lt;port&gt;] &lt;user&gt;@&lt;host&gt;&#39;</code></li>
<li>ssh免密码登录(公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾)：<code>ssh &lt;user&gt;@&lt;host&gt; &#39;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code></li>
<li>ssh禁用密码登录并启用ssh密钥登录：<code>vim /etc/ssh/sshd_config</code> <code>PubkeyAuthentication yes;AuthorizedKeysFile .ssh/authorized_keys;PasswordAuthentication no</code> <code>service sshd restart</code></li>
</ul>
<hr>
<h2 id="CPU管理"><a href="#CPU管理" class="headerlink" title="CPU管理"></a>CPU管理</h2><ul>
<li>显示CPU信息：<code>cat /proc/cpuinfo</code></li>
<li>显示CPU信息：<code>lscpu</code></li>
<li>显示CPU占用最多的前10个进程：<code>ps auxw|head -1;ps auxw|sort -rn -k3|head -10</code></li>
</ul>
<hr>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ul>
<li>显示内存信息：<code>free -m</code> </li>
<li>显示内存信息：<code>cat /proc/meminfo</code></li>
<li>显示内存消耗最多的前10个进程：<code>ps auxw|head -1;ps auxw|sort -rn -k4|head -10</code></li>
<li>显示虚拟内存使用最多的前10个进程：<code>ps auxw|head -1;ps auxw|sort -rn -k5|head -10</code></li>
<li>释放buffer和cache: <code>echo 3 &gt; /proc/sys/vm/drop_caches</code></li>
<li>每隔一秒高亮显示内存变化情况: <code>watch -n 1 -d &quot;free&quot;</code></li>
</ul>
<hr>
<h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><ul>
<li>查看已用端口：<code>netstat -pltn</code></li>
<li>查看某个端口被哪个进程占用: <code>lsof -i:&lt;port&gt;</code></li>
<li>显示机器所属域名: <code>hostname -d</code></li>
<li>显示完整的主机名和域名: <code>hostname –f</code></li>
<li>显示当前机器的ip地址: <code>hostname –i</code></li>
<li>互动式地查询域名记录: <code>nslookup</code></li>
<li>查询域名对应的IP: <code>dig &lt;domain-name&gt;</code></li>
<li>查询IP对应的域名: <code>dig -x &lt;ip&gt;</code></li>
<li>查看网络是否联通: <code>ping &lt;ip|domain-name&gt;</code></li>
<li>查看公网IP: <code>curl http://members.3322.org/dyndns/getip</code></li>
<li>每隔一秒高亮显示网络链接数: <code>watch -n 1 -d &quot;netstat -ant&quot;</code></li>
<li>查看一下当前的网络连接情况: <code>netstat -nt | awk &#39;/^tcp/ {++state[$NF]} END {for(key in state) print key,&quot;t&quot;,state[key]}&#39;</code></li>
<li>telnet: <code>telnet &lt;ip&gt; &lt;port&gt;</code></li>
</ul>
<hr>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li>光标回到行首：<code>ctrl + a(ahead)</code></li>
<li>光标回到行尾：<code>ctrl + e(end)</code></li>
<li>光标向行首移动一个字符：<code>ctrl + b(backwards)</code></li>
<li>光标向行尾移动一个字符：<code>ctrl + f(forwards)</code></li>
<li>删除光标到行首的字符：<code>ctrl + w</code></li>
<li>删除光标到行尾的字符：<code>ctrl + k</code></li>
<li>删除整个命令行文本字符：<code>ctrl + u</code></li>
<li>向行首删除一个字符：<code>ctrl + h</code></li>
<li>向行尾删除一个字符：<code>ctrl + d</code></li>
<li>粘贴ctrl+u,ctrl+k,ctrl+w删除的字符：<code>ctrl + y</code></li>
<li>上一个使用的历史命令：<code>ctrl + p</code></li>
<li>下一个使用的历史命令：<code>ctrl + n</code></li>
<li>快速检索历史命令：<code>ctrl + r</code></li>
<li>交换光标所在和其前的字符：<code>ctrl + t</code></li>
<li>使终端静止，停止输出：<code>ctrl + s</code></li>
<li>退出ctrl+q引起的静止：<code>ctrl + q</code></li>
<li>使正在运行的任务运行于后台：<code>ctrl + z</code></li>
<li>空命令行状态下退出终端：<code>ctrl + d</code></li>
<li>显示所有终端支持的命令：<code>esc + esc + esc</code></li>
</ul>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="external">SSH原理与运用（一）：远程登录</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html" target="_blank" rel="external">SSH原理与运用（二）：远程操作与端口转发</a></li>
<li><a href="http://my.oschina.net/goberl/blog/85816" target="_blank" rel="external">linux下查看最消耗CPU、内存的进程</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/22/JVM-参数设置及分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/22/JVM-参数设置及分析/" itemprop="url">JVM 参数设置及分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-22T15:44:35+08:00">
                2015-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JVM-相关参数"><a href="#JVM-相关参数" class="headerlink" title="JVM 相关参数"></a>JVM 相关参数</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>含义</th>
<th>默认值</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Xms</td>
<td>初始堆大小</td>
<td>物理内存的1/64且&lt;1G</td>
<td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td>
</tr>
<tr>
<td>-Xmx</td>
<td>最大堆大小</td>
<td>物理内存的1/4且&lt;1G</td>
<td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制.</td>
</tr>
<tr>
<td>-Xmn</td>
<td>新生代大小（JDK 1.4 or lator）</td>
<td></td>
<td>此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>Eden区与Survivor区的大小比值</td>
<td></td>
<td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td>
</tr>
<tr>
<td>-XX:+TraceClassLoading</td>
<td>输出虚拟机的类加载列表</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>-verbose:gc</td>
<td>输出JVM的GC情况</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>打印GC的详细情况</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>-XX:+HeapDumpOnOutOfMemoryError</td>
<td>让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>-Xss</td>
<td>设置每个线程的栈大小</td>
<td>1024k</td>
<td>*</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/22/JavaEE-Servlet核心接口解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/22/JavaEE-Servlet核心接口解析/" itemprop="url">JavaEE Servlet核心接口解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-22T00:12:02+08:00">
                2015-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Java中，每一个Servlet程序都必须直接或间接实现<code>javax.servlet.Servlet</code>这个接口。当编写一个Servlet类时，直接实现它，当扩展一个实现这个接口的类时(如GenericServlet)，则间接实现它。它独立于协议，控制着每个Servlet的生命周期。</p>
<p>Servlet接口是Servlet与Servlet容器(如Tomcat)之间的一个约定。这个约定总结起来就是说：Servlet容器会把Servlet类加载到内存中，并在Servlet实例中调用<strong>特定的方法</strong>。而且在一个应用中，<strong>每个Servlet类型只能有一个实例</strong>。</p>
<hr>
<h2 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h2><h4 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h4><p>封装Servlet的配置信息。Servlet容器初始化一个Servlet对象时，会为这个Servlet对象创建一个ServletConfig对象,包含了Servlet的初始化参数信息。此外，ServletConfig对象还与ServletContext对象关联。ServletContext对象有以下方法：</p>
<blockquote>
<ul>
<li><code>public String getServletName()</code>;   返回servlet的名字，即web.xml中的servlet-name的子元素的值。如果没有配置这个子元素，则返回servlet类的名字。</li>
<li><code>public ServletContext getServletContext()</code>;<br>返回一个servletContext()对象.</li>
<li><code>public String getInitParameter(String name)</code>;<br>根据给定的初始化参数，返回匹配的初始化参数值。</li>
<li><code>public Enumeration&lt;String&gt; getInitParameterNames()</code>;<br>返回一个Enumeration对象，里面包含了所有的初始化参数。</li>
</ul>
</blockquote>
<h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><p>ServletContext是Servlet和Servlet容器之间直接通信的接口。Servlet容器在启动一个Web应用时，会为这个应用创建一个ServletContext对象。每一个Web应用有且只有一个ServletContext对象。同一个Web应用中的各个Servlet对象共享一个ServletContext对象。Servlet对象可以通过ServletContext来共享各种资源。</p>
<p>Web应用范围具有2层含义:</p>
<blockquote>
<ul>
<li>表示由Web应用的生命周期构成的时间段；</li>
<li>表示在Web应用生命周期内所有Web组件的集合；</li>
</ul>
</blockquote>
<p>ServletContext对象的3种获取方式：</p>
<blockquote>
<ol>
<li>Javax.servlet.http.HttpSession.getServletContext();</li>
<li>Javax.servlet.jsp.PageContext.getServletContext(); PageContext是JSP的隐式对象，所以可以在JSP页面直接获取ServletContext对象。</li>
<li>Javax.servlet.ServletConfig.getServletContext();<br>这就是ServletConfig和ServletContext关联的地方。</li>
</ol>
</blockquote>
<h4 id="ServletRequest"><a href="#ServletRequest" class="headerlink" title="ServletRequest"></a>ServletRequest</h4><p>封装当前的请求的配置和数据，以便Servlet开发者不必解析和操作原始的请求数据。</p>
<h4 id="ServletResponse"><a href="#ServletResponse" class="headerlink" title="ServletResponse"></a>ServletResponse</h4><p>当前请求的响应，它的作用是使得将响应传回用户更容易。</p>
<hr>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>init()、service()、destroy()是Servlet生命周期方法。Servlet容器将会按照以下原则调用这3个方法。</p>
<h4 id="init"><a href="#init" class="headerlink" title="init()"></a>init()</h4><p><code>public void init(ServletConfig config) throws ServletException</code><br>如果Servlet的配置参数<code>load-on-startup=1</code>，那么Servlet容器启动时就会调用这个方法。如果<code>load-on-startup=0</code>，那么第一次请求Servlet时，Servlet容器才会调用这个方法。在后续的请求中，<strong>将不会再调用这个方法</strong>。</p>
<p>可以利用这个方法来编写一些应用程序初始化相关的代码。在调用这个方法时，Servlet容器会传递一个ServletConfig参数。一般来说，会将ServletConfig参数赋值给一个类级变量，以便Servlet类中其他方法也可以使用这个对象。</p>
<h4 id="service"><a href="#service" class="headerlink" title="service()"></a>service()</h4><p><code>public void service(ServletRequest req, ServletResponse res)throws ServletException, IOException</code>；<br>每次请求Servlet时，容器都会调用这个方法。必须在这里编写要Servlet完成的响应的代码。<strong>第一次请求Servlet时，容器会调用init方法和service方法；对于后续的请求，容器只调用service方法</strong>。</p>
<h4 id="destroy"><a href="#destroy" class="headerlink" title="destroy()"></a>destroy()</h4><p><code>public void destroy();</code><br>要销毁Servlet时，容器就会调用这个方法。它通常发生在卸载应用程序，或者关闭Servlet容器的时候。一般来说，可以在这个方法中编写一些资源清理相关的代码。</p>
<h4 id="getServletConfig"><a href="#getServletConfig" class="headerlink" title="getServletConfig()"></a>getServletConfig()</h4><p><code>public ServletConfig getServletConfig();</code><br>返回由Servlet容器传给init方法的ServletConfig。但是为了让getServletConfig()返回非null值，<strong>你肯定已经为传给init方法的ServletConfig赋给了一个类级变量</strong>。</p>
<h4 id="getServletInfo"><a href="#getServletInfo" class="headerlink" title="getServletInfo()"></a>getServletInfo()</h4><p><code>public String getServletInfo();</code><br>返回Servlet的描述。可以返回可能有用的任意字符串，甚至可能是null。</p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>必须要注意的一点是线程安全性。因为一个Web应用中所有的用户将公用一个Servlet实例，所以不建议使用类级变量，以免引起资源争夺导致混乱。除非它们是只读的，比如JUC. atomic包中的成员。</p>
<p>以上。</p>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/21/Java-自带工具常用命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/21/Java-自带工具常用命令/" itemprop="url">Java 自带工具常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-21T15:52:47+08:00">
                2015-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Javap"><a href="#Javap" class="headerlink" title="Javap"></a>Javap</h2><p>javap是JDK自带的反汇编器，可以查看java编译器为我们生成的字节码。通过它，我们可以对照源代码和字节码，从而了解很多编译器内部的工作.</p>
<ul>
<li>查看帮助信息：<code>javap -help</code></li>
<li>查看版本：<code>javap -version</code></li>
<li>输出行和局部变量表：<code>javap -l</code></li>
<li>仅显示public类和成员：<code>javap -public</code></li>
<li>显示protected/public类和成员：<code>javap -protected</code></li>
<li>显示package/protected/public类和成员 (默认)：<code>javap -package</code></li>
<li>显示所有类和成员：<code>javap -p</code> <code>javap -private</code></li>
<li>输出内部类型签名：<code>javap -s</code></li>
<li>对代码进行反汇编：<code>javap -c</code></li>
<li>输出堆栈大小、各方法的 locals 及 args 数,以及class文件的编译版本：<code>javap -v</code> <code>javap -verbose</code></li>
<li>显示正在处理的类的系统信息 (路径, 大小, 日期, MD5散列)：<code>javap -sysinfo</code></li>
<li>显示静态最终常量：<code>javap -constants</code></li>
</ul>
<hr>
<h2 id="JPs"><a href="#JPs" class="headerlink" title="JPs"></a>JPs</h2><p>jps（Java Process Status），虚拟机进程状态工具。可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()方法所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier，LVMID）。</p>
<blockquote>
<p>jps [options][hostid]</p>
</blockquote>
<ul>
<li>只输出LVMID，不输出主类名字：<code>jps -q</code></li>
<li>输出虚拟机进程启动时传递给主类main函数的参数：<code>jps -m</code></li>
<li>输出主类的全名，如果是jar包则输出jar包路径：<code>jps -l</code></li>
<li>输出虚拟机进程启动时JVM参数：<code>jps -v</code></li>
</ul>
<hr>
<h2 id="JStat"><a href="#JStat" class="headerlink" title="JStat"></a>JStat</h2><p>jstat（Java Statistics Monitoring Tool），虚拟机统计信息监视工具。用于监视虚拟机各种运行状态信息的命令行工具，它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾回收、JIT编译等运行数据。在没有GUI情况下，这是运行期定位虚拟机性能问题的首选工具。</p>
<blockquote>
<p>jstat [option vmid [interval[s|ms] [count]]]</p>
</blockquote>
<p>命令格式中的VMID和LVMID需要说明下，如果是本地虚拟机进程，那么VMID和LVMID是一致的，如果是远程虚拟机进程，那VMID格式是</p>
<blockquote>
<p>[protocol:][//]lvmid [@hostname[:port] / servername]</p>
</blockquote>
<p>参数interval和count代表查询间隔和次数，如果省略这两个参数，那么只查询一次。option代表用户希望查询的虚拟机信息，主要包括3类：类装载、垃圾回收、运行期变异状况。具体如下。</p>
<ul>
<li>监视类装载、卸载数量、总空间以及类装载所耗费时间：<code>jstat -class</code></li>
<li>监视Java堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等：<code>jstat -gc</code></li>
<li>输出Java堆各个区域使用到的最大、最小空间：<code>jstat -gccapacity</code></li>
<li>输出已使用空间占总空间的百分比：<code>jstat -gcutil</code></li>
<li>输出上一次GC的原因：<code>jstat -gccause</code></li>
<li>监视新生代GC状况：<code>jstat -gcnew</code></li>
<li>监视新生代GC状况，关注使用到的最大、最小空间：<code>jstat -gcnewcapacity</code></li>
<li>监视老年代GC状况：<code>jstat -gcold</code></li>
<li>监视老年代GC状况，关注使用到的最大、最小空间：<code>jstat -gcoldcapacity</code></li>
<li>输出永久代的最大、最小空间：<code>jstat -gcpermcapacity</code></li>
<li>输出JIT编译器编译过的方法、耗时等信息：<code>jstat -compiler</code></li>
<li>输出已经被JIT编译的方法：<code>jstat -printcompilation</code></li>
</ul>
<hr>
<h2 id="JInfo"><a href="#JInfo" class="headerlink" title="JInfo"></a>JInfo</h2><p>jinfo（Configuration Info for Java），Java配置信息工具。作用是可以实时地查看和调整虚拟机各项参数。</p>
<blockquote>
<p>jinfo [ option ] &lt; pid &gt;</p>
</blockquote>
<ul>
<li>查看所有参数：<code>jinfo -flags &lt;pid&gt;</code></li>
<li>查看未被显示指定的参数的系统默认值：<code>jinfo -flag [name] &lt;pid&gt;</code></li>
<li>查看未被显示指定的参数的系统默认值(JDK1.6-)：<code>java -XX:+PrintFlagsFinal</code></li>
<li>修改运行期虚拟机参数：<code>jinfo -flag [+/-] name</code> <code>jinfo -flag &lt;name&gt;=&lt;value&gt;</code></li>
<li>输出虚拟机进程的System.getProperties()的内容：<code>jinfo -sysprops &lt;pid&gt;</code></li>
</ul>
<hr>
<h2 id="JMap"><a href="#JMap" class="headerlink" title="JMap"></a>JMap</h2><p>jmap（Memory Map for Java），Java内存映像工具，用于生成堆转储快照（一般称为heapdump文件或dump文件）。jmap的作用不仅仅是获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细，如空间使用率、当前用的是哪种回收器等。</p>
<blockquote>
<p>jmap [ option ] vmid</p>
</blockquote>
<ul>
<li>生成Java堆转储快照：<code>jmap -dump [live, ] format=b, file=&lt;filename&gt;</code></li>
<li>当虚拟机对-hump 选项没有响应时，强制生成dump快照，只在Linux/Solaris平台有效：<code>jmap -F</code></li>
<li>显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台有效：<code>jmap -finalizerinfo</code></li>
<li>显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台有效：<code>jmap -heap</code></li>
<li>显示堆中对象统计信息，包括类、实例对象、合计容量：<code>jmap -histo</code></li>
<li>以ClassLoader为统计口径显示永久代内存状态，只在Linux/Solaris平台有效：<code>jmap permstat</code></li>
</ul>
<hr>
<h2 id="JHat"><a href="#JHat" class="headerlink" title="JHat"></a>JHat</h2><p>jhatzhuanch （JVM Heap Analyisi Tool），虚拟机堆转储快照分析工具。</p>
<hr>
<h2 id="JStack"><a href="#JStack" class="headerlink" title="JStack"></a>JStack</h2><p>jstack（Stack Trace for Java），Java堆栈工具，用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内为每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。</p>
<p>线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待什么资源。</p>
<blockquote>
<p>jstack [ option ] &lt; vmid &gt;</p>
</blockquote>
<ul>
<li>当正常输出的请求不被响应是，强制输出线程堆栈：<code>jstack -F</code></li>
<li>除堆栈外，显示显示关于锁的附加信息：<code>jstack -l</code></li>
<li>如果调用本地方法，显示C/C++的堆栈：<code>jstack -m</code></li>
</ul>
<p>在JDK1.5中，java.lang.Thread新增了一个getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码就完成了jstack的大部分功能，在实际项目中可以调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈。</p>
<hr>
<h2 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h2><p>JConsole（Java Monitoring and Management Console），是一种基于JMX的可视化监视、管理工具。它管理部分的功能是针对JMX MBean进行管理，由于MBean可以使用代码、中间件服务器的管理控制台或者所有符合JMX规范的软件进行访问，所以重点是使用JConsole的监视功能。</p>
<hr>
<h2 id="JVisualVM"><a href="#JVisualVM" class="headerlink" title="JVisualVM"></a>JVisualVM</h2><p>JVisualVM（All-in-One Java Troubleshooting Tool），Java多合一故障处理工具。是目前为止随JDK发布的功能最强大的运行监视和故障处理程序，并且可以预见在未来一段时间内都是官方主力发展的虚拟机故障处理工具。而且还有很多高效的插件可以使用。</p>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/18/Git-常用命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/18/Git-常用命令/" itemprop="url">Git 常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-18T08:11:31+08:00">
                2015-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><ul>
<li>设置全局用户名：<code>git config --global user.name &lt;your-user-name&gt;</code></li>
<li>设置全局邮箱：<code>git config --global user.email &lt;your-email&gt;</code></li>
<li>查看全局设置：<code>git config --global --list</code></li>
<li>设置项目用户名：<code>git config user.name &lt;your-user-name&gt;</code></li>
<li>设置项目邮箱：<code>git config user.email &lt;your-email&gt;</code></li>
<li>查看项目设置：<code>git config --list</code></li>
</ul>
<hr>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li>查看Git状态：<code>git status</code></li>
<li>查看日志：<code>git log</code></li>
<li>查看常用帮助：<code>git help</code></li>
<li>查看全部帮助：<code>git help -a</code></li>
<li>查看某个命令帮助：<code>git help &lt;command-name&gt;</code></li>
<li>查看版本：<code>git --version</code></li>
</ul>
<hr>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>初始化：<code>git init</code></li>
<li>关联远程仓库：<code>git remote add origin &lt;git-url&gt;</code></li>
<li>克隆项目到本地：<code>git clone &lt;git-url&gt;</code></li>
</ul>
<hr>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><ul>
<li>更新：<code>git pull</code></li>
</ul>
<hr>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul>
<li>添加某个文件到版本控制中：<code>git add [dir-name/]&lt;file-name&gt;</code></li>
<li>添加某个文件夹到版本控制中：<code>git add &lt;dir-name&gt;</code></li>
<li>添加所有文件到版本控制中：<code>git add .</code></li>
<li>从版本控制中删除某个文件：<code>git rm [dir-name/]&lt;file-name&gt;</code></li>
<li>提交修改：<code>git commit -m &quot;&lt;your-commit-note&gt;&quot;</code></li>
<li>推送到远程仓库：<code>git push [origin master]</code></li>
</ul>
<hr>
<h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><blockquote>
<p><strong>工作目录</strong>：git clone 后获得的一份本地的代码，也包括新编辑的，尚未加入版本控制的代码;<br><strong>暂存区域</strong>：git add 后暂存起来，尚未 git commit 的代码;<br><strong>本地仓库</strong>：git commit 后正式被版本控制记录起来的代码；</p>
</blockquote>
<ul>
<li>查看工作目录和暂存区域区别：<code>git diff</code></li>
<li>查看暂存区域和本地仓库区别：<code>git diff --staged</code> <code>git diff --cached</code></li>
</ul>
<hr>
<h3 id="取消修改"><a href="#取消修改" class="headerlink" title="取消修改"></a>取消修改</h3><ul>
<li>取消尚未add的修改：<code>git checkout -- &lt;file-name&gt;</code></li>
<li>取消已经add到未commit的修改：<code>git reset HEAD &lt;file-name&gt;</code></li>
<li>覆盖上次提交，用于已commit：<code>git commit --amend</code></li>
<li>撤销本地commit(回滚到某次commit): <code>git log</code> + <code>git reset [--hard] &lt;commit-id&gt;</code></li>
</ul>
<hr>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="http://pm.readthedocs.org/zh_CN/latest/vcs/git/usage.html" target="_blank" rel="external">Git常用命令：程序员的场景</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的网站：Git教程</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/15/Java-类初始化顺序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/15/Java-类初始化顺序/" itemprop="url">Java 类初始化顺序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-15T23:18:59+08:00">
                2015-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>这几天看java单例模式的时候，对类的加载机制和初始化顺序产生了疑问。于是在OSC发了一个技术贴<a href="http://www.oschina.net/question/2273217_217864?p=1#AnchorAnswer877680" target="_blank" rel="external">关于java内部类加载顺序的问题</a>,现在综合大家的回答总结下。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2015/08/15/Java-类初始化顺序/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/14/为何我从虾米转向网易云音乐/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/14/为何我从虾米转向网易云音乐/" itemprop="url">为何我从虾米转向网易云音乐</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-14T20:22:19+08:00">
                2015-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于音乐播放器,我自认为还是有点要求的.先说说自己对音乐播放器的要求吧.</p>
<blockquote>
<ul>
<li>界面必须要美观简洁;</li>
<li>操作要一目了然,没有各种杂项功能;</li>
<li>歌曲资源库要足够丰富;</li>
<li>必须有提供漫游类似歌曲的功能;</li>
<li>全平台同步;</li>
<li>功能稳定;</li>
</ul>
</blockquote>
<p>大概需求就这么多.先说一下为什么不用像酷狗和酷我这几款很大众的播放器,其实原因也很简单-不够喜欢.因为界面不足以吸引我,然后歌曲库质量良莠不全,搜歌的代价相比之下大不少.至于另外一个大众皆知的播放器- QQ 音乐.其实说真的, QQ音乐的 PC 和 Mac 版本做的真的一般,界面就不说了,有时候带着耳机想选个音质好点的,可以啊,充绿钻啊!顿时无语.关于腾讯的产品,其实大部分做的在行业来说都是算前列的,只是个人有个不好的习惯—只要有足够能力替代腾讯产品的,我都有优先考虑非腾讯系.</p>
<p>下面来说说虾米和网易云音乐吧.</p>
<h3 id="1-虾米"><a href="#1-虾米" class="headerlink" title="1. 虾米"></a>1. 虾米</h3><p><img src="https://farm1.staticflickr.com/461/19350232794_23b34477a7_n.jpg" alt=""></p>
<p>我应该算是比较早使用虾米的一批用户了,那时候阿里还没有收购虾米.当初为何选择虾米,只因为一个最吸引我的功能—查找类似的歌曲,这对于我这种没有很大动力去关注歌手和专辑的人说,简直是一个福音.每次听到自己喜欢的歌曲,都会很自然去点击下”寻找类似歌曲”, 而结果也往往能发现很多不错的歌曲是适合自己的.而且那时候虾米还有电台,质量还是非常高的(对比酷狗等),所以第一次用过之后就一直用虾米了,包括 PC 和 Android, iPhone.</p>
<p>可是最近却慢慢觉得虾米做的越来越不好了.</p>
<blockquote>
<ul>
<li><p>收藏的歌曲有很大的概率不能播放.最近播放收藏列表的时候,经常会出现这种情况:可以播放前面几首歌曲,但是播了几首之后,后面的歌曲一首接着一首被跳过,几乎跳过了收藏列表后面的所有歌曲.然后整个播放器就停止了.而且,而且,还没有任何提示.就算是因为版权问题下架了歌曲,也应该给个提示吧.这是我放弃虾米最重要的原因之一.</p>
</li>
<li><p>Android 端不能登录.这是年前还是用 Nexus5的时候,那时候更新了虾米后,死活登录不上去,导致我无法听歌.我们也知道虾米没有登录是不能播放歌曲的,那时候也知道可能是这个版本的问题,应该很快就可以修复的.但是虾米出现这么严重的问题,我也开始觉得这个产品越来越不用心了.好感度递减.</p>
</li>
</ul>
</blockquote>
<p>由于多次经受第一个问题的困扰,最终我决定更换自己使用了2年多的播放器了.</p>
<h3 id="2-网易云音乐"><a href="#2-网易云音乐" class="headerlink" title="2. 网易云音乐"></a>2. 网易云音乐</h3><p><img src="https://farm4.staticflickr.com/3733/19965276302_1ed3f3fc56_o.jpg" alt=""></p>
<p>其实之前也用过网易云音乐,初体验总体感觉体验不错,包括界面,操作,资源等.但是由于自己的收藏都是在虾米那边,也就一直没有考虑过转过来.自从有了换播放器的想法之后,第一反应就是网易云音乐.</p>
<blockquote>
<ul>
<li>开题的需求基本满足;</li>
<li>对于网易的产品,我一直都觉得还是比较良心的.比如有道词典,有道云笔记等,一直对网易的印象不错,所以对网易云音乐有信心,产品的迭代和更新应该都会比较及时,这也是我选择它最重要的原因;</li>
<li>网易云音乐的社交功能还是蛮有兴趣,可以看见别人分享的音乐,体验起来效果不错.这个是虾米也没有的;</li>
<li>最后一个,其实不是虾米的错.虾米无法分享音乐到朋友圈.有时候自己有某个特别喜欢的歌曲,总想分享到朋友圈让大家听听.然后因为腾讯和阿里的关系,虾米躺枪了.而网易云音乐没有这个困扰.</li>
</ul>
</blockquote>
<p>鉴于上面的原因,我最终决定放弃虾米,转向网易云音乐. iPhone 和 Mac上 会首先替换,接着也会把收藏的歌曲转过来.</p>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg"
               alt="archerda" />
          <p class="site-author-name" itemprop="name">archerda</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">55</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/archerda" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">archerda</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
