<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="archerda, ArcherdaArcherda's BlogHexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Archerda&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Archerda&#39;s Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Archerda&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>Archerda's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Archerda's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Programmer. Meditating.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/23/Java集合系列-3-LinkedList分析与源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/23/Java集合系列-3-LinkedList分析与源码解析/" itemprop="url">Java集合系列[3]-LinkedList分析与源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-23T23:47:45+08:00">
                2016-08-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前介绍了 <a href="http://archerda.github.io/2016/08/20/Java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B9%8BArrayList%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">ArrayList</a> 的整体架构。接下来我们来继续看List的另一个实现 <strong>LinkedList</strong>。主要分为以下部分：</p>
<ul>
<li>第一部分 AbstractSequentialList简介</li>
<li>第二部分 LinkedList简介</li>
<li>第三部分 数据结构分析</li>
<li>第四部分 源码分析</li>
<li>第五部分 遍历方式</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/08/23/Java集合系列-3-LinkedList分析与源码解析/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/20/Java集合系列-2-ArrayList分析与源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/20/Java集合系列-2-ArrayList分析与源码解析/" itemprop="url">Java集合系列[2]-ArrayList分析与源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-20T12:44:22+08:00">
                2016-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前介绍了 <a href="http://archerda.github.io/2016/08/17/Java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97-Collection%E6%A1%86%E6%9E%B6/" target="_blank" rel="external">Collection</a> 的整体架构。本文将通过Collection的具体类来加深理解。首先我们来看List，而ArrayList是List中最常用的，所以我们从他下手。主要分为以下部分：</p>
<ul>
<li>第一部分 简介</li>
<li>第二部分 数据结构分析</li>
<li>第三部分 源码分析</li>
<li>第四部分 遍历方式</li>
<li>第五部分 toArray()异常</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/08/20/Java集合系列-2-ArrayList分析与源码解析/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/17/Java集合系列-1-Collection框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/17/Java集合系列-1-Collection框架/" itemprop="url">Java集合系列[1]-Collection框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-17T23:31:17+08:00">
                2016-08-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>下图是Collection框架的类关系图：<br><img src="http://obmtcynvx.bkt.clouddn.com/32143ljfdoa9ufd.png" alt="Collection架构图"></p>
<p>Collection是一个接口，主要有2个分支，分别是<strong>List</strong>和<strong>Set</strong>。List和Set都是接口，他们都继承自Collection接口。List是有序队列，可以有重复元素；Set是数学概念中的集合，无序的，也是没有重复元素的（数学上的集合有三个特征：无序性、互异性、确定性）。</p>
<p>为了方便，JDK抽象出了AbstractCollection抽象类，它实现了Collection接口中大部分方法。这样在Collection的实现类中，就可以通过集成AbstractCollection省去了很多重复的编码工作。AbstractList和AbstractSet都继承自AbstractCollection，具体的List实现类继承自AbstractList（例如ArrayList、LinkedList、Vector、Stack等），而具体的Set实现类继承自AbstractSet（例如HashSet、TreeSet等）。</p>
<p>另外，Collection还继承Iterable接口，里面有一个iterator()方法，它返回Iterator接口。通常，我们可以通过Iterator迭代器来遍历集合。ListLiterator接口是List接口特有的，在List接口中，通过调用listIterator()返回一个ListIterator迭代器对象。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/08/17/Java集合系列-1-Collection框架/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/03/12/repost-淘宝大秒系统设计详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/12/repost-淘宝大秒系统设计详解/" itemprop="url">【Repost】淘宝大秒系统设计详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-12T20:45:56+08:00">
                2016-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <center><a href="http://toutiao.com/i6260281405876470273/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">淘宝大秒系统设计详解</a></center>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/03/02/Vim命令图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/02/Vim命令图/" itemprop="url">Vim命令图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-02T22:50:20+08:00">
                2016-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://c2.staticflickr.com/2/1524/25323931442_6bed1f3402_h.jpg" alt="Vim命令图"></p>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/02/28/多线程带来的风险/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/28/多线程带来的风险/" itemprop="url">多线程带来的风险</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-28T16:45:22+08:00">
                2016-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java对线程的支持其实是一把双刃剑。如果使用得当，线程可以有效的降低程序的开发和维护成本，同时提升复杂应用的性能。优点如下：</p>
<ol>
<li>发挥多处理器的能力，提高系统吞吐率</li>
<li>简化建模（例如Servlet和RMI远程方法调用）：<br>复杂工作简化为一组简单的并且同步的工作流，每个工作流在单独的线程中运行，并在特定的地方进行交互。</li>
<li>简化异步事件处理</li>
<li>更灵敏的用户响应界面</li>
</ol>
<p>然而，线程也带来了一些额外的问题。</p>
<hr>
<h2 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h2><p>安全性的含义是“<strong>永远不发生糟糕的事情</strong>”。</p>
<p>看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 非线程安全的数值序列生成器</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeSequence</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line">    </div><div class="line">    <span class="comment">// 返回一个唯一的数值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在单线程的环境中，这个类可以正常工作，产生正确的结果，但是在多线程的则不能。</p>
<p>UnsafeSequence的问题在于，如果执行的时间不对，那么两个线程在调用getNext方法时会得到相同的值。看下图：<br><img src="https://c2.staticflickr.com/2/1569/25332170365_376ceec88c.jpg" alt=""><br>这种错误出现的情况是：虽然 <strong>value++</strong> 看上去是一个原子操作，但事实上它包含了3个操作：读取value、将value的值+1、将结果写入value。由于运行的时候多个线程存在交替执行的情况，因此这两个线程可能同时执行读操作，从而使它们得到相同的值。结果也就是不同的线程的调用返回了相同的值，而这不是我们想要的结果。</p>
<p>这是一个并发安全问题，称为 <strong>竞态条件(Race Condition)</strong> 。在多线程环境下，getNext是否会返回唯一的数值，要取决于运行时对线程中操作的交替执行方式，这显然不正确。</p>
<p>由于多个线程要共享相同的内存地址空间，并且是并发操作，因此它们可能会访问或修改其他线程正在使用的变量。当然，这是一种极大的便利，因为这种方式比其他线程间通讯机制更容易实现数据共享。但是它同样带来了巨大的风险：线程由于无法预料数据变化而发生错误，当多个线程同时访问或修改相同的变量时，将会在串行编程模型中引入非串行因素，而非串行性是很难分析的。<strong>要使多线程程序的行为进行预测，必须对共享变量的访问操作进行协同</strong>，这样才不会在线程之间发生干扰。幸运的是，Java提供了各种同步机制来协同这种访问。</p>
<p>看下面代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 线程安全的数值序列生成器</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeSequence</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line">    </div><div class="line">    <span class="comment">// 返回一个唯一的数值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们将getNext修改为一个同步的方法，修复竟态条件问题。</p>
<p>在开发并发代码时，一定要注意 <strong>线程安全性是不可破坏的</strong>。</p>
<hr>
<h2 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h2><p>活跃性的含义是“<strong>某件正确的事情一定会发生</strong>”。</p>
<p>当某个操作无法继续执行下去的时候，就会发生活跃性问题。在串行程序中，活跃性问题就是无意中造成的无限循环，从而使得循环之后的代码无法得到执行。线程将带来其他一些活跃性问题。</p>
<p>比如，线程A在等待线程B释放所持用的资源，而线程B永远都不释放持有的资源，那么A就会永久地等下去。就是一种 <strong>饥饿</strong>现象，除此之外还有死锁以及活锁。</p>
<p>与大多数并发性错误一样，导致活跃性问题的错误同样是难以分析的，因为它们依赖于不同线程时间发生的时序。</p>
<hr>
<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>性能问题的含义是“<strong>正确的事情能尽快发生</strong>”。</p>
<p>活跃性意味着某件正确的事情最终一定会发生，但却不够好，因为我们同城希望正确的事情尽快发生。性能问题包括多个方面，例如服务时间过长、响应不灵敏、吞吐率过低、资源消耗过高、可伸缩性较低等。</p>
<p>在设计良好的并发应用程序中，线程能提升程序的性能。但无论如何，线程总会带来某种程度的运行时开销。在多线程程序中，但线程调度器临时挂起并转而运行另一个线程时，就会频繁地出现 <strong>上下文切换（Context Switch）</strong>，这种操作将带来极大的开销。当线程共享数据时，必须使用同步机制，而这些同步机制往往会压抑某些编译器优化，使内存缓冲区中的数据无效，以及增加共享内存总线的同步流量。所有这些操作都将带来额外开销。</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li>《Java并发编程实战》Brain Goetz等著 机械工业出版社</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/24/编程之法-字符串的旋转/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/24/编程之法-字符串的旋转/" itemprop="url">编程之法-字符串的旋转</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-24T00:08:25+08:00">
                2015-12-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个字符串，要求将字符串前面的若干个字符移到字符串的尾部。例如，将字符串“abcdef”的前三个字母‘a’、‘b’和‘c’移到字符串的尾部，那么原字符串将编程“defabc”。请编写一个函数实现此功能。</p>
<h2 id="解法一：蛮力移位"><a href="#解法一：蛮力移位" class="headerlink" title="解法一：蛮力移位"></a>解法一：蛮力移位</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将需要移动的字符一个一个地移动到字符的最后。编写一个leftShiftOne方法，每次将一个字符移动到字符串尾部，然后调用m次这个方法，使得字符串开头的m个字符移到字符串的尾部。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">char</span>[] s = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>&#125;;</div><div class="line">		leftShiftString(s, s.length, <span class="number">3</span>);</div><div class="line">		System.out.println(s);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//移动首部m位字符到最后</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftShiftString</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span> (m &gt; <span class="number">0</span>) &#123;</div><div class="line">			leftShiftOne(s, n);</div><div class="line">			--m;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//移动首位字符到最后</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftShiftOne</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">		<span class="keyword">char</span> t = s[<span class="number">0</span>];</div><div class="line">		</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</div><div class="line">			s[i - <span class="number">1</span>] = s[i];</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		s[n - <span class="number">1</span>] = t;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>针对长度为n的字符串来说，假设需要移动m个字符到字符串的末尾，那么总共需要m*n次操作，同时设立一个变量保存第一个字符。因此时间复杂度是<code>O(mn)</code>, 空间复杂度是<code>O(1)</code>。</p>
<h2 id="解法二：三步反转"><a href="#解法二：三步反转" class="headerlink" title="解法二：三步反转"></a>解法二：三步反转</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>先将一个字符串分割成两个部分，然后将这两个部分的字符串分别反转，最后再对整个字符串整体反转（即三步反转），即可解决字符串旋转的问题。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">char</span>[] s = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>&#125;;</div><div class="line">		leftRotateString(s, s.length, <span class="number">3</span>);</div><div class="line">		System.out.println(s);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//字符串旋转</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftRotateString</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</div><div class="line">		m %= n; <span class="comment">//若要左移动大于n位，那么与移动%n是等价的;</span></div><div class="line">		reverseString(s, <span class="number">0</span>, m - <span class="number">1</span>);</div><div class="line">		reverseString(s, m, n - <span class="number">1</span>);</div><div class="line">		reverseString(s, <span class="number">0</span>, n - <span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//字符串反转</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span> (from &lt; to) &#123;</div><div class="line">			<span class="keyword">char</span> t = s[from];</div><div class="line">			s[from++] = s[to];</div><div class="line">			s[to--] = t;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这个方法的时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code>。</p>
<h2 id="举一反三：单词反转"><a href="#举一反三：单词反转" class="headerlink" title="举一反三：单词反转"></a>举一反三：单词反转</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入一个英文句子，翻转句子中单词的顺序。要求单词内字符的顺序保持不变，句子中单词以空格隔开。为简单起见，标点符号和普通字符一样处理。例如，若输入”I am a student.”，则输出”student. a am I”.</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>先反转每一个单词，再反转整个字符串。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		String str = <span class="string">"My name is luohuida!"</span>;</div><div class="line">		<span class="keyword">char</span>[] chs = leftRotateString(str.toCharArray(), str.length());</div><div class="line">		System.out.println(chs);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//单词翻转</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] leftRotateString(<span class="keyword">char</span>[] s, <span class="keyword">int</span> n) &#123;</div><div class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">		</div><div class="line">		<span class="comment">//先翻转每个单词</span></div><div class="line">		<span class="keyword">for</span> (; j &lt; n; ++j) &#123;</div><div class="line">			<span class="keyword">if</span> (j == n - <span class="number">1</span> || s[j+<span class="number">1</span>] == <span class="string">' '</span>) &#123;</div><div class="line">				reverseString(s, i, j);</div><div class="line">				i = j + <span class="number">2</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		reverseString(s, <span class="number">0</span>, n - <span class="number">1</span>);</div><div class="line"></div><div class="line">		<span class="keyword">return</span> s;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//字符串反转</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span> (from &lt; to) &#123;</div><div class="line">			<span class="keyword">char</span> t = s[from];</div><div class="line">			s[from++] = s[to];</div><div class="line">			s[to--] = t;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>时间复杂度<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="">《编程之法》</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/05/设计模式-六大设计原则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/05/设计模式-六大设计原则/" itemprop="url">【Repost】设计模式-六大设计原则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-05T17:30:36+08:00">
                2015-12-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文转载自<a href="http://www.devtf.cn/?p=1134" target="_blank" rel="external">开发技术前线：面向对象六大原则</a><br>本文转载自<a href="http://www.devtf.cn/?p=1134" target="_blank" rel="external">开发技术前线：面向对象六大原则</a><br>本文转载自<a href="http://www.devtf.cn/?p=1134" target="_blank" rel="external">开发技术前线：面向对象六大原则</a></p>
<h2 id="优化代码的第一步——单一职责原则"><a href="#优化代码的第一步——单一职责原则" class="headerlink" title="优化代码的第一步——单一职责原则"></a>优化代码的第一步——单一职责原则</h2><p>单一职责原则的英文名称是Single Responsibility Principle，简称SRP。它的定义是：就一个类而言，应该仅有一个引起它变化的原因。简单来说，一个类中应该是一组相关性很高的函数、数据的封装。就像秦小波老师在《设计模式之禅》中说的：“这是一个备受争议却又及其重要的原则。只要你想和别人争执、怄气或者是吵架，这个原则是屡试不爽的”。因为单一职责的划分界限并不是总是那么清晰，很多时候都是需要靠个人经验来界定。当然，最大的问题就是对职责的定义，什么是类的职责，以及怎么划分类的职责。<br>对于计算机技术，通常只单纯地学习理论知识并不能很好地领会其深意，只有自己动手实践，并在实际运用中发现问题、解决问题、思考问题，才能够将知识吸收到自己的脑海中。下面以我的朋友小民的事迹说起。</p>
<p>自从Android系统发布以来，小民就是Android的铁杆粉丝，于是在大学期间一直保持着对Android的关注，并且利用课余时间做些小项目，锻炼自己的实战能力。毕业后，小民如愿地加入了心仪的公司，并且投入到了他热爱的Android应用开发行业中。将爱好、生活、事业融为一体，小民的第一份工作也算是顺风顺水，一切尽在掌握中。<br>在经历过一周的适应期以及熟悉公司的产品、开发规范之后，小民的开发工作就正式开始了。小民的主管是个工作经验丰富的技术专家，对于小民的工作并不是很满意，尤其小民最薄弱的面向对象设计，而Android开发又是使用Java语言，什么抽象、接口、六大原则、23种设计模式等名词把小民弄得晕头转向。小民自己也察觉到了自己的问题所在，于是，小民的主管决定先让小民做一个小项目来锻炼锻炼这方面的能力。正所谓养兵千日用兵一时，磨刀不误砍柴工，小民的开发之路才刚刚开始。</p>
<p>在经过一番思考之后，主管挑选了使用范围广、难度也适中的ImageLoader（图片加载）作为小民的训练项目。既然要训练小民的面向对象设计，那么就必须考虑到可扩展性、灵活性，而检测这一切是否符合需求的最好途径就是开源。用户不断地提出需求、反馈问题，小民的项目需要不断升级以满足用户需求，并且要保证系统的稳定性、灵活性。在主管跟小民说了这一特殊任务之后，小民第一次感到了压力，“生活不容易呐！”年仅22岁至今未婚的小民发出了如此深刻的感叹！</p>
<p>挑战总是要面对的，何况是从来不服输的小民。主管的要求很简单，要小民实现图片加载，并且要将图片缓存起来。在分析了需求之后，小民一下就放心下来了，“这么简单，原来我还以为很难呢……”小民胸有成足的喃喃自语。在经历了十分钟的编码之后，小民写下了如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 图片加载类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 图片缓存</span></div><div class="line">    LruCache&lt;String, Bitmap&gt; mImageCache;</div><div class="line">    <span class="comment">// 线程池,线程数量为CPU的数量</span></div><div class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool (Runtime.getRuntime().availableProcessors());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageLoader</span><span class="params">()</span> </span>&#123;</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initImageCache</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// 计算可使用的最大内存</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</div><div class="line">            <span class="comment">// 取四分之一的可用内存作为缓存</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cacheSize = maxMemory / <span class="number">4</span>;</div><div class="line">        mImageCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> bitmap.getRowBytes() * bitmap.getHeight() / <span class="number">1024</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;                   </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</div><div class="line">        imageView.setTag(url);</div><div class="line">        mExecutorService.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">           <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">              Bitmap bitmap = downloadImage(url);</div><div class="line">                <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">              &#125;</div><div class="line">                <span class="keyword">if</span> (imageView.getTag().equals(url)) &#123;</div><div class="line">                    imageView.setImageBitmap(bitmap);</div><div class="line">              &#125;</div><div class="line">                mImageCache.put(url, bitmap);</div><div class="line">          &#125;</div><div class="line">       &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span>  Bitmap <span class="title">downloadImage</span><span class="params">(String imageUrl)</span> </span>&#123;</div><div class="line">        Bitmap bitmap = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          URL url = newURL(imageUrl);</div><div class="line">            <span class="keyword">final</span> HttpURLConnection conn = (HttpURLConnection) </div><div class="line">                            url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> bitmap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>并且使用git软件进行版本控制，将工程托管到github上，伴随着git push命令的完成，小民的ImageLoader 0.1版本就正式发布了！如此短的时间内就完成了这个任务，而且还是一个开源项目，小民暗暗自喜，幻想着待会儿主管的称赞。</p>
<p>在小民给主管报告了ImageLoader的发布消息的几分钟之后，主管就把小民叫到了会议室。这下小民纳闷了，怎么夸人还需要到会议室。“小民，你的ImageLoader耦合太严重啦！简直就没有设计可言，更不要说扩展性、灵活性了。所有的功能都写在一个类里怎么行呢，这样随着功能的增多，ImageLoader类会越来越大，代码也越来越复杂，图片加载系统就越来越脆弱……”Duang，这简直就是当头棒喝，小民的脑海里已经听不清主管下面说的内容了，只是觉得自己之前没有考虑清楚就匆匆忙忙完成任务，而且把任务想得太简单了。</p>
<p>“你还是把ImageLoader拆分一下，把各个功能独立出来，让它们满足单一职责原则。”主管最后说道。小民是个聪明人，敏锐地捕捉到了单一职责原则这个关键词。用Google搜索了一些优秀资料之后总算是对单一职责原则有了一些认识。于是打算对ImageLoader进行一次重构。这次小民不敢过于草率，也是先画了一幅UML图，如图1-1所示。<br><img src="http://img.blog.csdn.net/20151101112108511" alt="图1-1"><br>ImageLoader代码修改如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 图片加载类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 图片缓存</span></div><div class="line">    ImageCache mImageCache = <span class="keyword">new</span> ImageCache() ;</div><div class="line">    <span class="comment">// 线程池,线程数量为CPU的数量</span></div><div class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool (Runtime.getRuntime().availableProcessors());</div><div class="line"> </div><div class="line">    <span class="comment">// 加载图片</span></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</div><div class="line">        Bitmap bitmap = mImageCache.get(url);</div><div class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">            imageView.setImageBitmap(bitmap);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        imageView.setTag(url);</div><div class="line">        mExecutorService.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"> </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            Bitmap bitmap = downloadImage(url);</div><div class="line">                <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (imageView.getTag().equals(url)) &#123;</div><div class="line">                    imageView.setImageBitmap(bitmap);</div><div class="line">                &#125;</div><div class="line">                mImageCache.put(url, bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">     &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span>  Bitmap <span class="title">downloadImage</span><span class="params">(String imageUrl)</span> </span>&#123;</div><div class="line">        Bitmap bitmap = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">           URL url = <span class="keyword">new</span> URL(imageUrl);</div><div class="line">            <span class="keyword">final</span> HttpURLConnection conn = (HttpURLConnection) </div><div class="line">                        url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bitmap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>并且添加了一个ImageCache类用于处理图片缓存，具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageCache</span> </span>&#123;</div><div class="line">    <span class="comment">// 图片LRU缓存</span></div><div class="line">    LruCache&lt;String, Bitmap&gt; mImageCache;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageCache</span><span class="params">()</span> </span>&#123;</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initImageCache</span><span class="params">()</span> </span>&#123;</div><div class="line">         <span class="comment">// 计算可使用的最大内存</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</div><div class="line">        <span class="comment">// 取四分之一的可用内存作为缓存</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cacheSize = maxMemory / <span class="number">4</span>;</div><div class="line">        mImageCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> bitmap.getRowBytes() * bitmap.getHeight() / <span class="number">1024</span>;</div><div class="line">           &#125;</div><div class="line">        &#125;;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bitmap)</span> </span>&#123;</div><div class="line">        mImageCache.put(url, bitmap) ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mImageCache.get(url) ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如图1-1和上述代码所示，小民将ImageLoader一拆为二，ImageLoader只负责图片加载的逻辑，而ImageCache只负责处理图片缓存的逻辑，这样ImageLoader的代码量变少了，职责也清晰了，当与缓存相关的逻辑需要改变时，不需要修改ImageLoader类，而图片加载的逻辑需要修改时也不会影响到缓存处理逻辑。主管在审核了小民的第一次重构之后，对小民的工作给予了表扬，大致意思是结构变得清晰了许多，但是可扩展性还是比较欠缺，虽然没有得到主管的完全肯定，但也是颇有进步，再考虑到自己确实有所收获，小民原本沮丧的心里也略微地好转起来。</p>
<p>从上述的例子中我们能够体会到，单一职责所表达出的用意就是“单一”二字。正如上文所说，如何划分一个类、一个函数的职责，每个人都有自己的看法，这需要根据个人经验、具体的业务逻辑而定。但是，它也有一些基本的指导原则，例如，两个完全不一样的功能就不应该放在一个类中。一个类中应该是一组相关性很高的函数、数据的封装。工程师可以不断地审视自己的代码，根据具体的业务、功能对类进行相应的拆分，我想这会是你优化代码迈出的第一步。</p>
<h2 id="让程序更稳定、更灵活——开闭原则"><a href="#让程序更稳定、更灵活——开闭原则" class="headerlink" title="让程序更稳定、更灵活——开闭原则"></a>让程序更稳定、更灵活——开闭原则</h2><p>开闭原则的英文全称是Open Close Principle，简称OCP，它是Java世界里最基础的设计原则，它指导我们如何建立一个稳定的、灵活的系统。开闭原则的定义是：软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是，对于修改是封闭的。在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会将错误引入原本已经经过测试的旧代码中，破坏原有系统。因此，当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。当然，在现实开发中，只通过继承的方式来升级、维护原有系统只是一个理想化的愿景，因此，在实际的开发过程中，修改原有代码、扩展代码往往是同时存在的。</p>
<p>软件开发过程中，最不会变化的就是变化本身。产品需要不断地升级、维护，没有一个产品从第一版本开发完就再没有变化了，除非在下个版本诞生之前它已经被终止。而产品需要升级，修改原来的代码就可能会引发其他的问题。那么如何确保原有软件模块的正确性，以及尽量少地影响原有模块，答案就是尽量遵守本章要讲述的开闭原则。</p>
<p>勃兰特·梅耶在1988年出版的《面向对象软件构造》一书中提出这一原则。这一想法认为，一旦完成，一个类的实现只应该因错误而被修改，新的或者改变的特性应该通过新建不同的类实现。新建的类可以通过继承的方式来重用原类的代码。显然，梅耶的定义提倡实现继承，已存在的实现对于修改是封闭的，但是新的实现类可以通过覆写父类的接口应对变化。<br>说了这么多，想必大家还是半懂不懂，还是让我们以一个简单示例说明一下吧。</p>
<p>在对ImageLoader进行了一次重构之后，小民的这个开源库获得了一些用户。小民第一次感受到自己发明“轮子”的快感，对开源的热情也越发高涨起来！通过动手实现一些开源库来深入学习相关技术，不仅能够提升自我，也能更好地将这些技术运用到工作中，从而开发出更稳定、优秀的应用，这就是小民的真实想法。</p>
<p>小民第一轮重构之后的ImageLoader职责单一、结构清晰，不仅获得了主管的一点肯定，还得到了用户的夸奖，算是个不错的开始。随着用户的增多，有些问题也暴露出来了，小民的缓存系统就是大家“吐槽”最多的地方。通过内存缓存解决了每次从网络加载图片的问题，但是，Android应用的内存很有限，且具有易失性，即当应用重新启动之后，原来已经加载过的图片将会丢失，这样重启之后就需要重新下载！这又会导致加载缓慢、耗费用户流量的问题。小民考虑引入SD卡缓存，这样下载过的图片就会缓存到本地，即使重启应用也不需要重新下载了！小民在和主管讨论了该问题之后就投入了编程中，下面就是小民的代码。<br>DiskCache.java类，将图片缓存到SD卡中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskCache</span> </span>&#123;</div><div class="line">    <span class="comment">// 为了简单起见临时写个路径,在开发中请避免这种写法 !</span></div><div class="line">    <span class="keyword">static</span> String cacheDir = <span class="string">"sdcard/cache/"</span>;</div><div class="line">     <span class="comment">// 从缓存中获取图片</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> BitmapFactory.decodeFile(cacheDir + url);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将图片缓存到内存中</span></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">       FileOutputStream fileOutputStream = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            fileOutputStream = <span class="keyword">new</span> FileOutputStream(cacheDir + url);</div><div class="line">            bmp.compress(CompressFormat.PNG, <span class="number">100</span>, fileOutputStream);</div><div class="line">      &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">      &#125; <span class="keyword">final</span> ly &#123;</div><div class="line">            <span class="keyword">if</span> (fileOutputStream != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    fileOutputStream.close();</div><div class="line">              &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">             &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为需要将图片缓存到SD卡中，所以，ImageLoader代码有所更新，具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 内存缓存</span></div><div class="line">    ImageCache mImageCache = <span class="keyword">new</span> ImageCache();</div><div class="line">    <span class="comment">// SD卡缓存</span></div><div class="line">    DiskCache mDiskCache = <span class="keyword">new</span> DiskCache();</div><div class="line">    <span class="comment">// 是否使用SD卡缓存</span></div><div class="line">    <span class="keyword">boolean</span> isUseDiskCache = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 线程池,线程数量为CPU的数量</span></div><div class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool (Runtime.getRuntime().availableProcessors());</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</div><div class="line">        <span class="comment">// 判断使用哪种缓存</span></div><div class="line">       Bitmap bitmap = isUseDiskCache ? mDiskCache.get(url) </div><div class="line">                : mImageCache.get (url);</div><div class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">            imageView.setImageBitmap(bitmap);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">        <span class="comment">// 没有缓存，则提交给线程池进行下载</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useDiskCache</span><span class="params">(<span class="keyword">boolean</span> useDiskCache)</span> </span>&#123;</div><div class="line">        isUseDiskCache = useDiskCache ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上述的代码中可以看到，仅仅新增了一个DiskCache类和往ImageLoader类中加入了少量代码就添加了SD卡缓存的功能，用户可以通过useDiskCache方法来对使用哪种缓存进行设置，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ImageLoader imageLoader = <span class="keyword">new</span> ImageLoader() ;</div><div class="line"> <span class="comment">// 使用SD卡缓存</span></div><div class="line">imageLoader.useDiskCache(<span class="keyword">true</span>);</div><div class="line"><span class="comment">// 使用内存缓存</span></div><div class="line">imageLoader.useDiskCache(<span class="keyword">false</span>);</div></pre></td></tr></table></figure></p>
<p>通过useDiskCache方法可以让用户设置不同的缓存，非常方便啊！小民对此很满意，于是提交给主管做代码审核。“小民，你思路是对的，但是有些明显的问题，就是使用内存缓存时用户就不能使用SD卡缓存，类似的，使用SD卡缓存时用户就不能使用内存缓存。用户需要这两种策略的综合，首先缓存优先使用内存缓存，如果内存缓存没有图片再使用SD卡缓存，如果SD卡中也没有图片最后才从网络上获取，这才是最好的缓存策略。”主管真是一针见血，小民这时才如梦初醒，刚才还得意洋洋的脸上突然有些泛红……<br>于是小民按照主管的指点新建了一个双缓存类DoudleCache，具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 双缓存。获取图片时先从内存缓存中获取，如果内存中没有缓存该图片，再从SD卡中获取。</div><div class="line"> *  缓存图片也是在内存和SD卡中都缓存一份</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCache</span> </span>&#123;</div><div class="line">    ImageCache mMemoryCache = <span class="keyword">new</span> ImageCache();</div><div class="line">    DiskCache mDiskCache = <span class="keyword">new</span> DiskCache();</div><div class="line"> </div><div class="line">    <span class="comment">// 先从内存缓存中获取图片，如果没有，再从SD卡中获取</span></div><div class="line">    <span class="function"><span class="keyword">public</span>   Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">       Bitmap bitmap = mMemoryCache.get(url);</div><div class="line">        <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</div><div class="line">            bitmap = mDiskCache.get(url);</div><div class="line">       &#125;</div><div class="line">        <span class="keyword">return</span>  bitmap;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">// 将图片缓存到内存和SD卡中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">        mMemoryCache.put(url, bmp);</div><div class="line">        mDiskCache.put(url, bmp);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们再看看最新的ImageLoader类吧，代码更新也不多：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 内存缓存</span></div><div class="line">    ImageCache mImageCache = <span class="keyword">new</span> ImageCache();</div><div class="line">    <span class="comment">// SD卡缓存</span></div><div class="line">    DiskCache mDiskCache = <span class="keyword">new</span> DiskCache();</div><div class="line">    <span class="comment">// 双缓存</span></div><div class="line">    DoubleCache mDoubleCache = <span class="keyword">new</span> DoubleCache() ;</div><div class="line">    <span class="comment">// 使用SD卡缓存</span></div><div class="line">    <span class="keyword">boolean</span> isUseDiskCache = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 使用双缓存</span></div><div class="line">    <span class="keyword">boolean</span> isUseDoubleCache = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 线程池,线程数量为CPU的数量</span></div><div class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool (Runtime.getRuntime().availableProcessors());</div><div class="line"> </div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</div><div class="line">        Bitmap bmp = <span class="keyword">null</span>;</div><div class="line">         <span class="keyword">if</span> (isUseDoubleCache) &#123;</div><div class="line">            bmp = mDoubleCache.get(url);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUseDiskCache) &#123;</div><div class="line">            bmp = mDiskCache.get(url);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            bmp = mImageCache.get(url);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">         <span class="keyword">if</span> ( bmp != <span class="keyword">null</span> ) &#123;</div><div class="line">            imageView.setImageBitmap(bmp);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 没有缓存，则提交给线程池进行异步下载图片</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useDiskCache</span><span class="params">(<span class="keyword">boolean</span> useDiskCache)</span> </span>&#123;</div><div class="line">        isUseDiskCache = useDiskCache ;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useDoubleCache</span><span class="params">(<span class="keyword">boolean</span> useDoubleCache)</span> </span>&#123;</div><div class="line">        isUseDoubleCache = useDoubleCache ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过增加短短几句代码和几处修改就完成了如此重要的功能。小民已越发觉得自己Android开发已经到了的得心应手的境地，不仅感觉一阵春风袭来，他那飘逸的头发一下从他的眼前拂过，小民感觉今天天空比往常敞亮许多。</p>
<p>“小民，你每次加新的缓存方法时都要修改原来的代码，这样很可能会引入Bug，而且会使原来的代码逻辑变得越来越复杂，按照你这样的方法实现，用户也不能自定义缓存实现呀！”到底是主管水平高，一语道出了小民这缓存设计上的问题。</p>
<p>我们还是来分析一下小民的程序，小民每次在程序中加入新的缓存实现时都需要修改ImageLoader类，然后通过一个布尔变量来让用户使用哪种缓存，因此，就使得在ImageLoader中存在各种if-else判断，通过这些判断来确定使用哪种缓存。随着这些逻辑的引入，代码变得越来越复杂、脆弱，如果小民一不小心写错了某个if条件（条件太多，这是很容易出现的），那就需要更多的时间来排除。整个ImageLoader类也会变得越来越臃肿。最重要的是用户不能自己实现缓存注入到ImageLoader中，可扩展性可是框架的最重要特性之一。</p>
<p>“软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的，这就是开放-关闭原则。也就是说，当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。”小民的主管补充到，小民听得云里雾里的。主管看小民这等反应，于是亲自“操刀”，为他画下了如图1-2的UML图。<br><img src="http://img.blog.csdn.net/20151101112846324" alt="图1-2"><br>小民看到图1-2似乎明白些什么，但是又不是太明确如何修改程序。主管看到小民这般模样只好亲自上阵，带着小民把ImageLoader程序按照图1-2进行了一次重构。具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 图片缓存</span></div><div class="line">    ImageCache mImageCache = <span class="keyword">new</span> MemoryCache();</div><div class="line">    <span class="comment">// 线程池,线程数量为CPU的数量</span></div><div class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool (Runtime.getRuntime().availableProcessors());</div><div class="line"> </div><div class="line">    <span class="comment">// 注入缓存实现</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageCache</span><span class="params">(ImageCache cache)</span> </span>&#123;</div><div class="line">        mImageCache = cache;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String imageUrl, ImageView imageView)</span> </span>&#123;</div><div class="line">        Bitmap bitmap = mImageCache.get(imageUrl);</div><div class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">            imageView.setImageBitmap(bitmap);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 图片没缓存，提交到线程池中下载图片</span></div><div class="line">        submitLoadRequest(imageUrl, imageView);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">submitLoadRequest</span><span class="params">(<span class="keyword">final</span> String imageUrl,</span></span></div><div class="line">             <span class="keyword">final</span> ImageView imageView) &#123;</div><div class="line">        imageView.setTag(imageUrl);</div><div class="line">        mExecutorService.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"> </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">              Bitmap bitmap = downloadImage(imageUrl);</div><div class="line">                <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">             &#125;</div><div class="line">               <span class="keyword">if</span> (imageView.getTag().equals(imageUrl)) &#123;</div><div class="line">                    imageView.setImageBitmap(bitmap);</div><div class="line">             &#125;</div><div class="line">                mImageCache.put(imageUrl, bitmap);</div><div class="line">         &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span>  Bitmap <span class="title">downloadImage</span><span class="params">(String imageUrl)</span> </span>&#123;</div><div class="line">       Bitmap bitmap = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">           URL url = <span class="keyword">new</span> URL(imageUrl);</div><div class="line">            <span class="keyword">final</span> HttpURLConnection conn = (HttpURLConnection) </div><div class="line">                        url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">              e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> bitmap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>经过这次重构，没有了那么多的if-else语句，没有了各种各样的缓存实现对象、布尔变量，代码确实清晰、简单了很多，小民对主管的崇敬之情又“泛滥”了起来。需要注意的是，这里的ImageCache类并不是小民原来的那个ImageCache，这次程序重构主管把它提取成一个图片缓存的接口，用来抽象图片缓存的功能。我们看看该接口的声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageCache</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ImageCache接口简单定义了获取、缓存图片两个函数，缓存的key是图片的url，值是图片本身。内存缓存、SD卡缓存、双缓存都实现了该接口，我们看看这几个缓存实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 内存缓存MemoryCache类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryCache</span> <span class="keyword">implements</span> <span class="title">ImageCache</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> LruCache&lt;String, Bitmap&gt; mMemeryCache;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemoryCache</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 初始化LRU缓存</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line">     <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mMemeryCache.get(url);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">        mMemeryCache.put(url, bmp);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// SD卡缓存DiskCache类</span></div><div class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">DiskCache</span> <span class="keyword">implements</span> <span class="title">ImageCache</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span><span class="comment">/* 从本地文件中获取该图片 */</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">        <span class="comment">// 将Bitmap写入文件中</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 双缓存DoubleCache类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCache</span> <span class="keyword">implements</span> <span class="title">ImageCache</span></span>&#123;</div><div class="line">    ImageCache mMemoryCache = <span class="keyword">new</span> MemoryCache();</div><div class="line">    ImageCache mDiskCache = <span class="keyword">new</span> DiskCache();</div><div class="line"> </div><div class="line">    <span class="comment">// 先从内存缓存中获取图片，如果没有，再从SD卡中获取</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">       Bitmap bitmap = mMemoryCache.get(url);</div><div class="line">        <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</div><div class="line">            bitmap = mDiskCache.get(url);</div><div class="line">       &#125;</div><div class="line">        <span class="keyword">return</span> bitmap;</div><div class="line">     &#125;</div><div class="line"> </div><div class="line">    <span class="comment">// 将图片缓存到内存和SD卡中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">        mMemoryCache.put(url, bmp);</div><div class="line">        mDiskCache.put(url, bmp);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>细心的朋友可能注意到了，ImageLoader类中增加了一个setImageCache（ImageCache cache）函数，用户可以通过该函数设置缓存实现，也就是通常说的依赖注入。下面就看看用户是如何设置缓存实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ImageLoader imageLoader = <span class="keyword">new</span> ImageLoader() ;</div><div class="line">        <span class="comment">// 使用内存缓存</span></div><div class="line">imageLoader.setImageCache(<span class="keyword">new</span> MemoryCache());</div><div class="line">        <span class="comment">// 使用SD卡缓存</span></div><div class="line">imageLoader.setImageCache(<span class="keyword">new</span> DiskCache());</div><div class="line">        <span class="comment">// 使用双缓存</span></div><div class="line">imageLoader.setImageCache(<span class="keyword">new</span> DoubleCache());</div><div class="line">        <span class="comment">// 使用自定义的图片缓存实现</span></div><div class="line">imageLoader.setImageCache(<span class="keyword">new</span> ImageCache() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">            <span class="comment">// 缓存图片</span></div><div class="line">       &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span><span class="comment">/*从缓存中获取图片*/</span>;</div><div class="line">       &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>在上述代码中，通过setImageCache（ImageCache cache）方法注入不同的缓存实现，这样不仅能够使ImageLoader更简单、健壮，也使得ImageLoader的可扩展性、灵活性更高。MemoryCache、DiskCache、DoubleCache缓存图片的具体实现完全不一样，但是，它们的一个特点是都实现了ImageCache接口。当用户需要自定义实现缓存策略时，只需要新建一个实现ImageCache接口的类，然后构造该类的对象，并且通过setImageCache（ImageCache cache）注入到ImageLoader中，这样ImageLoader就实现了变化万千的缓存策略，而扩展这些缓存策略并不会导致ImageLoader类的修改。经过这次重构，小民的ImageLoader已经基本算合格了。咦！这不就是主管说的开闭原则么！“软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的。而遵循开闭原则的重要手段应该是通过抽象……”小民细声细语的念叨中，陷入了思索中……</p>
<p>开闭原则指导我们，当软件需要变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。这里的“应该尽量”4个字说明OCP原则并不是说绝对不可以修改原始类的，当我们嗅到原来的代码“腐化气味”时，应该尽早地重构，以使得代码恢复到正常的“进化”轨道，而不是通过继承等方式添加新的实现，这会导致类型的膨胀以及历史遗留代码的冗余。我们的开发过程中也没有那么理想化的状况，完全地不用修改原来的代码，因此，在开发过程中需要自己结合具体情况进行考量，是通过修改旧代码还是通过继承使得软件系统更稳定、更灵活，在保证去除“代码腐化”的同时，也保证原有模块的正确性。</p>
<h2 id="构建扩展性更好的系统——里氏替换原则"><a href="#构建扩展性更好的系统——里氏替换原则" class="headerlink" title="构建扩展性更好的系统——里氏替换原则"></a>构建扩展性更好的系统——里氏替换原则</h2><p>里氏替换原则英文全称是Liskov Substitution Principle，简称LSP。它的第一种定义是：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。上面这种描述确实不太好理解，理论家有时候容易把问题抽象化，本来挺容易理解的事让他们一概括就弄得拗口了。我们再看看另一个直截了当的定义。里氏替换原则第二种定义：所有引用基类的地方必须能透明地使用其子类的对象。</p>
<p>我们知道，面向对象的语言的三大特点是继承、封装、多态，里氏替换原则就是依赖于继承、多态这两大特性。里氏替换原则简单来说就是，所有引用基类的地方必须能透明地使用其子类的对象。通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。说了那么多，其实最终总结就两个字：抽象。<br>小民为了深入地了解Android中的Window与View的关系特意写了一个简单示例，为了便于理解，我们先看如图1-3所示。<br><img src="http://img.blog.csdn.net/20151102134653836" alt="图1-3"><br>我们看看具体的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 窗口类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(View child)</span></span>&#123;</div><div class="line">        child.draw();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 建立视图抽象，测量视图的宽高为公用代码，绘制交给具体的子类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span>  <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span>  <span class="title">draw</span><span class="params">()</span> </span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">measure</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>&#123;</div><div class="line">        <span class="comment">// 测量视图大小</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 按钮类的具体实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 绘制按钮</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// TextView的具体实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 绘制文本</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述示例中，Window依赖于View，而View定义了一个视图抽象，measure是各个子类共享的方法，子类通过覆写View的draw方法实现具有各自特色的功能，在这里，这个功能就是绘制自身的内容。任何继承自View类的子类都可以设置给show方法，也就我们所说的里氏替换。通过里氏替换，就可以自定义各式各样、千变万化的View，然后传递给Window，Window负责组织View，并且将View显示到屏幕上。<br>里氏替换原则的核心原理是抽象，抽象又依赖于继承这个特性，在OOP当中，继承的优缺点都相当明显。<br>优点如下：</p>
<ul>
<li>（1）代码重用，减少创建类的成本，每个子类都拥有父类的方法和属性；</li>
<li>（2）子类与父类基本相似，但又与父类有所区别；</li>
<li>（3）提高代码的可扩展性。</li>
</ul>
<p>继承的缺点：</p>
<ul>
<li>继承是侵入性的，只要继承就必须拥有父类的所有属性和方法；</li>
<li>可能造成子类代码冗余、灵活性降低，因为子类必须拥有父类的属性和方法。</li>
</ul>
<p>事物总是具有两面性，如何权衡利与弊都是需要根据具体场景来做出选择并加以处理。里氏替换原则指导我们构建扩展性更好的软件系统，我们还是接着上面的ImageLoader来做说明。<br>上文的图1-2也很好地反应了里氏替换原则，即MemoryCache、DiskCache、DoubleCache都可以替换ImageCache的工作，并且能够保证行为的正确性。ImageCache建立了获取缓存图片、保存缓存图片的接口规范，MemoryCache等根据接口规范实现了相应的功能，用户只需要在使用时指定具体的缓存对象就可以动态地替换ImageLoader中的缓存策略。这就使得ImageLoader的缓存系统具有了无线的可能性，也就是保证了可扩展性。</p>
<p>想象一个场景，当ImageLoader中的setImageCache（ImageCache cache）中的cache对象不能够被子类所替换，那么用户如何设置不同的缓存对象以及用户如何自定义自己的缓存实现，通过1.3节中的useDiskCache方法吗？显然不是的，里氏替换原则就为这类问题提供了指导原则，也就是建立抽象，通过抽象建立规范，具体的实现在运行时替换掉抽象，保证系统的高扩展性、灵活性。开闭原则和里氏替换原则往往是生死相依、不弃不离的，通过里氏替换来达到对扩展开放，对修改关闭的效果。然而，这两个原则都同时强调了一个OOP的重要特性——抽象，因此，在开发过程中运用抽象是走向代码优化的重要一步。</p>
<h2 id="让项目拥有变化的能力——依赖倒置原则"><a href="#让项目拥有变化的能力——依赖倒置原则" class="headerlink" title="让项目拥有变化的能力——依赖倒置原则"></a>让项目拥有变化的能力——依赖倒置原则</h2><p>依赖倒置原则英文全称是Dependence Inversion Principle，简称DIP。依赖反转原则指代了一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节的目的，依赖模块被颠倒了。这个概念有点不好理解，这到底是什么意思呢？<br>依赖倒置原则的几个关键点：</p>
<ul>
<li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li>
<li>抽象不应该依赖细节；</li>
<li>细节应该依赖抽象。</li>
</ul>
<p>在Java语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是，可以直接被实例化，也就是可以加上一个关键字 new 产生一个对象。高层模块就是调用端，低层模块就是具体实现类。依赖倒置原则在 Java 语言中的表现就是：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。这又是一个将理论抽象化的实例，其实一句话就可以概括：面向接口编程，或者说是面向抽象编程，这里的抽象指的是接口或者抽象类。面向接口编程是面向对象精髓之一，也就是上面两节强调的抽象。</p>
<p>如果在类与类直接依赖于细节，那么它们之间就有直接的耦合，当具体实现需要变化时，意味着在这要同时修改依赖者的代码，并且限制了系统的可扩展性。我们看1.3节的图1-3中，ImageLoader直接依赖于MemoryCache，这个MemoryCache是一个具体实现，而不是一个抽象类或者接口。这导致了ImageLoader直接依赖了具体细节，当MemoryCache不能满足ImageLoader而需要被其他缓存实现替换时，此时就必须修改ImageLoader的代码，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 内存缓存 ( 直接依赖于细节 )</span></div><div class="line">    MemoryCache mMemoryCache = <span class="keyword">new</span> MemoryCache();</div><div class="line">     <span class="comment">// 加载图片到ImageView中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String url, ImageView imageView)</span> </span>&#123;</div><div class="line">       Bitmap bmp = mMemoryCache.get(url);</div><div class="line">        <span class="keyword">if</span> (bmp == <span class="keyword">null</span>) &#123;</div><div class="line">            downloadImage(url, imageView);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">            imageView.setImageBitmap(bmp);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageCache</span><span class="params">(MemoryCache cache)</span> </span>&#123;</div><div class="line">        mCache = cache ;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>随着产品的升级，用户发现MemoryCache已经不能满足需求，用户需要小民的ImageLoader可以将图片同时缓存到内存和SD卡中，或者可以让用户自定义实现缓存。此时，我们的MemoryCache这个类名不仅不能够表达内存缓存和SD卡缓存的意义，也不能够满足功能。另外，用户需要自定义缓存实现时还必须继承自MemoryCache，而用户的缓存实现可不一定与内存缓存有关，这在命名上的限制也让用户体验不好。重构的时候到了!小民的第一种方案是将MemoryCache修改为DoubleCache，然后在DoubleCache中实现具体的缓存功能。我们需要将ImageLoader修改如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 双缓存 ( 直接依赖于细节 )</span></div><div class="line">    DoubleCache mCache = <span class="keyword">new</span> DoubleCache();</div><div class="line">    <span class="comment">// 加载图片到ImageView中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String url, ImageView imageView)</span> </span>&#123;</div><div class="line">       Bitmap bmp = mCache.get(url);</div><div class="line">        <span class="keyword">if</span> (bmp == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="comment">// 异步下载图片</span></div><div class="line">            downloadImageAsync(url, imageView);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">            imageView.setImageBitmap(bmp);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageCache</span><span class="params">(DoubleCache cache)</span> </span>&#123;</div><div class="line">         mCache = cache ;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们将MemoryCache修改成DoubleCache，然后修改了ImageLoader中缓存类的具体实现，轻轻松松就满足了用户需求。等等！这不还是依赖于具体的实现类（DoubleCache）吗？当用户的需求再次变化时，我们又要通过修改缓存实现类和ImageLoader代码来实现？修改原有代码不是违反了1.3节中的开闭原则吗？小民突然醒悟了过来，低下头思索着如何才能让缓存系统更灵活、拥抱变化……</p>
<p>当然，这些都是在主管给出图1-2（1.3节）以及相应的代码之前，小民体验的煎熬过程。既然是这样，那显然主管给出的解决方案就能够让缓存系统更加灵活。一句话概括起来就是：依赖抽象，而不依赖具体实现。针对于图片缓存，主管建立的ImageCache抽象，该抽象中增加了get和put方法用以实现图片的存取。每种缓存实现都必须实现这个接口，并且实现自己的存取方法。当用户需要使用不同的缓存实现时，直接通过依赖注入即可，保证了系统的灵活性。我们再来简单回顾一下相关代码：</p>
<p>ImageCache缓存抽象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageCache</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ImageLoader类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 图片缓存类，依赖于抽象，并且有一个默认的实现</span></div><div class="line">    ImageCache mCache = <span class="keyword">new</span> MemoryCache();</div><div class="line"></div><div class="line">    <span class="comment">// 加载图片</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String url, ImageView imageView)</span> </span>&#123;</div><div class="line">       Bitmap bmp = mCache.get(url);</div><div class="line">        <span class="keyword">if</span> (bmp == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 异步加载图片</span></div><div class="line">            downloadImageAsync(url, imageView);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">            imageView.setImageBitmap(bmp);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置缓存策略,依赖于抽象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageCache</span><span class="params">(ImageCache cache)</span> </span>&#123;</div><div class="line">        mCache = cache;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，我们建立了ImageCache抽象，并且让ImageLoader依赖于抽象而不是具体细节。当需求发生变更时，小民只需要实现ImageCahce类或者继承其他已有的ImageCache子类完成相应的缓存功能，然后将具体的实现注入到ImageLoader即可实现缓存功能的替换，这就保证了缓存系统的高可扩展性，拥有了拥抱变化的能力，而这一切的基本指导原则就是我们的依赖倒置原则。从上述几节中我们发现，要想让我们的系统更为灵活，抽象似乎成了我们唯一的手段。</p>
<h2 id="系统有更高的灵活性——接口隔离原则"><a href="#系统有更高的灵活性——接口隔离原则" class="headerlink" title="系统有更高的灵活性——接口隔离原则"></a>系统有更高的灵活性——接口隔离原则</h2><p>接口隔离原则英文全称是InterfaceSegregation Principles，简称ISP。它的定义是：客户端不应该依赖它不需要的接口。另一种定义是：类间的依赖关系应该建立在最小的接口上。接口隔离原则将非常庞大、臃肿的接口拆分成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。接口隔离原则的目的是系统解开耦合，从而容易重构、更改和重新部署。</p>
<p>接口隔离原则说白了就是，让客户端依赖的接口尽可能地小，这样说可能还是有点抽象，我们还是以一个示例来说明一下。在此之前我们来说一个场景，在Java 6以及之前的JDK版本，有一个非常讨厌的问题，那就是在使用了OutputStream或者其他可关闭的对象之后，我们必须保证它们最终被关闭了，我们的SD卡缓存类中就有这样的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将图片缓存到内存中</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">    FileOutputStream fileOutputStream = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        fileOutputStream = <span class="keyword">new</span> FileOutputStream(cacheDir + url);</div><div class="line">        bmp.compress(CompressFormat.PNG, <span class="number">100</span>, fileOutputStream);</div><div class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (fileOutputStream != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                fileOutputStream.close();</div><div class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">          &#125;</div><div class="line">       &#125; <span class="comment">// end if</span></div><div class="line">    &#125; <span class="comment">// end if finally</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看到的这段代码可读性非常差，各种try…catch嵌套，都是些简单的代码，但是会严重影响代码的可读性，并且多层级的大括号很容易将代码写到错误的层级中。大家应该对这类代码也非常反感，那我们看看如何解决这类问题。<br>我们可能知道Java中有一个Closeable接口，该接口标识了一个可关闭的对象，它只有一个close方法，如图1-4所示。<br>我们要讲的FileOutputStream类就实现了这个接口，我们从图1-4中可以看到，还有一百多个类实现了Closeable这个接口，这意味着，在关闭这一百多个类型的对象时，都需要写出像put方法中finally代码段那样的代码。这还了得！你能忍，反正小民是忍不了的！于是小民打算要发挥他的聪明才智解决这个问题，既然都是实现了Closeable接口，那只要我建一个方法统一来关闭这些对象不就可以了么？说干就干，于是小民写下来如下的工具类：<br><img src="http://img.blog.csdn.net/20151102135056245" alt="图1-4"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseUtils</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">Private <span class="title">CloseUtils</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 关闭Closeable对象</div><div class="line">     * <span class="doctag">@param</span> closeable</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeQuietly</span><span class="params">(Closeable closeable)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != closeable) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                closeable.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们再看看把这段代码运用到上述的put方法中的效果如何：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">    FileOutputStream fileOutputStream = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        fileOutputStream = <span class="keyword">new</span> FileOutputStream(cacheDir + url);</div><div class="line">        bmp.compress(CompressFormat.PNG, <span class="number">100</span>, fileOutputStream);</div><div class="line">   &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">   &#125; <span class="keyword">final</span> ly &#123;</div><div class="line">        CloseUtils.closeQuietly(fileOutputStream);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码简洁了很多！而且这个closeQuietly方法可以运用到各类可关闭的对象中，保证了代码的重用性。CloseUtils的closeQuietly方法的基本原理就是依赖于Closeable抽象而不是具体实现（这不是1.4节中的依赖倒置原则么），并且建立在最小化依赖原则的基础，它只需要知道这个对象是可关闭，其他的一概不关心，也就是这里的接口隔离原则。</p>
<p>试想一下，如果在只是需要关闭一个对象时，它却暴露出了其他的接口函数，比如OutputStream的write方法，这就使得更多的细节暴露在客户端代码面前，不仅没有很好地隐藏实现，还增加了接口的使用难度。而通过Closeable接口将可关闭的对象抽象起来，这样只需要客户端依赖于Closeable就可以对客户端隐藏其他的接口信息，客户端代码只需要知道这个对象可关闭（只可调用close方法）即可。小民ImageLoader中的ImageCache就是接口隔离原则的运用，ImageLoader只需要知道该缓存对象有存、取缓存图片的接口即可，其他的一概不管，这就使得缓存功能的具体实现对ImageLoader具体的隐藏。这就是用最小化接口隔离了实现类的细节，也促使我们将庞大的接口拆分到更细粒度的接口当中，这使得我们的系统具有更低的耦合性，更高的灵活性。</p>
<p>Bob大叔（Robert C Martin）在21世纪早期将单一职责、开闭原则、里氏替换、接口隔离以及依赖倒置（也称为依赖反转）5个原则定义为SOLID原则，指代了面向对象编程的5个基本原则。当这些原则被一起应用时，它们使得一个软件系统更清晰、简单、最大程度地拥抱变化。SOLID被典型地应用在测试驱动开发上，并且是敏捷开发以及自适应软件开发基本原则的重要组成部分。在经过第1.1～1.5节的学习之后，我们发现这几大原则最终就可以化为这几个关键词：抽象、单一职责、最小化。那么在实际开发过程中如何权衡、实践这些原则，是大家需要在实践中多思考与领悟，正所谓”学而不思则罔，思而不学则殆”，只有不断地学习、实践、思考，才能够在积累的过程有一个质的飞越。</p>
<h2 id="更好的可扩展性——迪米特原则"><a href="#更好的可扩展性——迪米特原则" class="headerlink" title="更好的可扩展性——迪米特原则"></a>更好的可扩展性——迪米特原则</h2><p>迪米特原则英文全称为Law of Demeter，简称LOD，也称为最少知识原则（Least Knowledge Principle）。虽然名字不同，但描述的是同一个原则：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
<p>迪米特法则还有一个英文解释是：Only talk to your immedate friends，翻译过来就是：只与直接的朋友通信。什么叫做直接的朋友呢？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系的类型有很多，例如组合、聚合、依赖等。</p>
<p>光说不练很抽象呐，下面我们就以租房为例来讲讲迪米特原则。<br>“北漂”的同学比较了解，在北京租房绝大多数都是通过中介找房。我们设定的情境为：我只要求房间的面积和租金，其他的一概不管，中介将符合我要求的房子提供给我就可以。下面我们看看这个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 房间</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> area;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> price;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Room</span><span class="params">(<span class="keyword">float</span>  area, <span class="keyword">float</span>  price)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.area = area;</div><div class="line">        <span class="keyword">this</span>.price = price;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Room [area="</span> + area + <span class="string">", price="</span> + price + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 中介</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</div><div class="line">    List&lt;Room&gt; mRooms = <span class="keyword">new</span> ArrayList&lt;Room&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mediator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (inti = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            mRooms.add(<span class="keyword">new</span> Room(<span class="number">14</span> + i, (<span class="number">14</span> + i) * <span class="number">150</span>));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> List&lt;Room&gt;getAllRooms() &#123;</div><div class="line">        <span class="keyword">return</span> mRooms;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 租户</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tenant</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> roomArea;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> roomPrice;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> diffPrice = <span class="number">100.0001f</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> diffArea = <span class="number">0.00001f</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rentRoom</span><span class="params">(Mediator mediator)</span> </span>&#123;</div><div class="line">        List&lt;Room&gt;rooms = mediator.getAllRooms();</div><div class="line">        <span class="keyword">for</span> (Room room : rooms) &#123;</div><div class="line">            <span class="keyword">if</span> (isSuitable(room)) &#123;</div><div class="line">             System.out.println(<span class="string">"租到房间啦! "</span> + room);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSuitable</span><span class="params">(Room room)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.abs(room.price - roomPrice) &lt; diffPrice</div><div class="line">                &amp;&amp;Math.abs(room.area - roomArea) &lt; diffArea;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面的代码中可以看到，Tenant不仅依赖了Mediator类，还需要频繁地与Room类打交道。租户类的要求只是通过中介找到一间适合自己的房间罢了，如果把这些检测条件都放在Tenant类中，那么中介类的功能就被弱化，而且导致Tenant与Room的耦合较高，因为Tenant必须知道许多关于Room的细节。当Room变化时Tenant也必须跟着变化。Tenant又与Mediator耦合，就导致了纠缠不清的关系。这个时候就需要我们分清谁才是我们真正的“朋友”，在我们所设定的情况下，显然是Mediator（虽然现实生活中不是这样的）。上述代码的结构如图1-5所示。<br><img src="http://img.blog.csdn.net/20151102135211486" alt="图1-5"><br>既然是耦合太严重，那我们就只能解耦了，首先要明确地是，我们只和我们的朋友通信，这里就是指Mediator对象。必须将Room相关的操作从Tenant中移除，而这些操作案例应该属于Mediator，我们进行如下重构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 中介</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</div><div class="line">    List&lt;Room&gt; mRooms = <span class="keyword">new</span> ArrayList&lt;Room&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mediator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (inti = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            mRooms.add(<span class="keyword">new</span> Room(<span class="number">14</span> + i, (<span class="number">14</span> + i) * <span class="number">150</span>));</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Room <span class="title">rentOut</span><span class="params">(<span class="keyword">float</span>  area, <span class="keyword">float</span>  price)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Room room : mRooms) &#123;</div><div class="line">            <span class="keyword">if</span> (isSuitable(area, price, room)) &#123;</div><div class="line">                <span class="keyword">return</span>  room;</div><div class="line">          &#125;</div><div class="line">       &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSuitable</span><span class="params">(<span class="keyword">float</span> area, <span class="keyword">float</span> price, Room room)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.abs(room.price - price) &lt; Tenant.diffPrice</div><div class="line">            &amp;&amp; Math.abs(room.area - area) &lt; Tenant.diffPrice;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 租户</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tenant</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> roomArea;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> roomPrice;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> diffPrice = <span class="number">100.0001f</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> diffArea = <span class="number">0.00001f</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rentRoom</span><span class="params">(Mediator mediator)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"租到房啦 "</span> + mediator.rentOut(roomArea, roomPrice));</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重构后的结构图如图1-6所示:<br><img src="http://img.blog.csdn.net/20151102135310062" alt="图1-6"><br>只是将对于Room的判定操作移到了Mediator类中，这本应该是Mediator的职责，他们根据租户设定的条件查找符合要求的房子，并且将结果交给租户就可以了。租户并不需要知道太多关于Room的细节，比如与房东签合同、房东的房产证是不是真的、房内的设施坏了之后我要找谁维修等，当我们通过我们的“朋友”中介租了房之后，所有的事情我们都通过与中介沟通就好了，房东、维修师傅等这些角色并不是我们直接的“朋友”。“只与直接的朋友通信”这简单的几个字就能够将我们从乱七八糟的关系网中抽离出来，使我们的耦合度更低、稳定性更好。<br>通过上述示例以及小民的后续思考，迪米特原则这把利剑在小民的手中已经舞得风生水起。就拿sd卡缓存来说吧，ImageCache就是用户的直接朋友，而SD卡缓存内部却是使用了jake wharton的DiskLruCache实现，这个DiskLruCache就不属于用户的直接朋友了，因此，用户完全不需要知道它的存在，用户只需要与ImageCache对象打交道即可。例如将图片存到SD卡中的代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap value)</span> </span>&#123;</div><div class="line">    DiskLruCache.Editor editor = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 如果没有找到对应的缓存，则准备从网络上请求数据，并写入缓存</span></div><div class="line">        editor = mDiskLruCache.edit(url);</div><div class="line">        <span class="keyword">if</span> (editor != <span class="keyword">null</span>) &#123;</div><div class="line">                OutputStream outputStream = editor.newOutputStream(<span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span> (writeBitmapToDisk(value, outputStream)) &#123;</div><div class="line">              <span class="comment">// 写入disk缓存</span></div><div class="line">                editor.commit();</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">                editor.abort();</div><div class="line">          &#125;</div><div class="line">            CloseUtils.closeQuietly(outputStream);</div><div class="line">       &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用户在使用SD卡缓存时，根本不知晓DiskLruCache的实现，这就很好地对用户隐藏了具体实现。当小民已经“牛”到可以自己完成SD卡的rul实现时，他就可以随心所欲的替换掉jake wharton的DiskLruCache。小民的代码大体如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将Bitmap写入文件中</span></div><div class="line">    FileOutputStream fos = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 构建图片的存储路径 ( 省略了对url取md5)</span></div><div class="line">        fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"sdcard/cache/"</span> + imageUrl2MD5(url));</div><div class="line">        bmp.compress(CompressFormat.JPEG, <span class="number">100</span>, fos);</div><div class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> ( fos != <span class="keyword">null</span> ) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                fos.close();</div><div class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">          &#125;</div><div class="line">       &#125;</div><div class="line">    &#125; <span class="comment">// end if finally</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>SD卡缓存的具体实现虽然被替换了，但用户根本不会感知到。因为用户根本不知道DiskLruCache的存在，他们没有与DiskLruCache进行通信，他们只认识直接“朋友”ImageCache，ImageCache将一切细节隐藏在了直接“朋友”的外衣之下，使得系统具有更低的耦合性和更好的可扩展性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在应用开发过程中，最难的不是完成应用的开发工作，而是在后续的升级、维护过程中让应用系统能够拥抱变化。拥抱变化也就意味着在满足需求且不破坏系统稳定性的前提下保持高可扩展性、高内聚、低耦合，在经历了各版本的变更之后依然保持清晰、灵活、稳定的系统架构。当然，这是一个比较理想的情况，但我们必须要朝着这个方向去努力，那么遵循面向对象六大原则就是我们走向灵活软件之路所迈出的第一步。</p>
<h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><ul>
<li><a href="http://www.devtf.cn/?p=1134" target="_blank" rel="external">开发技术前线:面向对象六大原则</a></li>
<li><a href="">Android源码设计模式解析与实战</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/11/Intellij-IDEA部署本地Tomcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/11/Intellij-IDEA部署本地Tomcat/" itemprop="url">Intellij IDEA部署本地Tomcat</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-11T22:15:36+08:00">
                2015-11-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一直以来用Eclipse都是用本地tomcat、IDEA都是tomcat/jetty的maven插件的方式来跑Web工程。之前使用让IDEA用本地tomcat的方式来运行却没成功，一直困惑不已。然而今天公司需要这样做，问了下同事终于把这问题解决了。所以记录下！</p>
<h2 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h2><h3 id="安装本地Tomcat"><a href="#安装本地Tomcat" class="headerlink" title="安装本地Tomcat"></a>安装本地Tomcat</h3><p>Tomcat和JDK的安装可以查看这里<a href="http://www.cnblogs.com/pannysp/archive/2012/03/07/2383364.html" target="_blank" rel="external">win7下安装配置tomcat,java运行环境</a>,具体的就不啰嗦了，这个步骤应该都操作过很多次了。但这是基础，jdk和tomcat没配好，接下来的所有工作都无法进行。</p>
<h3 id="安装Tomcat-and-TomEE-Integration"><a href="#安装Tomcat-and-TomEE-Integration" class="headerlink" title="安装Tomcat and TomEE Integration"></a>安装Tomcat and TomEE Integration</h3><p>因为IDEA要依赖”<strong>Tomcat and TomEE Integration</strong>“这个插件来运行tomcat，所以我们的IDEA必须要进行安装。ULTIMATE版本的已经自带了，社区版的好像要自己装 。可以在工具栏的<code>Run-&gt;Edit Configurations</code>，在弹出来的界面中点击<code>+</code>，输入<code>tomcat</code>看是否有<code>Tomcat Server</code>，有的话就是已经安装了，没有的话就去<code>Settings</code>里的插件中心安装即可。<br><img src="https://c1.staticflickr.com/1/773/22272123843_82e7e3a187_c.jpg" alt=""></p>
<h3 id="验证Project的Artifacts"><a href="#验证Project的Artifacts" class="headerlink" title="验证Project的Artifacts"></a>验证Project的Artifacts</h3><p>打开Project的<code>Module Setting(F4)</code>，看<code>Artifacts</code>里是不是有<code>&lt;project_name&gt;:war</code>和<code>&lt;project_name&gt;:war exploded</code>，如果你的是Web工程，一般都会有。如果没有就检查下是否是Web工程。<br><img src="https://c1.staticflickr.com/1/757/22883412036_19caf37b3b_c.jpg" alt=""></p>
<h3 id="添加服务器配置"><a href="#添加服务器配置" class="headerlink" title="添加服务器配置"></a>添加服务器配置</h3><p>依次打开<code>Run -&gt; Edit Configurations -&gt; + -&gt; Tomcat Server -&gt; Local</code>，输入如下图中的配置。<br><img src="https://c2.staticflickr.com/6/5720/22893261735_31e829dae6_c.jpg" alt=""><br><img src="https://c1.staticflickr.com/1/737/22474938568_aab1510c02_c.jpg" alt=""></p>
<h2 id="配置热部署"><a href="#配置热部署" class="headerlink" title="配置热部署"></a>配置热部署</h2><p>在服务器的配置过程中，热部署是一个很常用的功能。如果没有配置热部署，那么你每修改一个java文件，甚至一个jsp文件，都必须手动restart server，那将是多么痛苦的一件事。</p>
<p>上面的图中，<strong>On ‘Update’ action</strong>是你点击Update按钮后的动作。而<strong>On frame deactivation</strong>是热部署的关键，为了实现热部署我们应该把它设置为<strong>Update classed and resources</strong>。 但是有时候我们发觉只有Do nothing、Update resources这两个选项，并没有Update classed and resources这个选项。其实这是因为我们的war包是选了 <code>&lt;project_name&gt;:war</code>这个，只要选回<code>&lt;project_name&gt;:war exploded</code>这个就可以了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实本地tomcat的运行关键是依靠war包，而这个war包IDEA默认已经帮我们配置好了。所以把这个war包添加到tomcat的配置中就可以run on local了。</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://blog.csdn.net/dandandeshangni/article/details/44057871" target="_blank" rel="external">CSDN:idea 修改jsp页面需要重新部署项目的额问题</a></li>
<li><a href="http://www.cnblogs.com/pannysp/archive/2012/03/07/2383364.html" target="_blank" rel="external">win7下安装配置tomcat,java运行环境</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/25/链表-常见面试问题总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/25/链表-常见面试问题总结/" itemprop="url">链表-常见面试问题总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-25T02:56:01+08:00">
                2015-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近这段时间都在忙活校招，在面试的过程中遇到了很多有关链表的问题，由于以前没怎么搞过ACM，数据结构也忘的七七八八了，所以总体感觉回答得不是很好。昨天把链表的基础回顾了下，见这里<a href="http://www.luohuida.com/2015/10/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">单链表的基础操作</a>，于是今天把面试过程中经常遇到的链表相关的问题总结下。</p>
<h2 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h2><p>单链表的反转是面试的常用考点，所以必须掌握。思路是<strong>把当前节点拿过来作为已经翻转的表头，成为一个已翻转的子链，用result指向其头部（也就是当前节点）</strong>。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 反转单链表</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">traversingReverse</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">	Node result = <span class="keyword">null</span>;</div><div class="line">	Node temp = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 头反转法：把当前节点拿过来作为已经翻转结果的表头</span></div><div class="line">	<span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">		temp = head.next; <span class="comment">// 保存下一个节点</span></div><div class="line">		head.next = result; <span class="comment">// 当前节点放在结果的开头</span></div><div class="line">		result = head; <span class="comment">// 当前节点的头</span></div><div class="line">		head = temp; <span class="comment">// head指向下一个节点</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="懒删除-在O-1-时间删除链表节点"><a href="#懒删除-在O-1-时间删除链表节点" class="headerlink" title="懒删除(在O(1)时间删除链表节点)"></a>懒删除(在O(1)时间删除链表节点)</h2><p>有一种情况，当我们的now引用指向某一个节点的时候，我们需要删除该节点。然而如果不知道now节点的前驱节点，一般方法是无法删除now这个节点的。</p>
<p>这个时候，我们可以使用“懒”删除，这种方法的思想是：<strong>把now节点后驱节点的值赋给now节点，然后now节点的next指向的它后驱节点的下一个节点</strong>。因为不用遍历，所以这个算法的时间复杂度是O(1)。然而要注意的是尾节点，当now节点就是尾节点的时候，这种办法就行不通了。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// O(1)复杂度删除某个节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lazyDelete</span><span class="params">(Node now)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(now.next != <span class="keyword">null</span>) &#123; <span class="comment">// ①非尾节点</span></div><div class="line">        now.value = now.next.value; <span class="comment">// 复制后驱节点的值</span></div><div class="line">        now.next = now.next.next; <span class="comment">// “删除”后驱节点</span></div><div class="line">    &#125;  <span class="keyword">else</span>&#123; <span class="comment">// ②尾节点，行不通</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="求链表倒数第k个节点"><a href="#求链表倒数第k个节点" class="headerlink" title="求链表倒数第k个节点"></a>求链表倒数第k个节点</h2><p>经常会遇到求单链表倒数第几个节点的问题，如果按常规方法的话，我们需要先遍历整个链表，记录下节点个数，假设为n，然后再遍历一遍，第n-k+1个就是所求节点了。可是这个方法效率太低，需要两次遍历，有没有更加高效的方法呢？答案是肯定的。我们可以用 <strong>快慢指针</strong> 来解决这个问题，这个方法的思想是这样的：</p>
<blockquote>
<ul>
<li>假设有引用fast、slow，开始都指向首节点;</li>
<li>fast先走k次，这样fast和slow就相隔了k个节点;</li>
<li>然后fast、slow一起走，当fast走到链表末尾为null的时候，slow就是所求节点了。</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 求单链表倒数第k个节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getKNode</span><span class="params">(Node head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    Node fast = head;</div><div class="line">    Node slow = head;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(; i &lt; k &amp;&amp; fast != <span class="keyword">null</span>; i++) &#123;</div><div class="line">        fast = fast.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(i != k) &#123;</div><div class="line">        System.out.println(k + <span class="string">"位置超出链表长度"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span>) &#123;</div><div class="line">        fast = fast.next;</div><div class="line">        slow = slow.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> slow;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="求链表的中间节点"><a href="#求链表的中间节点" class="headerlink" title="求链表的中间节点"></a>求链表的中间节点</h2><p>如果要求一个链表的中间节点，常规的方法是先遍历一次获取链表的长度n，如果n是偶数就n/2、n/2+1都可以，如果n是奇数，那就第n/2+1个。可是这个方法的效率也是非常低。</p>
<p>其实通过上面找用快慢指针的方法来找倒数第k个数，我们可以衍生到这里来。这个方法的思路是这样的：</p>
<blockquote>
<ul>
<li>假设有引用fast、slow，开始都指向首节点;</li>
<li>fast、slow同时走，但是fast每次走2步，slow每次走1步；</li>
<li>当fast走到链表末尾时，slow就是中间节点；</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 求链表的中间节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getMiddleNode</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Node fast = head;</div><div class="line">    Node slow = head;</div><div class="line">    </div><div class="line">    <span class="comment">// ①如果fast==null的话，说明是偶数个；而fast.next==null的话，说明是奇数个</span></div><div class="line">    <span class="comment">// ①条件返回的是偶数情况中的后者，如果要返回前者，可用下面判断条件：</span></div><div class="line">    <span class="comment">// while (fast != null &amp;&amp; fast.next != null &amp;&amp; fast.next.next != null)</span></div><div class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123; <span class="comment">// ①</span></div><div class="line">        fast = fast.next.next; <span class="comment">// 快指针走2步</span></div><div class="line">        slow = slow.next; <span class="comment">// 慢指针走1步</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> slow;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="单链表是否存在环-leetcode-141"><a href="#单链表是否存在环-leetcode-141" class="headerlink" title="单链表是否存在环(leetcode 141)"></a>单链表是否存在环(leetcode 141)</h2><p>其实判断单链表是否有环有2种方法，第一种是用Set集合的方法，第二种是用快慢指针的方法。</p>
<h3 id="利用HashSet集合"><a href="#利用HashSet集合" class="headerlink" title="利用HashSet集合"></a>利用HashSet集合</h3><p>这个方法的思想很简单，就是<strong>遍历该链表，每走一次，就判断HashSet中是否存在该节点，如果存在则说明有环，结束；如果不存在，说明还没有环，把该节点放到HashSet中去，直到链表的末尾</strong>。如果利用的是HashSet，则该算法的时间复杂度也是O(n)，就是空间复杂度大了点。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 利用HashMap判断是否有环</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCircle</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    Set&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">    	<span class="keyword">if</span>(getFromSet(set, head) != <span class="keyword">null</span>) &#123;</div><div class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    	&#125;</div><div class="line">    	</div><div class="line">    	set.add(head);</div><div class="line">    	head = head.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 由于Set没有提供get()方法，所以自己实现一个</span></div><div class="line"><span class="comment">// 缘何Set不提供get()？？？</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getFromSet</span><span class="params">(Set&lt;Node&gt; set, Node node)</span> </span>&#123;</div><div class="line">	Iterator it = set.iterator();</div><div class="line">	Node tmp;</div><div class="line"></div><div class="line">	<span class="keyword">while</span>(it.hasNext()) &#123;</div><div class="line">		tmp = (Node)it.next();</div><div class="line">		<span class="keyword">if</span>(tmp == node) &#123;</div><div class="line">			<span class="keyword">return</span> tmp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="利用快慢指针"><a href="#利用快慢指针" class="headerlink" title="利用快慢指针"></a>利用快慢指针</h3><p>上面的方法实现起来很简单高效，但是却需要额外的空间，空间复杂度是O(n)，而快慢指针是一个更高效的方法。<strong>让快指针每次走2步，慢指针每次走1步，两个指针的速度不一样，如果存在环的话，那么最后快慢指针肯定会相遇</strong>。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 利用快慢指针判断链表是否有环</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCircle</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    Node fast = head;</div><div class="line">    Node slow = head;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</div><div class="line">        fast = fast.next.next;</div><div class="line">        slow = slow.next;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (fast == slow) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="单链表中环的起点-leetcode-142"><a href="#单链表中环的起点-leetcode-142" class="headerlink" title="单链表中环的起点(leetcode 142)"></a>单链表中环的起点(leetcode 142)</h2><p><img src="https://c1.staticflickr.com/1/620/22399861952_2440672711_c.jpg" alt="快慢指针求环起点"><br>假设链表中存在环，我们先设定几个参数：n(环的长度=7)、a(链表起点到环起点的距离=3)、x(fast指针到环起点的时候，slow指针在环中的位置0 &lt;= x &lt; n)，由此我们可以推出下面几个性质：</p>
<blockquote>
<ol>
<li>slow到起点(s3)的时候，fast在环中走了x步(f3)，那么fast和slow相差 n - x 步，也就是说 n - x 步后，fast会追上slow；</li>
<li>经过 n - x 步后(4步)，fast和slow在环中M点相遇(f7与s7)；</li>
<li>假设这时候相遇点M与环起点的距离为b(=4)，则slow走过的距离是 a + b ，而fast走过的距离为 a + b + k <em> n 。显然fast走的长度是slow的2倍，所以2 </em> ( a + b ) = a + b + k <em> n，则 **a + b = k </em> n**；</li>
<li>把fast指针拉回链表的起始点，这时候fast和slow每次都走一步，经过a步后，fast和slow在环的起始点相遇。</li>
</ol>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用快慢指针求环起点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listCircleStart</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    <span class="comment">// 空链或者单节点，不存在环</span></div><div class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Node fast = head;</div><div class="line">    Node slow = head;</div><div class="line">    </div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123; <span class="comment">// 无环</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        fast = fast.next.next; <span class="comment">// 走2步</span></div><div class="line">        slow = slow.next; <span class="comment">// 走1步</span></div><div class="line">    &#125; <span class="keyword">while</span> (fast != slow) <span class="comment">// 直到fast和slow相遇</span></div><div class="line">    </div><div class="line">    fast = head; <span class="comment">// 重新拉回链表起点</span></div><div class="line">    <span class="keyword">while</span> (fast != slow) &#123; <span class="comment">// 相遇即为环起点</span></div><div class="line">        fast = fast.next; <span class="comment">// 走1步</span></div><div class="line">        slow = slow.next; <span class="comment">// 走1步</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> fast;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="单链表中环的长度"><a href="#单链表中环的长度" class="headerlink" title="单链表中环的长度"></a>单链表中环的长度</h2><p>在上面，我们找到环的起点后，再用slow指针走一遍，就可以算出环的长度了。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用快慢指针求环长度</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">listCircleLength</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    Node cicleStart = listCircleStart(head); <span class="comment">// 先利用上面的方法求出环起点</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(cicleStart == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Node tmp = cicleStart.next;</div><div class="line">    <span class="keyword">int</span> counter = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (tmp != cicleStart) &#123; <span class="comment">// 重走一遍，直到回到环起点</span></div><div class="line">        counter++;</div><div class="line">        tmp = tmp.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="两个链表是否相交并求出交点-leetcode-160"><a href="#两个链表是否相交并求出交点-leetcode-160" class="headerlink" title="两个链表是否相交并求出交点(leetcode 160)"></a>两个链表是否相交并求出交点(leetcode 160)</h2><p>给定2个链表，判断这两个链表是否相交，如果相交的话，就类似于一个向左翻转90°的Y。见下图：<br><img src="https://c1.staticflickr.com/1/649/22234956790_1986323deb_c.jpg" alt="相交链表"></p>
<p>这个问题相比环来说简单很多，我们可以用Set集合方法、链长先走方法、成环方法来解决。下面我们逐一来看。</p>
<h3 id="Set集合方法"><a href="#Set集合方法" class="headerlink" title="Set集合方法"></a>Set集合方法</h3><p>这个方法的思路最简单：</p>
<blockquote>
<ol>
<li>先遍历a链，依次把所有节点放入到Set中去；</li>
<li>然后遍历b链，每到一个节点，就去Set看是否存在该节点，如果存在，则说明有交点，而交点就是该节点(第一个相等的肯定是交点)；</li>
<li>如果直到b链的末尾都没有相等节点，则说明没有交点；</li>
</ol>
</blockquote>
<p>这个方法其实比较笨，效率也比较低。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 利用Set求2链表交点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getCrossNode</span><span class="params">(Node headA, Node headB)</span> </span>&#123;</div><div class="line">    Set&lt;Node&gt; set = <span class="keyword">new</span> Hash&lt;&gt;();</div><div class="line">    </div><div class="line">    <span class="comment">// 把a链全部放入Set中</span></div><div class="line">    <span class="keyword">while</span> (headA != <span class="keyword">null</span>) &#123;</div><div class="line">        set.add(headA);</div><div class="line">        headA = headA.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 遍历b链</span></div><div class="line">    <span class="keyword">while</span> (headB != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(set.getFromSet(set, headB) != <span class="keyword">null</span>) &#123; <span class="comment">// 相交</span></div><div class="line">            <span class="keyword">return</span> headB;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getFromSet</span><span class="params">(Set&lt;Node&gt; set, Node node)</span> </span>&#123;</div><div class="line">	Iterator it = set.iterator();</div><div class="line">	Node tmp;</div><div class="line"></div><div class="line">	<span class="keyword">while</span>(it.hasNext()) &#123;</div><div class="line">		tmp = (Node)it.next();</div><div class="line">		<span class="keyword">if</span>(tmp == node) &#123;</div><div class="line">			<span class="keyword">return</span> tmp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="链长先走方法"><a href="#链长先走方法" class="headerlink" title="链长先走方法"></a>链长先走方法</h3><p>这个方法的思路是这样的：</p>
<blockquote>
<ol>
<li>遍历一次，求出链a的长度x，链b的长度y，求出|x-y|=k，这个k是链a和链b的长度差；</li>
<li>让长的链先走k步，这样a、b链剩下的长度都是一样的；</li>
<li>然后a、b一起走，遇到相等的节点，就是它们的交点；如果没相遇，说明没有交点；</li>
</ol>
</blockquote>
<p>这个方法比Set的方法好很多，因为不用用到Set集合，所以快很多。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 链长先走求2链交点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getCrossNode</span><span class="params">(Node headA, Node headB)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="comment">// 链a长度</span></div><div class="line">    <span class="keyword">int</span> y = <span class="number">0</span>; <span class="comment">// 链b长度</span></div><div class="line">    </div><div class="line">    Node tmp = headA; <span class="comment">// 因为后续还要用到headA，所以用临时变量来遍历</span></div><div class="line">    <span class="keyword">while</span>(tmp != <span class="keyword">null</span>) &#123;</div><div class="line">        x++;</div><div class="line">        tmp = tmp.next;</div><div class="line">    &#125;</div><div class="line">    tmp = headB;</div><div class="line">    <span class="keyword">while</span>(tmp != <span class="keyword">null</span>) &#123;</div><div class="line">        y++;</div><div class="line">        tmp = tmp.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> k; <span class="comment">// 链长度差</span></div><div class="line">    <span class="keyword">if</span> (x - y &gt; <span class="number">0</span>) &#123; <span class="comment">// a链长</span></div><div class="line">        k = x - y;</div><div class="line">        </div><div class="line">        <span class="comment">// a链走k步</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</div><div class="line">            headA = headA.next;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        k = y - x;</div><div class="line">        </div><div class="line">        <span class="comment">// b链走k步</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</div><div class="line">            headB = headB.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 这时候，headA指向的子链和headB指向的子链长度一样，一起走</span></div><div class="line">    <span class="keyword">while</span> (headA != <span class="keyword">null</span>) &#123; <span class="comment">// 这里不需要判断headB，因为headA和headB肯定同时为null</span></div><div class="line">        <span class="keyword">if</span>(headA == headB) &#123; <span class="comment">// 相遇的节点是交点</span></div><div class="line">            <span class="keyword">return</span> headA</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        headA = headA.next;</div><div class="line">        headB = headB.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="成环方法"><a href="#成环方法" class="headerlink" title="成环方法"></a>成环方法</h3><p>我们把a链的首尾连接起来，这样a链就形成了一个环。如果a、b链相交，那么从b链来看，链b这个时候就会出现环路，我们可以用上面找环的方法来解决。如下图：<br><img src="https://c1.staticflickr.com/1/583/22236866799_dbacbb5d5e_c.jpg" alt="成环方法求两链交点"></p>
<p>这个方法的思路如下：</p>
<blockquote>
<ol>
<li>把a链的尾部指向a链头部，让其形成一个环；</li>
<li>从b链头部开始遍历，如果b中能找到环，说明ab相交，环的起点即为交点；如果不能找到环，说明无交点；</li>
<li>把a链中的环断开，恢复链a；</li>
</ol>
</blockquote>
<p>这个方法的代码和找环的代码差不多，这里就不写了。</p>
<h2 id="复制带有随机指针的链表-leetcode-138"><a href="#复制带有随机指针的链表-leetcode-138" class="headerlink" title="复制带有随机指针的链表(leetcode 138)"></a>复制带有随机指针的链表(leetcode 138)</h2><p>一个单链表除了next指针外，还有一个random指针，random指针随机指向任何一个元素(可能为null)，然后我们的任务是复制它。</p>
<p>这个复制其实next指针直接用常规方法就能解决，<strong>难点在于random指针，因为我们不知道random指针在复制后的地址-复制元素的地址变了，而且random指向的元素可能还没生成</strong>。</p>
<p>要解决这个问题，我们有2种方法：map集合方法、“副本”方法。</p>
<h3 id="map集合方法"><a href="#map集合方法" class="headerlink" title="map集合方法"></a>map集合方法</h3><p>这个方法的思路是这样的：</p>
<blockquote>
<ol>
<li>先遍历一次原链，用常规方法复制一个新链，使其next指针指向正确的位置，random指针为null；而且在这个过程中，每生成一个新节点，用map来保存旧节点到新节点的映射，类似与map(oldNode, newNode);</li>
<li>再同时遍历原链和新链，在原链中得到节点的random指向的oldNode，然后利用map.get(oldNode)获取newCode，把新链节点的random指向这个newNode；</li>
</ol>
</blockquote>
<p>结合下图：<br><img src="https://c1.staticflickr.com/1/602/22251236159_7a98624fd3_c.jpg" alt="利用map复制带random的链表"></p>
<p>容易知道，这个方法的时间复杂度是O(n)，空间复杂度也是O(n)，效率比较低。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 利用map实现带random指针的链表复制</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NodeWithRandom <span class="title">copyWithRandom</span> <span class="params">(NodeWithRandom h)</span> </span>&#123;</div><div class="line">	NodeWithRandom newNode = <span class="keyword">null</span>;</div><div class="line">	Map&lt;NodeWithRandom, NodeWithRandom&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">	map.put(<span class="keyword">null</span>, <span class="keyword">null</span>); <span class="comment">// 解决random指向null的情况</span></div><div class="line"></div><div class="line">	<span class="comment">// 先用常规方法复制链表</span></div><div class="line">	NodeWithRandom tmp1 = h;</div><div class="line">	NodeWithRandom h2 = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">while</span> (tmp1 != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span>(newNode == <span class="keyword">null</span>) &#123; <span class="comment">// 表头</span></div><div class="line">			newNode = <span class="keyword">new</span> NodeWithRandom(tmp1.value);</div><div class="line">			h2 = newNode;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			newNode.next = <span class="keyword">new</span> NodeWithRandom(tmp1.value);</div><div class="line">			newNode = newNode.next;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		map.put(tmp1, newNode); <span class="comment">// 旧地址到新地址的映射</span></div><div class="line">		tmp1 = tmp1.next;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 再两个链表同时走复制random，a'.random = map[a.random]</span></div><div class="line">	tmp1 = h;</div><div class="line">	NodeWithRandom tmp2 = h2;</div><div class="line">	<span class="keyword">while</span> (tmp1 != <span class="keyword">null</span>) &#123;</div><div class="line">		tmp2.random = map.get(tmp1.random); <span class="comment">// 利用map的映射，将新链表的random指针指向新节点</span></div><div class="line">		tmp1 = tmp1.next;</div><div class="line">		tmp2 = tmp2.next;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> h2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 带random的节点</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeWithRandom</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> value;</div><div class="line">	<span class="keyword">public</span> NodeWithRandom next;</div><div class="line">	<span class="keyword">public</span> NodeWithRandom random;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NodeWithRandom</span> <span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.value = value;</div><div class="line">		<span class="keyword">this</span>.next = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">this</span>.random = <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="“副本”方法"><a href="#“副本”方法" class="headerlink" title="“副本”方法"></a>“副本”方法</h3><p>这个方法的思路主要是：</p>
<blockquote>
<ol>
<li>new副本：在每个旧节点后插入一个当前节点的副本，重新拉成链；</li>
<li>复制random：新节点的random=旧节点random的next；</li>
<li>拆分：奇数项都是旧节点，偶数项都是新节点，提取偶数项成链；</li>
</ol>
</blockquote>
<p>如下图：<br><img src="https://c1.staticflickr.com/1/745/22428455812_4c8560e01e_c.jpg" alt="“副本”方法复制带随机指针的链表"></p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// "副本"方式复制带随机指针链表</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NodeWithRandom <span class="title">copyRandomList</span> <span class="params">(NodeWithRandom head)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 在每个节点后创建副本，拉成链</span></div><div class="line">	NodeWithRandom now = head; </div><div class="line">	<span class="keyword">while</span> (now != <span class="keyword">null</span>) &#123;</div><div class="line">		NodeWithRandom copy = <span class="keyword">new</span> NodeWithRandom(now.value);</div><div class="line">		copy.next = now.next;</div><div class="line">		now.next = copy;</div><div class="line"></div><div class="line">		now = copy.next;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 复制random</span></div><div class="line">	<span class="keyword">for</span> (now = head; now != <span class="keyword">null</span>; now = now.next.next) &#123;</div><div class="line">		now.next.random = now.random == <span class="keyword">null</span> ? <span class="keyword">null</span> : now.random.next; <span class="comment">// 新节点的random=旧节点random的next</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 奇数项为旧节点，偶数项为新节点</span></div><div class="line">	<span class="comment">// 提取出偶数项就是所求</span></div><div class="line">	NodeWithRandom h = head.next; <span class="comment">// 新链头部</span></div><div class="line">	NodeWithRandom t = h; <span class="comment">// 遍历游标</span></div><div class="line">	NodeWithRandom tail = head;</div><div class="line">	<span class="keyword">for</span> (;;) &#123;</div><div class="line">		tail.next = t.next; <span class="comment">// 重连旧节点</span></div><div class="line">		tail = tail.next; <span class="comment">// 移向下一个旧节点</span></div><div class="line">		<span class="keyword">if</span>(tail == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		t.next = tail.next; <span class="comment">// 连接新节点</span></div><div class="line">		t = t.next; <span class="comment">// 移向下一个新节点</span></div><div class="line">	&#125; </div><div class="line"></div><div class="line">	<span class="keyword">return</span> h;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="链表partition过程-leetcode-86"><a href="#链表partition过程-leetcode-86" class="headerlink" title="链表partition过程(leetcode 86)"></a>链表partition过程(leetcode 86)</h2><p>链表里存放整数，给定x，把x小的节点放在&gt;=x之前，这就是一个partition过程，数组在partition的过程就是这样做的。然而链表和数组不同的是，在patition的过程中，链表没必要赋值来赋值去，而是重新起一个头，把比x小的连起来，把&gt;=x的连成另外一条链，最后再把这2条链连起来就是了。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 链表的partition过程</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Node</span><span class="params">(Node head, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    Node h1 = <span class="keyword">null</span>; <span class="comment">// 小子链头部</span></div><div class="line">    Node h2 = <span class="keyword">null</span>; <span class="comment">// 大子链头部</span></div><div class="line">    Node t1 = <span class="keyword">null</span>; <span class="comment">// 小子链尾部</span></div><div class="line">    Node t2 = <span class="keyword">null</span>; <span class="comment">// 大子链尾部</span></div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (; head != <span class="keyword">null</span>; head = head.next) &#123;</div><div class="line">        <span class="keyword">if</span> (head.val &lt; x) &#123; <span class="comment">// 比x小</span></div><div class="line">            <span class="keyword">if</span> (h1 = <span class="keyword">null</span>) &#123; <span class="comment">// 头部</span></div><div class="line">                h1 = head;</div><div class="line">                t1 = head;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                t1.next = head;</div><div class="line">                t1 = t1.next;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (h2 == <span class="keyword">null</span>) &#123;</div><div class="line">                h2 = head;</div><div class="line">                t2 = head;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                t2.next = head;</div><div class="line">                t2 = t2.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (t2 != <span class="keyword">null</span>) &#123; <span class="comment">// 大子链有节点</span></div><div class="line">        t2.next = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(t1 != <span class="keyword">null</span>) &#123; <span class="comment">// 小子链有节点</span></div><div class="line">        t1.next = h2;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> h1 != <span class="keyword">null</span> ? h1 : h2;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面可以看出，涉及链表的问题，大部分都可以用快慢指针或集合的方式来解决，所以遇到这种问题可以往这方面考虑。由于链表实在非常灵活，所以具体的问题还是得灵活处理。</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://wuchong.me/blog/2014/03/25/interview-link-questions/" target="_blank" rel="external">面试精选：链表问题集锦</a></li>
<li><a href="http://www.julyedu.com/video/play/?id=31&amp;course=25" target="_blank" rel="external">七月算法：链表面试精讲</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png"
               alt="archerda" />
          <p class="site-author-name" itemprop="name">archerda</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">64</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/archerda" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:luo.archer@gmail.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Email
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">archerda</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
