<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="archerda, ArcherdaArcherda's BlogHexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Archerda&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Archerda&#39;s Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Archerda&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>Archerda's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Archerda's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Programmer. Meditating.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/11/Intellij-IDEA部署本地Tomcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/11/Intellij-IDEA部署本地Tomcat/" itemprop="url">Intellij IDEA部署本地Tomcat</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-11T22:15:36+08:00">
                2015-11-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一直以来用Eclipse都是用本地tomcat、IDEA都是tomcat/jetty的maven插件的方式来跑Web工程。之前使用让IDEA用本地tomcat的方式来运行却没成功，一直困惑不已。然而今天公司需要这样做，问了下同事终于把这问题解决了。所以记录下！</p>
<h2 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h2><h3 id="安装本地Tomcat"><a href="#安装本地Tomcat" class="headerlink" title="安装本地Tomcat"></a>安装本地Tomcat</h3><p>Tomcat和JDK的安装可以查看这里<a href="http://www.cnblogs.com/pannysp/archive/2012/03/07/2383364.html" target="_blank" rel="external">win7下安装配置tomcat,java运行环境</a>,具体的就不啰嗦了，这个步骤应该都操作过很多次了。但这是基础，jdk和tomcat没配好，接下来的所有工作都无法进行。</p>
<h3 id="安装Tomcat-and-TomEE-Integration"><a href="#安装Tomcat-and-TomEE-Integration" class="headerlink" title="安装Tomcat and TomEE Integration"></a>安装Tomcat and TomEE Integration</h3><p>因为IDEA要依赖”<strong>Tomcat and TomEE Integration</strong>“这个插件来运行tomcat，所以我们的IDEA必须要进行安装。ULTIMATE版本的已经自带了，社区版的好像要自己装 。可以在工具栏的<code>Run-&gt;Edit Configurations</code>，在弹出来的界面中点击<code>+</code>，输入<code>tomcat</code>看是否有<code>Tomcat Server</code>，有的话就是已经安装了，没有的话就去<code>Settings</code>里的插件中心安装即可。<br><img src="https://c1.staticflickr.com/1/773/22272123843_82e7e3a187_c.jpg" alt=""></p>
<h3 id="验证Project的Artifacts"><a href="#验证Project的Artifacts" class="headerlink" title="验证Project的Artifacts"></a>验证Project的Artifacts</h3><p>打开Project的<code>Module Setting(F4)</code>，看<code>Artifacts</code>里是不是有<code>&lt;project_name&gt;:war</code>和<code>&lt;project_name&gt;:war exploded</code>，如果你的是Web工程，一般都会有。如果没有就检查下是否是Web工程。<br><img src="https://c1.staticflickr.com/1/757/22883412036_19caf37b3b_c.jpg" alt=""></p>
<h3 id="添加服务器配置"><a href="#添加服务器配置" class="headerlink" title="添加服务器配置"></a>添加服务器配置</h3><p>依次打开<code>Run -&gt; Edit Configurations -&gt; + -&gt; Tomcat Server -&gt; Local</code>，输入如下图中的配置。<br><img src="https://c2.staticflickr.com/6/5720/22893261735_31e829dae6_c.jpg" alt=""><br><img src="https://c1.staticflickr.com/1/737/22474938568_aab1510c02_c.jpg" alt=""></p>
<h2 id="配置热部署"><a href="#配置热部署" class="headerlink" title="配置热部署"></a>配置热部署</h2><p>在服务器的配置过程中，热部署是一个很常用的功能。如果没有配置热部署，那么你每修改一个java文件，甚至一个jsp文件，都必须手动restart server，那将是多么痛苦的一件事。</p>
<p>上面的图中，<strong>On ‘Update’ action</strong>是你点击Update按钮后的动作。而<strong>On frame deactivation</strong>是热部署的关键，为了实现热部署我们应该把它设置为<strong>Update classed and resources</strong>。 但是有时候我们发觉只有Do nothing、Update resources这两个选项，并没有Update classed and resources这个选项。其实这是因为我们的war包是选了 <code>&lt;project_name&gt;:war</code>这个，只要选回<code>&lt;project_name&gt;:war exploded</code>这个就可以了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实本地tomcat的运行关键是依靠war包，而这个war包IDEA默认已经帮我们配置好了。所以把这个war包添加到tomcat的配置中就可以run on local了。</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://blog.csdn.net/dandandeshangni/article/details/44057871" target="_blank" rel="external">CSDN:idea 修改jsp页面需要重新部署项目的额问题</a></li>
<li><a href="http://www.cnblogs.com/pannysp/archive/2012/03/07/2383364.html" target="_blank" rel="external">win7下安装配置tomcat,java运行环境</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/25/链表-常见面试问题总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/25/链表-常见面试问题总结/" itemprop="url">链表-常见面试问题总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-25T02:56:01+08:00">
                2015-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近这段时间都在忙活校招，在面试的过程中遇到了很多有关链表的问题，由于以前没怎么搞过ACM，数据结构也忘的七七八八了，所以总体感觉回答得不是很好。昨天把链表的基础回顾了下，见这里<a href="http://www.luohuida.com/2015/10/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">单链表的基础操作</a>，于是今天把面试过程中经常遇到的链表相关的问题总结下。</p>
<h2 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h2><p>单链表的反转是面试的常用考点，所以必须掌握。思路是<strong>把当前节点拿过来作为已经翻转的表头，成为一个已翻转的子链，用result指向其头部（也就是当前节点）</strong>。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 反转单链表</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">traversingReverse</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">	Node result = <span class="keyword">null</span>;</div><div class="line">	Node temp = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 头反转法：把当前节点拿过来作为已经翻转结果的表头</span></div><div class="line">	<span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">		temp = head.next; <span class="comment">// 保存下一个节点</span></div><div class="line">		head.next = result; <span class="comment">// 当前节点放在结果的开头</span></div><div class="line">		result = head; <span class="comment">// 当前节点的头</span></div><div class="line">		head = temp; <span class="comment">// head指向下一个节点</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="懒删除-在O-1-时间删除链表节点"><a href="#懒删除-在O-1-时间删除链表节点" class="headerlink" title="懒删除(在O(1)时间删除链表节点)"></a>懒删除(在O(1)时间删除链表节点)</h2><p>有一种情况，当我们的now引用指向某一个节点的时候，我们需要删除该节点。然而如果不知道now节点的前驱节点，一般方法是无法删除now这个节点的。</p>
<p>这个时候，我们可以使用“懒”删除，这种方法的思想是：<strong>把now节点后驱节点的值赋给now节点，然后now节点的next指向的它后驱节点的下一个节点</strong>。因为不用遍历，所以这个算法的时间复杂度是O(1)。然而要注意的是尾节点，当now节点就是尾节点的时候，这种办法就行不通了。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// O(1)复杂度删除某个节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lazyDelete</span><span class="params">(Node now)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(now.next != <span class="keyword">null</span>) &#123; <span class="comment">// ①非尾节点</span></div><div class="line">        now.value = now.next.value; <span class="comment">// 复制后驱节点的值</span></div><div class="line">        now.next = now.next.next; <span class="comment">// “删除”后驱节点</span></div><div class="line">    &#125;  <span class="keyword">else</span>&#123; <span class="comment">// ②尾节点，行不通</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="求链表倒数第k个节点"><a href="#求链表倒数第k个节点" class="headerlink" title="求链表倒数第k个节点"></a>求链表倒数第k个节点</h2><p>经常会遇到求单链表倒数第几个节点的问题，如果按常规方法的话，我们需要先遍历整个链表，记录下节点个数，假设为n，然后再遍历一遍，第n-k+1个就是所求节点了。可是这个方法效率太低，需要两次遍历，有没有更加高效的方法呢？答案是肯定的。我们可以用 <strong>快慢指针</strong> 来解决这个问题，这个方法的思想是这样的：</p>
<blockquote>
<ul>
<li>假设有引用fast、slow，开始都指向首节点;</li>
<li>fast先走k次，这样fast和slow就相隔了k个节点;</li>
<li>然后fast、slow一起走，当fast走到链表末尾为null的时候，slow就是所求节点了。</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 求单链表倒数第k个节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getKNode</span><span class="params">(Node head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    Node fast = head;</div><div class="line">    Node slow = head;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(; i &lt; k &amp;&amp; fast != <span class="keyword">null</span>; i++) &#123;</div><div class="line">        fast = fast.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(i != k) &#123;</div><div class="line">        System.out.println(k + <span class="string">"位置超出链表长度"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span>) &#123;</div><div class="line">        fast = fast.next;</div><div class="line">        slow = slow.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> slow;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="求链表的中间节点"><a href="#求链表的中间节点" class="headerlink" title="求链表的中间节点"></a>求链表的中间节点</h2><p>如果要求一个链表的中间节点，常规的方法是先遍历一次获取链表的长度n，如果n是偶数就n/2、n/2+1都可以，如果n是奇数，那就第n/2+1个。可是这个方法的效率也是非常低。</p>
<p>其实通过上面找用快慢指针的方法来找倒数第k个数，我们可以衍生到这里来。这个方法的思路是这样的：</p>
<blockquote>
<ul>
<li>假设有引用fast、slow，开始都指向首节点;</li>
<li>fast、slow同时走，但是fast每次走2步，slow每次走1步；</li>
<li>当fast走到链表末尾时，slow就是中间节点；</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 求链表的中间节点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getMiddleNode</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Node fast = head;</div><div class="line">    Node slow = head;</div><div class="line">    </div><div class="line">    <span class="comment">// ①如果fast==null的话，说明是偶数个；而fast.next==null的话，说明是奇数个</span></div><div class="line">    <span class="comment">// ①条件返回的是偶数情况中的后者，如果要返回前者，可用下面判断条件：</span></div><div class="line">    <span class="comment">// while (fast != null &amp;&amp; fast.next != null &amp;&amp; fast.next.next != null)</span></div><div class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123; <span class="comment">// ①</span></div><div class="line">        fast = fast.next.next; <span class="comment">// 快指针走2步</span></div><div class="line">        slow = slow.next; <span class="comment">// 慢指针走1步</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> slow;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="单链表是否存在环-leetcode-141"><a href="#单链表是否存在环-leetcode-141" class="headerlink" title="单链表是否存在环(leetcode 141)"></a>单链表是否存在环(leetcode 141)</h2><p>其实判断单链表是否有环有2种方法，第一种是用Set集合的方法，第二种是用快慢指针的方法。</p>
<h3 id="利用HashSet集合"><a href="#利用HashSet集合" class="headerlink" title="利用HashSet集合"></a>利用HashSet集合</h3><p>这个方法的思想很简单，就是<strong>遍历该链表，每走一次，就判断HashSet中是否存在该节点，如果存在则说明有环，结束；如果不存在，说明还没有环，把该节点放到HashSet中去，直到链表的末尾</strong>。如果利用的是HashSet，则该算法的时间复杂度也是O(n)，就是空间复杂度大了点。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 利用HashMap判断是否有环</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCircle</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    Set&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">    	<span class="keyword">if</span>(getFromSet(set, head) != <span class="keyword">null</span>) &#123;</div><div class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    	&#125;</div><div class="line">    	</div><div class="line">    	set.add(head);</div><div class="line">    	head = head.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 由于Set没有提供get()方法，所以自己实现一个</span></div><div class="line"><span class="comment">// 缘何Set不提供get()？？？</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getFromSet</span><span class="params">(Set&lt;Node&gt; set, Node node)</span> </span>&#123;</div><div class="line">	Iterator it = set.iterator();</div><div class="line">	Node tmp;</div><div class="line"></div><div class="line">	<span class="keyword">while</span>(it.hasNext()) &#123;</div><div class="line">		tmp = (Node)it.next();</div><div class="line">		<span class="keyword">if</span>(tmp == node) &#123;</div><div class="line">			<span class="keyword">return</span> tmp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="利用快慢指针"><a href="#利用快慢指针" class="headerlink" title="利用快慢指针"></a>利用快慢指针</h3><p>上面的方法实现起来很简单高效，但是却需要额外的空间，空间复杂度是O(n)，而快慢指针是一个更高效的方法。<strong>让快指针每次走2步，慢指针每次走1步，两个指针的速度不一样，如果存在环的话，那么最后快慢指针肯定会相遇</strong>。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 利用快慢指针判断链表是否有环</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCircle</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    Node fast = head;</div><div class="line">    Node slow = head;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</div><div class="line">        fast = fast.next.next;</div><div class="line">        slow = slow.next;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (fast == slow) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="单链表中环的起点-leetcode-142"><a href="#单链表中环的起点-leetcode-142" class="headerlink" title="单链表中环的起点(leetcode 142)"></a>单链表中环的起点(leetcode 142)</h2><p><img src="https://c1.staticflickr.com/1/620/22399861952_2440672711_c.jpg" alt="快慢指针求环起点"><br>假设链表中存在环，我们先设定几个参数：n(环的长度=7)、a(链表起点到环起点的距离=3)、x(fast指针到环起点的时候，slow指针在环中的位置0 &lt;= x &lt; n)，由此我们可以推出下面几个性质：</p>
<blockquote>
<ol>
<li>slow到起点(s3)的时候，fast在环中走了x步(f3)，那么fast和slow相差 n - x 步，也就是说 n - x 步后，fast会追上slow；</li>
<li>经过 n - x 步后(4步)，fast和slow在环中M点相遇(f7与s7)；</li>
<li>假设这时候相遇点M与环起点的距离为b(=4)，则slow走过的距离是 a + b ，而fast走过的距离为 a + b + k <em> n 。显然fast走的长度是slow的2倍，所以2 </em> ( a + b ) = a + b + k <em> n，则 **a + b = k </em> n**；</li>
<li>把fast指针拉回链表的起始点，这时候fast和slow每次都走一步，经过a步后，fast和slow在环的起始点相遇。</li>
</ol>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用快慢指针求环起点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listCircleStart</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    <span class="comment">// 空链或者单节点，不存在环</span></div><div class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Node fast = head;</div><div class="line">    Node slow = head;</div><div class="line">    </div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123; <span class="comment">// 无环</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        fast = fast.next.next; <span class="comment">// 走2步</span></div><div class="line">        slow = slow.next; <span class="comment">// 走1步</span></div><div class="line">    &#125; <span class="keyword">while</span> (fast != slow) <span class="comment">// 直到fast和slow相遇</span></div><div class="line">    </div><div class="line">    fast = head; <span class="comment">// 重新拉回链表起点</span></div><div class="line">    <span class="keyword">while</span> (fast != slow) &#123; <span class="comment">// 相遇即为环起点</span></div><div class="line">        fast = fast.next; <span class="comment">// 走1步</span></div><div class="line">        slow = slow.next; <span class="comment">// 走1步</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> fast;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="单链表中环的长度"><a href="#单链表中环的长度" class="headerlink" title="单链表中环的长度"></a>单链表中环的长度</h2><p>在上面，我们找到环的起点后，再用slow指针走一遍，就可以算出环的长度了。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用快慢指针求环长度</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">listCircleLength</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    Node cicleStart = listCircleStart(head); <span class="comment">// 先利用上面的方法求出环起点</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(cicleStart == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Node tmp = cicleStart.next;</div><div class="line">    <span class="keyword">int</span> counter = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (tmp != cicleStart) &#123; <span class="comment">// 重走一遍，直到回到环起点</span></div><div class="line">        counter++;</div><div class="line">        tmp = tmp.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="两个链表是否相交并求出交点-leetcode-160"><a href="#两个链表是否相交并求出交点-leetcode-160" class="headerlink" title="两个链表是否相交并求出交点(leetcode 160)"></a>两个链表是否相交并求出交点(leetcode 160)</h2><p>给定2个链表，判断这两个链表是否相交，如果相交的话，就类似于一个向左翻转90°的Y。见下图：<br><img src="https://c1.staticflickr.com/1/649/22234956790_1986323deb_c.jpg" alt="相交链表"></p>
<p>这个问题相比环来说简单很多，我们可以用Set集合方法、链长先走方法、成环方法来解决。下面我们逐一来看。</p>
<h3 id="Set集合方法"><a href="#Set集合方法" class="headerlink" title="Set集合方法"></a>Set集合方法</h3><p>这个方法的思路最简单：</p>
<blockquote>
<ol>
<li>先遍历a链，依次把所有节点放入到Set中去；</li>
<li>然后遍历b链，每到一个节点，就去Set看是否存在该节点，如果存在，则说明有交点，而交点就是该节点(第一个相等的肯定是交点)；</li>
<li>如果直到b链的末尾都没有相等节点，则说明没有交点；</li>
</ol>
</blockquote>
<p>这个方法其实比较笨，效率也比较低。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 利用Set求2链表交点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getCrossNode</span><span class="params">(Node headA, Node headB)</span> </span>&#123;</div><div class="line">    Set&lt;Node&gt; set = <span class="keyword">new</span> Hash&lt;&gt;();</div><div class="line">    </div><div class="line">    <span class="comment">// 把a链全部放入Set中</span></div><div class="line">    <span class="keyword">while</span> (headA != <span class="keyword">null</span>) &#123;</div><div class="line">        set.add(headA);</div><div class="line">        headA = headA.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 遍历b链</span></div><div class="line">    <span class="keyword">while</span> (headB != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(set.getFromSet(set, headB) != <span class="keyword">null</span>) &#123; <span class="comment">// 相交</span></div><div class="line">            <span class="keyword">return</span> headB;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getFromSet</span><span class="params">(Set&lt;Node&gt; set, Node node)</span> </span>&#123;</div><div class="line">	Iterator it = set.iterator();</div><div class="line">	Node tmp;</div><div class="line"></div><div class="line">	<span class="keyword">while</span>(it.hasNext()) &#123;</div><div class="line">		tmp = (Node)it.next();</div><div class="line">		<span class="keyword">if</span>(tmp == node) &#123;</div><div class="line">			<span class="keyword">return</span> tmp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="链长先走方法"><a href="#链长先走方法" class="headerlink" title="链长先走方法"></a>链长先走方法</h3><p>这个方法的思路是这样的：</p>
<blockquote>
<ol>
<li>遍历一次，求出链a的长度x，链b的长度y，求出|x-y|=k，这个k是链a和链b的长度差；</li>
<li>让长的链先走k步，这样a、b链剩下的长度都是一样的；</li>
<li>然后a、b一起走，遇到相等的节点，就是它们的交点；如果没相遇，说明没有交点；</li>
</ol>
</blockquote>
<p>这个方法比Set的方法好很多，因为不用用到Set集合，所以快很多。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 链长先走求2链交点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getCrossNode</span><span class="params">(Node headA, Node headB)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="comment">// 链a长度</span></div><div class="line">    <span class="keyword">int</span> y = <span class="number">0</span>; <span class="comment">// 链b长度</span></div><div class="line">    </div><div class="line">    Node tmp = headA; <span class="comment">// 因为后续还要用到headA，所以用临时变量来遍历</span></div><div class="line">    <span class="keyword">while</span>(tmp != <span class="keyword">null</span>) &#123;</div><div class="line">        x++;</div><div class="line">        tmp = tmp.next;</div><div class="line">    &#125;</div><div class="line">    tmp = headB;</div><div class="line">    <span class="keyword">while</span>(tmp != <span class="keyword">null</span>) &#123;</div><div class="line">        y++;</div><div class="line">        tmp = tmp.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> k; <span class="comment">// 链长度差</span></div><div class="line">    <span class="keyword">if</span> (x - y &gt; <span class="number">0</span>) &#123; <span class="comment">// a链长</span></div><div class="line">        k = x - y;</div><div class="line">        </div><div class="line">        <span class="comment">// a链走k步</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</div><div class="line">            headA = headA.next;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        k = y - x;</div><div class="line">        </div><div class="line">        <span class="comment">// b链走k步</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</div><div class="line">            headB = headB.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 这时候，headA指向的子链和headB指向的子链长度一样，一起走</span></div><div class="line">    <span class="keyword">while</span> (headA != <span class="keyword">null</span>) &#123; <span class="comment">// 这里不需要判断headB，因为headA和headB肯定同时为null</span></div><div class="line">        <span class="keyword">if</span>(headA == headB) &#123; <span class="comment">// 相遇的节点是交点</span></div><div class="line">            <span class="keyword">return</span> headA</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        headA = headA.next;</div><div class="line">        headB = headB.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="成环方法"><a href="#成环方法" class="headerlink" title="成环方法"></a>成环方法</h3><p>我们把a链的首尾连接起来，这样a链就形成了一个环。如果a、b链相交，那么从b链来看，链b这个时候就会出现环路，我们可以用上面找环的方法来解决。如下图：<br><img src="https://c1.staticflickr.com/1/583/22236866799_dbacbb5d5e_c.jpg" alt="成环方法求两链交点"></p>
<p>这个方法的思路如下：</p>
<blockquote>
<ol>
<li>把a链的尾部指向a链头部，让其形成一个环；</li>
<li>从b链头部开始遍历，如果b中能找到环，说明ab相交，环的起点即为交点；如果不能找到环，说明无交点；</li>
<li>把a链中的环断开，恢复链a；</li>
</ol>
</blockquote>
<p>这个方法的代码和找环的代码差不多，这里就不写了。</p>
<h2 id="复制带有随机指针的链表-leetcode-138"><a href="#复制带有随机指针的链表-leetcode-138" class="headerlink" title="复制带有随机指针的链表(leetcode 138)"></a>复制带有随机指针的链表(leetcode 138)</h2><p>一个单链表除了next指针外，还有一个random指针，random指针随机指向任何一个元素(可能为null)，然后我们的任务是复制它。</p>
<p>这个复制其实next指针直接用常规方法就能解决，<strong>难点在于random指针，因为我们不知道random指针在复制后的地址-复制元素的地址变了，而且random指向的元素可能还没生成</strong>。</p>
<p>要解决这个问题，我们有2种方法：map集合方法、“副本”方法。</p>
<h3 id="map集合方法"><a href="#map集合方法" class="headerlink" title="map集合方法"></a>map集合方法</h3><p>这个方法的思路是这样的：</p>
<blockquote>
<ol>
<li>先遍历一次原链，用常规方法复制一个新链，使其next指针指向正确的位置，random指针为null；而且在这个过程中，每生成一个新节点，用map来保存旧节点到新节点的映射，类似与map(oldNode, newNode);</li>
<li>再同时遍历原链和新链，在原链中得到节点的random指向的oldNode，然后利用map.get(oldNode)获取newCode，把新链节点的random指向这个newNode；</li>
</ol>
</blockquote>
<p>结合下图：<br><img src="https://c1.staticflickr.com/1/602/22251236159_7a98624fd3_c.jpg" alt="利用map复制带random的链表"></p>
<p>容易知道，这个方法的时间复杂度是O(n)，空间复杂度也是O(n)，效率比较低。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 利用map实现带random指针的链表复制</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NodeWithRandom <span class="title">copyWithRandom</span> <span class="params">(NodeWithRandom h)</span> </span>&#123;</div><div class="line">	NodeWithRandom newNode = <span class="keyword">null</span>;</div><div class="line">	Map&lt;NodeWithRandom, NodeWithRandom&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">	map.put(<span class="keyword">null</span>, <span class="keyword">null</span>); <span class="comment">// 解决random指向null的情况</span></div><div class="line"></div><div class="line">	<span class="comment">// 先用常规方法复制链表</span></div><div class="line">	NodeWithRandom tmp1 = h;</div><div class="line">	NodeWithRandom h2 = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">while</span> (tmp1 != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span>(newNode == <span class="keyword">null</span>) &#123; <span class="comment">// 表头</span></div><div class="line">			newNode = <span class="keyword">new</span> NodeWithRandom(tmp1.value);</div><div class="line">			h2 = newNode;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			newNode.next = <span class="keyword">new</span> NodeWithRandom(tmp1.value);</div><div class="line">			newNode = newNode.next;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		map.put(tmp1, newNode); <span class="comment">// 旧地址到新地址的映射</span></div><div class="line">		tmp1 = tmp1.next;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 再两个链表同时走复制random，a'.random = map[a.random]</span></div><div class="line">	tmp1 = h;</div><div class="line">	NodeWithRandom tmp2 = h2;</div><div class="line">	<span class="keyword">while</span> (tmp1 != <span class="keyword">null</span>) &#123;</div><div class="line">		tmp2.random = map.get(tmp1.random); <span class="comment">// 利用map的映射，将新链表的random指针指向新节点</span></div><div class="line">		tmp1 = tmp1.next;</div><div class="line">		tmp2 = tmp2.next;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> h2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 带random的节点</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeWithRandom</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> value;</div><div class="line">	<span class="keyword">public</span> NodeWithRandom next;</div><div class="line">	<span class="keyword">public</span> NodeWithRandom random;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NodeWithRandom</span> <span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.value = value;</div><div class="line">		<span class="keyword">this</span>.next = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">this</span>.random = <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="“副本”方法"><a href="#“副本”方法" class="headerlink" title="“副本”方法"></a>“副本”方法</h3><p>这个方法的思路主要是：</p>
<blockquote>
<ol>
<li>new副本：在每个旧节点后插入一个当前节点的副本，重新拉成链；</li>
<li>复制random：新节点的random=旧节点random的next；</li>
<li>拆分：奇数项都是旧节点，偶数项都是新节点，提取偶数项成链；</li>
</ol>
</blockquote>
<p>如下图：<br><img src="https://c1.staticflickr.com/1/745/22428455812_4c8560e01e_c.jpg" alt="“副本”方法复制带随机指针的链表"></p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// "副本"方式复制带随机指针链表</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NodeWithRandom <span class="title">copyRandomList</span> <span class="params">(NodeWithRandom head)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 在每个节点后创建副本，拉成链</span></div><div class="line">	NodeWithRandom now = head; </div><div class="line">	<span class="keyword">while</span> (now != <span class="keyword">null</span>) &#123;</div><div class="line">		NodeWithRandom copy = <span class="keyword">new</span> NodeWithRandom(now.value);</div><div class="line">		copy.next = now.next;</div><div class="line">		now.next = copy;</div><div class="line"></div><div class="line">		now = copy.next;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 复制random</span></div><div class="line">	<span class="keyword">for</span> (now = head; now != <span class="keyword">null</span>; now = now.next.next) &#123;</div><div class="line">		now.next.random = now.random == <span class="keyword">null</span> ? <span class="keyword">null</span> : now.random.next; <span class="comment">// 新节点的random=旧节点random的next</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 奇数项为旧节点，偶数项为新节点</span></div><div class="line">	<span class="comment">// 提取出偶数项就是所求</span></div><div class="line">	NodeWithRandom h = head.next; <span class="comment">// 新链头部</span></div><div class="line">	NodeWithRandom t = h; <span class="comment">// 遍历游标</span></div><div class="line">	NodeWithRandom tail = head;</div><div class="line">	<span class="keyword">for</span> (;;) &#123;</div><div class="line">		tail.next = t.next; <span class="comment">// 重连旧节点</span></div><div class="line">		tail = tail.next; <span class="comment">// 移向下一个旧节点</span></div><div class="line">		<span class="keyword">if</span>(tail == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		t.next = tail.next; <span class="comment">// 连接新节点</span></div><div class="line">		t = t.next; <span class="comment">// 移向下一个新节点</span></div><div class="line">	&#125; </div><div class="line"></div><div class="line">	<span class="keyword">return</span> h;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="链表partition过程-leetcode-86"><a href="#链表partition过程-leetcode-86" class="headerlink" title="链表partition过程(leetcode 86)"></a>链表partition过程(leetcode 86)</h2><p>链表里存放整数，给定x，把x小的节点放在&gt;=x之前，这就是一个partition过程，数组在partition的过程就是这样做的。然而链表和数组不同的是，在patition的过程中，链表没必要赋值来赋值去，而是重新起一个头，把比x小的连起来，把&gt;=x的连成另外一条链，最后再把这2条链连起来就是了。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 链表的partition过程</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Node</span><span class="params">(Node head, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    Node h1 = <span class="keyword">null</span>; <span class="comment">// 小子链头部</span></div><div class="line">    Node h2 = <span class="keyword">null</span>; <span class="comment">// 大子链头部</span></div><div class="line">    Node t1 = <span class="keyword">null</span>; <span class="comment">// 小子链尾部</span></div><div class="line">    Node t2 = <span class="keyword">null</span>; <span class="comment">// 大子链尾部</span></div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (; head != <span class="keyword">null</span>; head = head.next) &#123;</div><div class="line">        <span class="keyword">if</span> (head.val &lt; x) &#123; <span class="comment">// 比x小</span></div><div class="line">            <span class="keyword">if</span> (h1 = <span class="keyword">null</span>) &#123; <span class="comment">// 头部</span></div><div class="line">                h1 = head;</div><div class="line">                t1 = head;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                t1.next = head;</div><div class="line">                t1 = t1.next;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (h2 == <span class="keyword">null</span>) &#123;</div><div class="line">                h2 = head;</div><div class="line">                t2 = head;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                t2.next = head;</div><div class="line">                t2 = t2.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (t2 != <span class="keyword">null</span>) &#123; <span class="comment">// 大子链有节点</span></div><div class="line">        t2.next = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(t1 != <span class="keyword">null</span>) &#123; <span class="comment">// 小子链有节点</span></div><div class="line">        t1.next = h2;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> h1 != <span class="keyword">null</span> ? h1 : h2;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面可以看出，涉及链表的问题，大部分都可以用快慢指针或集合的方式来解决，所以遇到这种问题可以往这方面考虑。由于链表实在非常灵活，所以具体的问题还是得灵活处理。</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://wuchong.me/blog/2014/03/25/interview-link-questions/" target="_blank" rel="external">面试精选：链表问题集锦</a></li>
<li><a href="http://www.julyedu.com/video/play/?id=31&amp;course=25" target="_blank" rel="external">七月算法：链表面试精讲</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/14/单链表的基础操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/14/单链表的基础操作/" itemprop="url">单链表的基础操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-14T00:01:36+08:00">
                2015-10-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们知道，线性表分为顺序表和链式表。顺序表是基于数组的存储表示，其特点是用物理位置上的邻接关系来表示结点间的逻辑关系。但是基于数组的顺序表的缺点也非常明显，比如说插入/删除的效率低下（平均需要移动一半元素）、需要预先进行存储分配等。</p>
<p>为了克服顺序表的缺点，可以采用链接方式来存储线性表，通常将链接方式的线性表称为链表。<strong>链表适用于插入/删除频繁，存储空间不确定的场景</strong>。单链表的特点是<strong>长度可以很方便地进行扩充，其数据元素的顺序与其链表表示中节点的物理顺序可能不一致，一般通过单链表的指针将各个数据元素按照线性表的逻辑顺序连接起来</strong>，如下图：<br><img src="https://c1.staticflickr.com/1/631/21509590143_579b0d0b40_z.jpg" alt="单链表示意图"></p>
<p>由于链表的每个节点带有指针域(引用)，因而在存储空间上比顺序表要付出较大的代价。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>创建单链表主要有前插和后插两种方法，建立的方式不同，最终得到的链表也不相同。</p>
<h3 id="前插法建立单链表"><a href="#前插法建立单链表" class="headerlink" title="前插法建立单链表"></a>前插法建立单链表</h3><p>前插法是指每次插入新节点总是在表的前端进行，这样插入的结果是<strong>链表中各节点中数据的逻辑顺序与输入顺序是正好相反的</strong>。其主要步骤如下：</p>
<blockquote>
<ol>
<li>生成新节点newNode，将读入数据存放到newNode的data域中；</li>
<li>将newNode插入到链表的前端；</li>
</ol>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 建立链表</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">buildList</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">	Node first = <span class="keyword">null</span>;</div><div class="line">	Node newNode = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 头插入法</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">		newNode = <span class="keyword">new</span> Node(i);</div><div class="line">		newNode.next = first;</div><div class="line">		first = newNode;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> first;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="后插法建立单链表"><a href="#后插法建立单链表" class="headerlink" title="后插法建立单链表"></a>后插法建立单链表</h3><p>后插法是指每次newNode总是插入到链表的尾端，这样插入的结果，链表中各个节点的逻辑顺序和输入数据的顺序是完全一致的。这个方法需要设置一个<strong>尾指针last</strong>，总是指向新链表中最后一个节点，新节点连接到它所指链尾的后面。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">buildListLast</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">	Node first = <span class="keyword">null</span>;</div><div class="line">	Node last = <span class="keyword">null</span>;</div><div class="line">	Node now = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 后插法</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">		now = <span class="keyword">new</span> Node(i);</div><div class="line">		now.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(first == <span class="keyword">null</span>) &#123;				</div><div class="line">			first = now;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			last.next = now;				</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		last = now;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> first;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>利用单链表来表示线性表，将使得插入和删除变得非常方便，只要修改链中节点指针或引用的值，无需移动表中的元素，就能高效地实现插入和删除操作。</p>
<p>对于插入，我们希望在单链表（a1，a2，a3，…an）的包含数据ai的节点之后插入一个newNode，那么可能会出现3种情况：</p>
<ol>
<li><p>插入到链表头部。这个时候newNode应插入在<strong>第一个节点之前</strong>，如下图a所示。这时必须修改头指针first。插入操作为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">newNode.next = first；</div><div class="line">first = newNode;</div></pre></td></tr></table></figure>
</li>
<li><p>插入到链表中间。此时，首先让一个<strong>检测指针current</strong>指向ai所在节点，再将新节点插入到ai之后，如下图b所示。插入操作为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">newNode.next = current.next;</div><div class="line">current.next = newNode;</div></pre></td></tr></table></figure>
</li>
<li><p>插入到链表尾端。新节点追加到表尾，如下图c所示。这时，应先令检测指针current指向最后一个节点an，再执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">newNode.next = current.next;</div><div class="line">current.next = newNode;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://c2.staticflickr.com/6/5658/21510886033_db7ebd8b1b_z.jpg" alt="链表插入的示例"></p>
<p>从上面可以看出，2和3情形的操作一致，所以这2中情况可以合并考虑。综上，最后可得单链表的插入算法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将新元素插入到第index个节点之后。index从1开始，index = 0表示插入到第一个节点之前</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">insert</span><span class="params">(Node first, Node newNode, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">	<span class="comment">// ①如果链表为空，或者插入的索引为0，则插入到前端</span></div><div class="line">	<span class="keyword">if</span>(first == <span class="keyword">null</span> || index == <span class="number">0</span>) &#123;</div><div class="line">		newNode.next = first;</div><div class="line">		first = newNode;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		Node current = first;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; index; k++) &#123;</div><div class="line">			<span class="keyword">if</span>(current == <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				current = current.next;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(current == <span class="keyword">null</span>) &#123;</div><div class="line">			System.out.println(<span class="string">"无效的插入位置"</span>);</div><div class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//  ②插入中间或尾部</span></div><div class="line">			newNode.next = current.next;</div><div class="line">			current.next = newNode;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> first;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>单链表的删除算法比较简单，但也分为2种情况：</p>
<ol>
<li><p>删除头部。这时需要用一个del引用先保存头部节点，再将表头引用指向下一个节点，使其成为新链表的头部，最后删除del保存的节点。如下图a所示。删除操作为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Node del = first;</div><div class="line">first = first.next;</div><div class="line">del = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>删除中间节点或尾部。设删除链表中的第i个节点，首先用引用del保存第i个节点，再让第i-1个节点的next引用指向第i+1个节点，通过重新拉链，把第i个节点从链表中分离出来，最后删除del引用的节点。如下图b所示。删除操作为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Node del = current.next;</div><div class="line">current.next = del.next;</div><div class="line">del = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://c2.staticflickr.com/6/5783/21948392158_887cc9754b_z.jpg" alt="在单链表中删除ai节点"></p>
<p>由此可得单链表的删除算法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将链表的第index个元素删除，index从1开始</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">delete</span><span class="params">(Node first, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">	Node del = <span class="keyword">null</span>;</div><div class="line">	Node current = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(index &lt; <span class="number">1</span>) &#123; <span class="comment">// ①删除头结点</span></div><div class="line">		del = first;</div><div class="line">		first = first.next;</div><div class="line">		del = <span class="keyword">null</span>; <span class="comment">// 让GC回收</span></div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		current = first;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; index - <span class="number">1</span>; k++) &#123;</div><div class="line">			<span class="keyword">if</span>(current == <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				current = current.next;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(current == <span class="keyword">null</span> || current.next == <span class="keyword">null</span>) &#123;</div><div class="line">			System.out.println(<span class="string">"无效的删除位置"</span>);</div><div class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// ②删除中间节点或尾部节点</span></div><div class="line">			del = current.next;</div><div class="line">			current.next = del.next;</div><div class="line">			del = <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> first;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>遍历应该是最简单的了，直接看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 遍历链表</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traveling</span><span class="params">(Node first)</span> </span>&#123;</div><div class="line">	Node h = first;   </div><div class="line"></div><div class="line">    <span class="keyword">while</span> (h != <span class="keyword">null</span>) &#123;   </div><div class="line">        System.out.print(h.value + <span class="string">" "</span>);   </div><div class="line">        h = h.next;   </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了链表的相关基础操作：创建、插入、删除、遍历。链表本身很灵活，所以很考察编程功底，所以掌握基础至关重要，接下来还会再写一篇，记录下其他链表的其他进一步的运用。</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="">数据结构(用面向对象方法与C++语言描述) 第二版 殷人昆主编 清华大学出版社</a></li>
<li><a href="http://www.julyedu.com/video/play/?id=31&amp;course=25" target="_blank" rel="external">七月算法：链表面试精讲</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/13/设计模式系列之单例模式-Singleton/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/13/设计模式系列之单例模式-Singleton/" itemprop="url">设计模式系列之单例模式(Singleton)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-13T12:14:39+08:00">
                2015-10-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>学习设计模式的时候，经常会以单例模式作为第一个案例来分析，因为这个模式比较简单，容易理解。但其实一旦牵涉到并发的时候，单例模式也往往很多问题。所以需要系统的梳理一下。</p>
<p>单例模式是一种<code>创建型模式</code>，在Java应用中，单例对象必须保证在一个Java虚拟机中，该对象有且只能有一个实例。这个模式有一下几种应用场景（或者说有这么些优点）：</p>
<blockquote>
<ul>
<li>某些类的实例对象创建，开销比较大，消耗很多的系统资源；</li>
<li>对于某些频繁使用的对象，减少new操作，避免在Java堆中产生过多实例，降低GC压力；</li>
<li>在某些场景中，多个实例对象会导致系统错乱。类似于一个Company有多个CEO，听谁的。</li>
</ul>
</blockquote>
<p>以上这几种情况就非常适合使用单例模式来解决。</p>
<p>单例模式有一下几个特点：</p>
<blockquote>
<ul>
<li>必须保持只有一个实例；</li>
<li>必须自己创建一个自己的实例（因为构造方式是private的）；</li>
<li>必须为其他对象提供唯一的实例（需要提供一个getInstance()方法）；</li>
</ul>
</blockquote>
<p>单例模式主要有以下5种方式，逐一分析下。</p>
<h2 id="饿汉式（线程安全）"><a href="#饿汉式（线程安全）" class="headerlink" title="饿汉式（线程安全）"></a>饿汉式（线程安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="comment">// 类加载的时候就会初始化，这个过程有且仅有一次</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line"></div><div class="line">    <span class="comment">// 私有的构造方法</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 对外提供唯一的Singleton实例</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式非常简单，因为单例的实例被声明为<code>static</code>和<code>final</code>，在JVM第一次加载该单例类到内存中的时候就会初始化【1】，所以创建实例本身是线程安全的。</p>
<p>然而这种方式的缺点也是显而易见的：</p>
<blockquote>
<ul>
<li>这个方式不是<code>懒加载模式</code>（lazy initialization），单例会在第一次加载的时候就被初始化，即使客户端没有调用getInstance()方法。这个时候如果单例类的开销比较大或者时间花费较多，就会降低系统效率。</li>
<li>在一些场景中是无法使用这种方式的：比如Singleton的创建是依赖参数或配置文件的，在getInstance之前必须调用某个方法设置参数给它，那么这种单例就无法使用了。</li>
</ul>
</blockquote>
<h2 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// a</span></div><div class="line">            <span class="comment">// 为了加大出现线程问题的概率，我们在这里休眠1秒</span></div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            instance = <span class="keyword">new</span> Singleton(); <span class="comment">// b</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码简单明了，而且使用了懒加载模式，但是却存在着致命伤。当有多个线程同时运行这段代码的时候，就非常可能创建出多个实例，也就是说这个单例类在并发环境中是无法正确运行的。</p>
<p>我们来分析下出现错误的原因：假设有2个线程同时来到了a处，此时的instance为null。假设线程1先进入if语句块中，但是还没执行b，就交出了CPU使用权。接着线程2获取CPU使用权，进入if语句块，执行了b，生成一个对象，这时候交出了CPU使用权。<strong>这时候，线程1接着执行b，又生成了一个对象</strong>。而在这2个对象的创建期间，其他类可能调用了getInstance()方法，极大可能调用了第1个对象，然后第2个对象创建后，其他类又调用的是第2个对象。这就严重违反了单例模式的核心功能，<strong>所以这种写法是完全不正确的</strong>。</p>
<h2 id="懒汉式（synchronized）"><a href="#懒汉式（synchronized）" class="headerlink" title="懒汉式（synchronized）"></a>懒汉式（synchronized）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// a</span></div><div class="line">            <span class="comment">// 为了出现线程问题，我们在这里休眠1000毫秒。(当然这里并不出现线程安全问题)</span></div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            instance = <span class="keyword">new</span> Singleton(); <span class="comment">// b：这里不会释放掉对象锁，所以其他线程无法进入</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了解决线程安全问题，我们需要使用Java提供的同步机制。为此我们用<code>synchronized</code>关键字来修饰getInstance()方法。</p>
<p>这种方式虽然做到了线程安全，但是却也并不高效。<strong>因为每次只能有一个线程调用getInstance()方法，但是明显同步操作只需要在第一次初始化的时候才被需要</strong>。为此我们引入了双重校验锁。</p>
<h2 id="懒汉式（双重校验锁Double-Checked-Locking）"><a href="#懒汉式（双重校验锁Double-Checked-Locking）" class="headerlink" title="懒汉式（双重校验锁Double Checked Locking）"></a>懒汉式（双重校验锁Double Checked Locking）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;<span class="comment">// private static volatile Singleton instance;</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;<span class="comment">// 第一次校验</span></div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;<span class="comment">// 锁</span></div><div class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;<span class="comment">// 第二次校验</span></div><div class="line">                    Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    instance = <span class="keyword">new</span> Singleton();<span class="comment">// a：可加赋值的内存屏障</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实这种方式本质上就是在同步方式的基础上再加一层校验（也就是if语句判断），只不过把同步的方法换成了同步块。</p>
<p>但是这段代码还是可能出现问题，问题出现在a处<code>instance = new Singleton();</code>这句代码并非是一个原子操作【2】，JVM大概做了3件事：</p>
<ol>
<li>【分配引用内存】给instance分配内存；</li>
<li>【分配实例内存】调用Singleton的构造函数来初始化成员变量；</li>
<li>【引用指向实例地址】将instance引用指向分配的实例内存，这时候instance才不为null；</li>
</ol>
<p>但是JVM可能存在<code>指令重排序</code>，也就是说上面的2、3顺序是不一定的，最终执行顺序可能是1-2-3，也可能是1-3-2，如果是后者，则在执行完3、2未执行的时候，被线程2夺取了CPU，那么这个时候<strong>instance不为null，但是却没有初始化</strong>，所以线程2直接就返回了instance，使用的时候就报错了。</p>
<p>为此我们需要把intance声明为<code>volatile</code>，有部分人认为volatile是保证了可见性，也就是保证线程在本地内存中不会存有instance的副本，每次都是去主内存中获取。但其实是不对的，即使是保证了可见性，也还是会出现上面的问题。使用volatile的主要原因是其另外一个特性：<code>禁止指令重排序</code>。<strong>在volatile变量的赋值操作后，会生成一个内存屏障（在汇编代码上），读操作不会被重排序到内存屏障前</strong>。比如上面的例子，取操作必须在执行完1-2-3或1-3-2后，不存在执行到1-3后读取instance的情况。从“<a href="http://www.luohuida.com/2015/08/28/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/#先行发生原则" target="_blank" rel="external">先行发生原则</a>”的角度来理解的话，就是对于一个volatile变量的写操作是先行发生与后面对这个变量的读操作（这里的后面指的是时间概念）。</p>
<p>但是特别注意的是，在JDK1.5之前，使用volatile的双重校验锁还是有问题的。因为JDK1.5之前的内存模型是存在缺陷的，即使将变量声明为volatile也不能完全避免重排序，主要是volatile变量前后的代码仍然存在重排序问题。在JDK1.5及之后这个问题得到了修复，可以放心使用。</p>
<h2 id="静态内部类方式"><a href="#静态内部类方式" class="headerlink" title="静态内部类方式"></a>静态内部类方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>静态内部类是最被提倡使用的方式，在《effective java》上也是被推荐的。这种写法仍然使用了JVM本身机制保证了线程安全问题。由于SingletonHolder是私有的，除了getInstance()没有其他方法能够访问它，因此它是懒汉式的。同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。这种方式其实是懒汉式和饿汉式的结合。</p>
<p>这种方式使用一个私有静态内部类来维护单例的实现，JVM内部机制保证当一个类被加载时，这个类的加载过程是线程互斥的。这样，当我们第一次调用getInstance()方法的时候，JVM能够帮助我们保证INSTANCE只被创建一次，并且会保证把赋值给INSTANCE的内存初始化完毕，这样我们就不用担心上面的问题了。同时该方法也只会在第一次使用的时候使用互斥机制，这样就解决了低性能的问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，编写单例模式的方法一般有4种，懒汉式线程不安全哪种是不正确的写法，自然也就不算。其实在日常开发中，如果单例对象开销不是很大，直接使用饿汉式也是一种不错的选择。而如果需要懒加载的话，用静态内部类是一种更加优雅的写法。</p>
<hr>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>【1】如果是final的话，应该是静态绑定的，在编译期间就可以确定，参考<a href="http://www.luohuida.com/2015/09/09/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/#被动引用场景-3：使用父类常量不会触发定义常量的类的初始化" target="_blank" rel="external">使用父类常量不会触发定义常量的类的初始化</a>。<br>【2】这与<a href="http://www.luohuida.com/2015/08/28/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" target="_blank" rel="external">Java 内存模型</a>中提到的synchroized保证了原子性有冲突？</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="external">Jark’s Blog: 如何正确地写出单例模式
</a></li>
<li><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" target="_blank" rel="external">CSDN: Java之美[从菜鸟到高手演变]之设计模式</a></li>
<li><a href="http://blog.csdn.net/ljhljh8888/article/details/8017701" target="_blank" rel="external">CSDN: 单例模式有什么好处</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/01/Sublime-Text-3-快捷键以及常用配置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/01/Sublime-Text-3-快捷键以及常用配置/" itemprop="url">Sublime Text 3 快捷键以及常用配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-01T16:15:01+08:00">
                2015-10-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="快捷键（Mac平台）"><a href="#快捷键（Mac平台）" class="headerlink" title="快捷键（Mac平台）"></a>快捷键（Mac平台）</h2><table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">⌘</td>
<td style="text-align:left">command</td>
</tr>
<tr>
<td style="text-align:left">⌃</td>
<td style="text-align:left">control</td>
</tr>
<tr>
<td style="text-align:left">⌥</td>
<td style="text-align:left">option/alt</td>
</tr>
<tr>
<td style="text-align:left">⇧</td>
<td style="text-align:left">shift</td>
</tr>
<tr>
<td style="text-align:left">↩</td>
<td style="text-align:left">enter</td>
</tr>
<tr>
<td style="text-align:left">⌫</td>
<td style="text-align:left">delete</td>
</tr>
</tbody>
</table>
<ul>
<li>打开Console：<code>⌃</code> `</li>
<li>打开命令模式：<code>⌘ ⇧ p</code></li>
<li>根据文件名打开文件：<code>⌘ p</code></li>
<li>定位函数方法：<code>⌘  r</code></li>
<li>多行游标：<code>⌘ d(选中)</code> <code>⌘ k(跳过)</code></li>
<li>快速跳行：<code>⌃ g</code></li>
<li>删除整行：<code>⌃ ⇧ k</code></li>
<li>剪切整行：<code>⌘ x</code></li>
<li>本文件查找：<code>⌘ f</code></li>
<li>全局查找：<code>⌘ ⇧ f</code></li>
<li>替换：<code>⌘ ⌥ f</code></li>
</ul>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="安装Package-Control："><a href="#安装Package-Control：" class="headerlink" title="安装Package Control："></a>安装<strong>Package Control</strong>：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.request,os,hashlib; h = <span class="string">'2915d1851351e5ee549c20394736b442'</span> + <span class="string">'8bc59f460fa1548d1514676163dafc88'</span>; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( <span class="string">'http://packagecontrol.io/'</span> + pf.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)).read(); dh = hashlib.sha256(by).hexdigest(); print(<span class="string">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class="keyword">if</span> dh != h <span class="keyword">else</span> open(os.path.join( ipp, pf), <span class="string">'wb'</span> ).write(by)</div></pre></td></tr></table></figure>
<h3 id="Emmet："><a href="#Emmet：" class="headerlink" title="Emmet："></a><strong>Emmet</strong>：</h3><p>提供了一种非常简练的语法规则，然后立刻生成对应的 HTML 结构或者 CSS 代码，同时还有多种实用的功能帮助进行前端开发。</p>
<ul>
<li>自动生成HTML5初始代码：<code>html:5</code></li>
<li>生成特定id节点：<code>span#idName</code></li>
<li>生成特定class节点：<code>span.className</code></li>
</ul>
<h3 id="AutoFileName"><a href="#AutoFileName" class="headerlink" title="AutoFileName:"></a><strong>AutoFileName</strong>:</h3><p>自动补全文件路径，非常方便。</p>
<h3 id="DocBlockr"><a href="#DocBlockr" class="headerlink" title="DocBlockr:"></a><strong>DocBlockr</strong>:</h3><p>DocBlockr会成为你编写代码文档的有效工具。当输入/**并且按下Tab键的时候，这个插件会自动解析任何一个函数并且为你准备好合适的模板。</p>
<h3 id="Alignment："><a href="#Alignment：" class="headerlink" title="Alignment："></a><strong>Alignment</strong>：</h3><p>代码对齐。</p>
<h3 id="jQuery："><a href="#jQuery：" class="headerlink" title="jQuery："></a><strong>jQuery</strong>：</h3><p>jQuery代码提示。</p>
<h3 id="JsFormat："><a href="#JsFormat：" class="headerlink" title="JsFormat："></a><strong>JsFormat</strong>：</h3><p>JavaScript代码格式化。</p>
<h3 id="Tag："><a href="#Tag：" class="headerlink" title="Tag："></a><strong>Tag</strong>：</h3><p>HTML/XML标签缩进、补全和校验。</p>
<h3 id="HTML-CSS-JS-Prettify："><a href="#HTML-CSS-JS-Prettify：" class="headerlink" title="HTML-CSS-JS Prettify："></a><strong>HTML-CSS-JS Prettify</strong>：</h3><p>代码美化。</p>
<h3 id="ConvertToUTF8："><a href="#ConvertToUTF8：" class="headerlink" title="ConvertToUTF8："></a><strong>ConvertToUTF8</strong>：</h3><p>通过本插件，可以编辑并保存目前编码不被 Sublime Text 支持的文件，特别是中日韩用户使用的 GB2312，GBK，BIG5，EUC-KR，EUC-JP 等。</p>
<h3 id="主题及配色"><a href="#主题及配色" class="headerlink" title="主题及配色"></a>主题及配色</h3><p>Material</p>
<h2 id="个人配置"><a href="#个人配置" class="headerlink" title="个人配置"></a>个人配置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">"auto_complete"</span> : true,</div><div class="line">	<span class="string">"auto_complete_selector"</span>: <span class="string">"source - comment"</span>,</div><div class="line">	<span class="string">"auto_complete_triggers"</span>: </div><div class="line">	[</div><div class="line">		&#123;</div><div class="line">			<span class="string">"characters"</span>: <span class="string">"."</span></div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			<span class="string">"characters"</span>: <span class="string">"&gt;"</span></div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			<span class="string">"characters"</span>: <span class="string">":"</span></div><div class="line">		&#125;</div><div class="line">	],</div><div class="line">	<span class="string">"bold_folder_labels"</span>: true,</div><div class="line">	<span class="string">"color_scheme"</span>: <span class="string">"Packages/Material Theme/schemes/Material-Theme.tmTheme"</span>,</div><div class="line">	<span class="string">"fade_fold_buttons"</span>: false,</div><div class="line">	<span class="string">"font_face"</span>: <span class="string">"Monaco"</span>,</div><div class="line">	<span class="string">"font_size"</span>: <span class="number">13</span>,</div><div class="line">	<span class="string">"highlight_line"</span>: true,</div><div class="line">	<span class="string">"highlight_modified_tabs"</span>: true,</div><div class="line">	<span class="string">"ignored_packages"</span>:</div><div class="line">	[</div><div class="line">		<span class="string">"Vintage"</span></div><div class="line">	],</div><div class="line">	<span class="string">"line_padding_bottom"</span>: <span class="number">1</span>,</div><div class="line">	<span class="string">"line_padding_top"</span>: <span class="number">1</span>,</div><div class="line">	<span class="string">"open_files_in_new_window"</span>: false,</div><div class="line">	<span class="string">"theme"</span>: <span class="string">"Material-Theme.sublime-theme"</span>,</div><div class="line">	<span class="string">"material_theme_accent_purple"</span>: true,</div><div class="line">	<span class="string">"material_theme_small_statusbar"</span>: true,</div><div class="line">	<span class="string">"material_theme_small_tab"</span>: true,</div><div class="line">	<span class="string">"material_theme_tabs_autowidth"</span>: true,</div><div class="line">	<span class="string">"overlay_scroll_bars"</span>: <span class="string">"enabled"</span>,</div><div class="line">	<span class="string">"smart_indent"</span>: true,</div><div class="line">	<span class="string">"word_wrap"</span>: true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="subl命令"><a href="#subl命令" class="headerlink" title="subl命令"></a>subl命令</h2><p>在Bash中执行下面语句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/subl</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://packagecontrol.io/installation" target="_blank" rel="external">Package Control Installation</a></li>
<li><a href="http://www.cnsecer.com/4112.html" target="_blank" rel="external">解决Mac下Sublime Text3因为pyV8无法加载导致Emmet无法使用的问题</a></li>
<li><a href="https://github.com/liveNo/Sublime-Tutorial?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">Sublime Text 插件与快捷键（Mac 版）</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/23/Google-s-Java-Style/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/23/Google-s-Java-Style/" itemprop="url">Google's Java Style</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-23T16:15:09+08:00">
                2015-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为何需要编程规范"><a href="#为何需要编程规范" class="headerlink" title="为何需要编程规范"></a>为何需要编程规范</h2><p>记得以前刚开始写C的时候，能写出来代码就好。后来看了好基友的代码后，感受到了满满的恶意，于是被教育了。后来开始慢慢理解编程规范的作用，以及它的必要性。编程规范多少算是软件工程领域里面的概念，很多程序员认为“编程规范是浪费时间的”、“我有自己的规范”等，其实我大部分是因为他们（她？）没有体会到编程规范所带来的好处。</p>
<p>按我的理解，遵循标准的编程规范有以下几个好处：</p>
<ul>
<li>容易理解代码。Always，如果一份代码遵循一定的规范，每个类、每个方法都声明了它的作用、参数意义等，那么很多时候我们只要看它的文件结构就知道了这些代码要干什么了。</li>
<li>增加代码好感度。面对陌生的东西，我们都会感到害怕。而有统一的规范，你看一眼代码，就会觉得它们很眼熟。那么畏难心理自然消退。</li>
<li>容易维护。</li>
</ul>
<p>目前，自己主要在学习Java方面的技术，而且是个Google粉，所以尝试完全去遵循Google的Java规范。下面是它们的规范文档，中文是由Hawstein大神翻译的。实践篇尤其值得一读。</p>
<h2 id="English"><a href="#English" class="headerlink" title="English"></a>English</h2><p><a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html" target="_blank" rel="external">Google Java Style</a></p>
<h2 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h2><p><a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="external">Hawstein’Blog:Google Java编程风格指南</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/22/什么是事务/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/22/什么是事务/" itemprop="url">什么是事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-22T11:04:30+08:00">
                2015-09-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>事务是DBMS中业务操作的执行单位，事务的ACID性质是数据库一致性的基本保证</strong>。保障并发执行时事务满足ACID的技术就是数据库的并发控制，保障在数据库发生故障时依然满足ACID的技术就是数据库的故障恢复。<strong>并发控制和故障恢复</strong>是数据库系统管理的基本内容，所以事务概念和事务ACID性质也就成为了数据库管理的重要基础。</p>
<h2 id="事务概念与性质"><a href="#事务概念与性质" class="headerlink" title="事务概念与性质"></a>事务概念与性质</h2><p>我们先来看一个例子：由账户A转账金额X到账户B。这是一个非常经典的例子。这个业务可以分解成2个基本的操作：</p>
<ol>
<li>从A中减少金额X；</li>
<li>在B中添加金额X；</li>
</ol>
<p>这2个动作构成了一个不可分割的整体，要么一起执行，要么都不执行。如果只执行前一个动作而忽略了后一个动作，那么将导致数据错乱。这种<strong>“不可分割”的业务单位</strong>对于数据库业务的并发控制和故障恢复非常重要、非常必要，这就是“事务”的基本概念。</p>
<h3 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h3><p>事务（transaction），是DBMS中的基本执行单位。根本特征在于集中了数据库应用方面的若干操作，这些操作构成一个操作序列，要么全做，要么全不做<strong>，整个序列是一个不可分割的“原子化”单位</strong>。</p>
<p>在数据库系统中，一个事务是指：由一系列数据库操作组成的一个完整的逻辑过程。例如银行转帐，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和，构成一个完整的逻辑过程，不可拆分。</p>
<h3 id="事务性质"><a href="#事务性质" class="headerlink" title="事务性质"></a>事务性质</h3><p>在数据库事务处理过程中，事务的正常状态是由“ACID”性质予以保证的。</p>
<ol>
<li><strong>原子性</strong>（<strong>Atomicity</strong>）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li><strong>一致性</strong>（<strong>Consistency</strong>）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
<li><strong>隔离性</strong>（<strong>Isolation</strong>）：多个事务并发执行与这些事务单独执行的结果“等效”。当两个或者多个事务并发访问（此处访问指查询和修改的操作）数据库的同一数据时所表现出的相互关系。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>持久性</strong>（<strong>Durability</strong>）：在事务完成以后，该事务对数据库所作的更改便持久地保存在数据库之中，并且是完全的。</li>
</ol>
<h2 id="事务操作与状态"><a href="#事务操作与状态" class="headerlink" title="事务操作与状态"></a>事务操作与状态</h2><p>在数据库运行过程中，事务可以由下述的4个基本部分组成：</p>
<ol>
<li>开始（begin）：开始执行事务。</li>
<li>执行（read and write）：事务对数据进行读或写操作。</li>
<li>提交（commit）：事务完成所有操作，同时保存结果，标志着事务的成功完成。</li>
<li>回滚（rollback）：事务未完成所有所做，重新返回到事务开始，标志着事务的撤销。</li>
</ol>
<p>根据事务的上述操作，可以得到事务的各种状态：</p>
<ol>
<li>活动状态（active）：事务处于运行当中。</li>
<li>局部提交状态（partial committed）：表明事务的最后语句已经被执行。</li>
<li>提交状态（committed）：事务执行成功，执行结果写入到数据库中。</li>
<li>失败状态（failed）：事务无法正常进行。</li>
<li>终止状态（abort）：回到事务执行前的初始状态。</li>
</ol>
<p>事务操作与状态之间的关系如下图：<br><img src="https://c2.staticflickr.com/6/5672/21623200401_2616631b8d_z.jpg" alt="事务操作与状态之间的关系"></p>
<p>可以得出以下结论：</p>
<ul>
<li>事务一般由“事务开始”启动，到“事务提交”或“事务回滚”结束。</li>
<li>在事务开始后，它不断做READ或WRITE操作，但此时WRITE操作仅将数据写入磁盘缓冲区，并不是真正写入到数据库中。</li>
<li>在事务执行过程中会产生2种情况：一是顺利执行，此时事务继续执行其后的操作；二是产生故障等原因而终止。</li>
</ul>
<h2 id="SQL事务机制"><a href="#SQL事务机制" class="headerlink" title="SQL事务机制"></a>SQL事务机制</h2><h3 id="事务处理语句"><a href="#事务处理语句" class="headerlink" title="事务处理语句"></a>事务处理语句</h3><ol>
<li>事务开始语句：<code>BEGIN TRANSACTION</code>.</li>
<li>事务提交语句：<code>COMMIT TRANSACTION</code>.</li>
<li>事务回滚语句：<code>ROLLBACK TRANSACTION</code>.</li>
<li>事务存储点语句：<code>SAVE TRANSACTION</code>, <code>RELEASE TRANSACTION</code>.</li>
</ol>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="">数据库系统教程 叶小平著 清华大学出版社</a></li>
<li><a href="https://zh.wikipedia.org/wiki/ACID" target="_blank" rel="external">维基百科：ACID</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/21/JVM-如何确定对象已死/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/21/JVM-如何确定对象已死/" itemprop="url">JVM 如何确定对象已死</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-21T11:44:12+08:00">
                2015-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Java堆里面存放着Java世界中几乎所有的对象实例，GC前，第一件事情就是确定这些对象中哪些嗨“存活”着，哪些已经“死去”(即不可能再被使用的对象)。</p>
<h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>一个常用的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它的时候，这个计数器+1；当引用失效的时候，这个计数器-1.当计数器=0的时候，则说明这个对象不可能再被使用。这个叫“引用计数算法”（Reference Counting）。</p>
<p>客观地说，RC算法的实现简单，效率也很高，在大部分情况下它都是一个不错的算法(Objective-C中就使用它来管理内存)。然后JVM中却没有使用它来管理内存，其中最主要的原因就是RC算法<strong>无法处理循环引用</strong>的问题（还有一个问题就是频繁的更新引用计数会降低运行效率）。</p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>在主流的商业程序语言（Java、C#、甚至古老的Lisp）的主流实现中，都是通过可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法的基本思路是：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没用任何引用链相连时（从图论的角度来看，就是GC Roots到这个对象不可达），则说明这个对象是不可用的。如下图所示，，对象object5、object6、objectt7虽然互相关联，但是它们到GC Roots是不可达的，所以它们会被判定是可回收对象。<br><img src="https://c2.staticflickr.com/6/5742/21386142560_90e6e43417.jpg" alt="可达性分析算法判定对象是否可回收"></p>
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li>
<li>本地方法栈中JNI（即一般说的native方法）引用的对象；(ps.栈中数据不受GC影响)</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
</ul>
<h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法来判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK1.2之前，Java中的引用的定义很传统：<strong>如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用</strong>。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用2种状态，对于一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：<strong>当内存空间还足够时，则能够保存在内存中；如果内存空间在进行GC后非常紧张，则可以抛弃这些对象</strong>。很多系统的缓存功能都符合这样的场景。</p>
<p>在JDK1.2后，Java对引用的概念进行了扩充，将引用分为<strong>强引用</strong>（Strong Reference）、<strong>软引用</strong>（Soft Reference）、<strong>弱引用</strong>（Weak Reference）、<strong>虚引用</strong>（Phantom Reference）4种，这4种引用的引用强度逐渐减弱。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>强引用</code></td>
<td style="text-align:left">就是指在代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，GC永远不会回收它们；</td>
</tr>
<tr>
<td style="text-align:left"><code>软引用</code></td>
<td style="text-align:left">用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之内进行二次GC。如果这次GC后还没有足够的内存，才会抛出OOM异常。在JDK1.2后，提供了SoftReference类来实现软引用；</td>
</tr>
<tr>
<td style="text-align:left"><code>弱引用</code></td>
<td style="text-align:left">也是用来描述非必需的对象的，但是它的强度比弱引用更弱一些，被弱引用关联的对象只能生存到下一次GC之前。当GC的时候，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2后，提供了WeakReference类来实现弱引用；</td>
</tr>
<tr>
<td style="text-align:left"><code>虚引用</code></td>
<td style="text-align:left">也称为幽灵或者幻影引用。它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过一个虚引用来取得一个对象实例。为一个对象引入虚引用关联的唯一目的就是能在这个对象被回收器回收之前收到一个系统通知。在JDK1.2后，提供了PhantomReference类实现虚引用。</td>
</tr>
</tbody>
</table>
<h2 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h2><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经过两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被<strong>第一次标记</strong>并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。然后这个对象会放置在一个叫做<code>F-Queue</code>的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的<code>Finalize线程</code>去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不会承诺会等待它运行结束，原因是如果一个对象的finalize()方法执行缓慢，或者发生了死循环，将很可能导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行<strong>第二次小规模的标记</strong>，如果对象在finalize()中成功拯救自己—只要重新与引用链上的任何一个对象建立关联即可，<strong>比如把自己（this关键字）赋值给某个类变量或者对象的成员变量</strong>，那么在第二次标记的时候它将被移除“即将回收”的队列；如果这个对象这个时候还没有逃脱，那基本上它就真的被回收了。来看演示代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.archerda.oom;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 代码演示的目的有2：1</div><div class="line"> *  1.对象可以在GC的时候自救；</div><div class="line"> *  2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统调用一次</div><div class="line"> *</div><div class="line"> * Created by Archerda on 15/9/21.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">        <span class="keyword">super</span>.finalize();</div><div class="line">        System.out.println(<span class="string">"finalize method executed."</span>);</div><div class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>; <span class="comment">// 拯救自己</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</div><div class="line"></div><div class="line">        SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line">        System.gc();</div><div class="line">        Thread.sleep(<span class="number">500</span>); <span class="comment">// 因为finalize线程的优先级很低，所有暂停0.5s来等地它</span></div><div class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"Yes, I'm still alive."</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"No, I'm dead."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">finalize method executed.</div><div class="line">Yes, I<span class="string">'m still alive.</span></div></pre></td></tr></table></figure></p>
<p>从上面的运行结果可以看出，SAVE_HOOK对象的finalize()方法确实被垃圾回收器触发过，并且在回收之前成功逃脱了。</p>
<p>如果我们把<code>FinalizeEscapeGC.SAVE_HOOK = this</code> 注释掉，那么运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">finalize method executed.</div><div class="line">No, I<span class="string">'m dead.</span></div></pre></td></tr></table></figure></p>
<p>这个时候SAVE_HOOK没有重新关联到引用链中，所以没有逃脱GC的回收。</p>
<p>还有个现象，我们把上面代码的main()方法改下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</div><div class="line"></div><div class="line">        SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line">        System.gc();</div><div class="line">        Thread.sleep(<span class="number">500</span>); <span class="comment">// 因为finalize线程的优先级很低，所有暂停0.5s来等地它</span></div><div class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"Yes, I'm still alive."</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"No, I'm dead."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 下面这段代码与上面的完全一样，但是这次自救却失败了</span></div><div class="line">        SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line">        System.gc();</div><div class="line">        Thread.sleep(<span class="number">500</span>); <span class="comment">// 因为finalize线程的优先级很低，所有暂停0.5s来等地它</span></div><div class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"Yes, I'm still alive."</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"No, I'm dead."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">finalize method executed.</div><div class="line">Yes, I'm still alive.</div><div class="line">No, I'm dead.</div></pre></td></tr></table></figure></p>
<p>代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次逃脱失败。这时因为<strong>一个对象的finalize()方法都只会被系统自动调通一次</strong>，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败。也就是说，<strong>对象只能自救一次</strong>。</p>
<p>值得注意的是，建议大家尽量避免使用finalize()方法。因为他不是C/C++中的析构函数，而是Java刚诞生的时候为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂、不确定性大，无法保证各个对象的调用顺序。有些教材中描述它适合做“关闭外部资源”之类的工作，这完全是对这个方法用途的一种安慰，finalize()方法能做的所有工作，使用try-catch或者其他方式都可以做的更好、更及时。所以，忘记这个方法吧！！！</p>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>很多人认为方法区（或者说HotSpot虚拟机中的永久代）是没有垃圾回收的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区中实现垃圾回收，而且在方法区中进行垃圾回收的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾回收一般可以回收70%~95%的空间，而永久代中的垃圾收集效率却远低于此。</p>
<p>永久代中的垃圾回收主要回收两部分内容：<strong>废弃常量和无用的类</strong>。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例：假如一个字符串“abc”已经进入常量池了，当时<strong>当前系统没有任何一个String对象是叫做“abc”，也没有其他地方引用了这个字面量</strong>，如果这时发生了GC，而且必要的话，这个“abc”常量就回被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否“无用”的条件则要苛刻很多。类需要同时满足下面3个条件才能算是“无用的类”：</p>
<ol>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li>
<li>加载该类的ClassLoader已经被回收；</li>
<li>该类队形的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ol>
<p>虚拟机<strong>可以</strong>对满足上述3个条件的无用类进行回收，这里所说的“可以”，而并不是和对象一样，对象的是不使用了就必然会回收。</p>
<p>在大量使用反射、动态代理、CGLib等字节码技术框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备卸载类的功能，以保证虚拟机永久代不会溢出。</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="">深入理解Java虚拟机(第二版) 周志明著</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0" target="_blank" rel="external">维基百科：引用计数</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%AE%9A%E7%BE%A9%E5%8F%AF%E9%81%94%E6%80%A7" target="_blank" rel="external">维基百科：定義可達性</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/20/JVM-内存溢出异常实例/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/20/JVM-内存溢出异常实例/" itemprop="url">JVM 内存溢出异常实例</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-20T22:51:27+08:00">
                2015-09-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在JVM规范的描述中，除了PC外，虚拟机内存的其他几个运行时区域都有发生<code>OutOfMemoryError</code>(OOM)异常的可能性。为了对这些异常进一步理解，我们将通过若干实例来验证异常发生的场景，并且会介绍几个与内存相关的最基本的虚拟机参数。</p>
<p>其实写记录这篇文章的原因有2个：</p>
<blockquote>
<ol>
<li>通过代码验证Java虚拟机规范中描述的各个运行时区域存储的内容；</li>
<li>希望以后在工作中遇到实际的内存溢出异常是，能根据异常的信息快速判断是那个区域的内存溢出，知道什么样的代码可能会导致这些区域内存溢出，以及出现异常后该如何处理。</li>
</ol>
</blockquote>
<p>首先，为了避免每次启动程序都需要手动敲入JVM参数，我们用Intellij IDEA来测试，并且在<code>RUN/DEBUG Configurations---VM options</code>中键入(参数说明请看这里：<a href="http://www.luohuida.com/2015/08/22/JVM-%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E5%8F%8A%E5%88%86%E6%9E%90/" target="_blank" rel="external">JVM-参数分析</a>)</p>
<blockquote>
<p>-verbose:gc -Xms20M -Xmx20M -Xmn10M<br>-XX:+PrintGCDetails -XX:SurvivorRatio=8</p>
</blockquote>
<p>如下图。<br><img src="https://c1.staticflickr.com/1/738/21374151329_35db70e94d_z.jpg" alt="在Intellij IDEA中设置虚拟机参数"></p>
<h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><p>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免GC来清除这些对象，那么在对象数量达到最大堆的容量限制后就回产生内存溢出异常。</p>
<p>在下面的代码中，我们限制饿了Java堆的大小为20M，不可扩展(<strong>将堆的初始值-Xms与最大值-Xmx参数设置为一样即可避免堆自动扩展</strong>)，通过参数<code>-XX:+HeapDumpOnOutOfMemoeyError</code>可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.archerda.oom;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * VM options: -Xms20m -Xmx20m -XX:HeapDumpOnOutOfMemoryError</div><div class="line"> * Created by Archerda on 15/9/20.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            list.add(<span class="keyword">new</span> OOMObject());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">java.lang.OutOfMemoryError: Java heap space</div><div class="line">Dumping heap to java_pid23366.hprof ...</div><div class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</div><div class="line">Heap dump file created [<span class="number">27701731</span> bytes in <span class="number">0.202</span> secs]</div></pre></td></tr></table></figure></p>
<p>Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出异常时，异常堆栈信息<code>java.lang.OutOfMemoryError</code>会跟着进一步提示<code>Java heap space</code>。</p>
<p>要解决这个区域的异常，一般的手段是先通过内存映像分析工具Jstat工具来分析下。首先找到堆转储文件java_pid23366.hprof，默认在工程的根目录下，也可以通过-XX:+HeapDumpOnOutOfMemoeyError=&lt; file-path &gt;来指定。然后运行<code>jstat java_pid23366.hprof</code>，jstat分析完成后会生成html文件并启动服务器，我们访问默认端口localhost:7000打开分析结果页面，默认会显示功能列表，我们主要关注的是有多少个实例存在导致了内存异常，所以我们点击链接<code>Show instance counts for all classes (excluding platform)</code>。如下图。<br><img src="https://c1.staticflickr.com/1/759/21570648651_f2f93da65d_z.jpg" alt=""></p>
<p>然后会调到下面这个页面，从这张图中我们可以很清晰的看见堆中竟然存在810326个OOMObject对象，由此问题的根源就显而易见了。<br><img src="https://c2.staticflickr.com/6/5700/20940716653_d806a7835d_z.jpg" alt=""></p>
<p>除了用jstat这个命令行工具外，我们还可以使用jvisualvm这个可视化工具来分析，只要把.hprof文件导入进去就可以了。如下图。<br><img src="https://c1.staticflickr.com/1/633/21551225682_c26ee32d5b_z.jpg" alt="利用jvisualvm分析堆转储文件"></p>
<p>如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致GC无法自动回收它们的。掌握了泄露对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置。</p>
<p>如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的参数(-Xms与-Xmx)，与物理机内存对比看是否还可以调大，从代码检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行时期的内存消耗。</p>
<h2 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h2><p>由于在HotSpot虚拟机中不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然-Xoss参数(设置本地方法栈大小)存在，但是毫无意义，栈容量只由<strong>-Xss</strong>参数设定。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了2中异常：</p>
<ol>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常；</li>
<li>如果虚拟机在扩展时无法申请到足够的内存空间，将抛出OutOfMemoryError异常；</li>
</ol>
<p>这里把异常分为2中情况，看似更加严谨，但却存在一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上都是对同一件事情的两种描述而已。</p>
<p>在实验中，将范围限制于单线程中的操作，尝试了下面2中方法均无法让虚拟机产生OutOfMemoryError异常，尝试的结果都是获得StackOverflowError异常，测试代码如下：</p>
<ol>
<li>使用<strong>-Xss</strong>参数减少栈内存容量。结果：抛出StackOverflowError异常，异常出现时将输出栈的深度；</li>
<li>定义了大量的本地变量，增大此方法帧中本地变量表的长度，结果：抛出StackOverflowError异常。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.archerda.oom;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Options: -Xss160k</div><div class="line"> * Created by Archerda on 15/9/20.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOF</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</div><div class="line">        stackLength++;</div><div class="line">        stackLeak();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">        JavaVMStackOF oom = <span class="keyword">new</span> JavaVMStackOF();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            oom.stackLeak();</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            System.out.println(<span class="string">"stack length: "</span> + oom.stackLength);</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">stack length: <span class="number">751</span></div><div class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</div><div class="line">	at com.archerda.oom.JavaVMStackOF.stackLeak(JavaVMStackOF.java:<span class="number">11</span>)</div><div class="line">	at com.archerda.oom.JavaVMStackOF.stackLeak(JavaVMStackOF.java:<span class="number">12</span>)</div><div class="line">...后面省略</div></pre></td></tr></table></figure></p>
<p>结果表明：在单个线程的情况下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。</p>
<h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><p>由于运行时常量池是方法区的一部分，因此这2个区域的溢出测试就放在一齐进行。之前说过JDK1.7开始逐步”去永久代”的事情，在此就以测试代码观察一下这件事对程序的实际影响。</p>
<p>String.intern()是一个native方法，它的作用是：如果字符串常量池中已经包含了一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。在JDK1.6及之前的版本中，由于常量池分配在永久代中，我们可以通过<code>-XX:PermSIze</code>和<code>-XX:MaxPernSize</code>限制方法区大小，从而间接限制其中常量池的容量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.archerda.oom;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * JDK 1.6中有效，JDK1.7中无效。</div><div class="line"> * VM Options: -XX:PermSize=10m -XX:MaxPermSize=10m</div><div class="line"> * Created by Archerda on 15/9/20.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 使用List保持常量池的引用，避免FullGC回收常量池行为.</span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            list.add(String.valueOf(i).intern()); <span class="comment">// 10MB的PermSize在integer范围内足够产生OOM了.</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: PermGen space</div><div class="line"> at java.lang.String.intern(Native Method)</div><div class="line"> at com.archerda.oom.RuntimeConstantPoolOOM...</div></pre></td></tr></table></figure></p>
<p>从运行结果中可以看出，运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是”<strong>PermGen space</strong>“，说明运行时常量池属于方法区(HotSpot虚拟机中的永久代)的一部分。</p>
<p>而使用JDK1.7运行这段程序就不会等到相同的结果，while循环将一直循环下去。关于这个字符串常量池的实现问题，还可以引申出一个有意思的影响，看如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.archerda.oom;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by Archerda on 15/9/20.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"软件"</span>).toString();</div><div class="line">        System.out.println(str1.intern() == str1);</div><div class="line"></div><div class="line">        String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</div><div class="line">        System.out.println(str2.intern() == str2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>JDK1.6运行结果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">false</span></div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure></p>
<p>JDK1.7运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure></p>
<p>分析：</p>
<blockquote>
<p>在1.6中，intern()方法会把首次遇到的字符串实例复制到常量池中，返回的也是常量池中的这个字符串实例的引用，而StringBuilder创建的字符串在堆上，所有必然不是同一个引用，所以2个都是false。</p>
<p>而在1.7中，intern()实现<strong>不会再复制</strong>，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串是同一个。对于str2比较返回是false是因为”java”这个字符串在执行StringBuilder.toString()之前已经出现过(？？？哪里出现了卧槽，虚拟机加载的关键字么，可是pack+age还是返回true啊)，字符串常量池已经有它的引用了，不符合“首次出现”的原则，而“计算机软件”这个字符串是首次出现的。</p>
</blockquote>
<p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本的思路是运行时生成大量的类去填满方法区，直到溢出。虽然直接使用Java SE API也可以动态产生类(如反射时的GeneratedConstructorAccessor和动态代理等)，但我们这次使用CGLib直接操作字节码运行时生成大量的动态类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.archerda.oom;</div><div class="line"></div><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</div><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</div><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by Archerda on 15/9/20.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">            enhancer.setSuperclass(OOMObject.class);</div><div class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</div><div class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            enhancer.create();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Caused by: java.lang.OutOfMemoryError: PernGen space</div><div class="line">    at...</div></pre></td></tr></table></figure></p>
<p>值得注意的是，我们在这个例子中的模拟场景并不是一个纯碎的实验，这样的应用经常会出现在实际的应用之中：当前很多主流的框架，如Spring、Hibernate，在对类进行增强的时候，都是使用CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以载入内存。</p>
<p>方法区溢出也是一种常见的内存溢出异常，一个类要被GC回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收情况。这类场景除了CGLib字节码增强之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行需要被编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的类加载器加载会视为不同的类）等。</p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="">深入理解Java虚拟机(第二版) 周志明著</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/16/进程与线程是何关系/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/16/进程与线程是何关系/" itemprop="url">进程与线程是何关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-16T20:08:20+08:00">
                2015-09-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>进程和线程的相关内容，探究起来比较复杂，这里就先了解和记录下一些比较基础的概念和相关知识，等以后学习Linux内核相关的代码时再详细记录吧。</p>
<h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>进程，是可并发执行的程序在一个数据集上的一次执行过程，<strong>它是系统资源分配的基本单位</strong>。从结构上看，进程实体是由 <code>程序段、数据段和进程控制块(PCB)</code>三部分组成，这三部分也被统称为”进程映像”或”进程上下文”。</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>在一个进程的活动期间，它至少具备三种基本状态：<code>就绪状态</code>、<code>执行状态</code>、<code>等待状态</code>。<br><img src="https://farm1.staticflickr.com/617/20837657454_b21147a027_z.jpg" alt=""></p>
<h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p>每一个进程<strong>有且只有一个</strong>进程控制块(Process Control Block, PCB)，进程控制块是操作系统用于记录和描述进程状态及相关信息的数据结构，也是操作系统控制和管理进程的主要依据。PCB是进程存在的唯一标志。操作系统的并发执行也是根据PCB来进行控制和管理的。</p>
<h3 id="进程队列"><a href="#进程队列" class="headerlink" title="进程队列"></a>进程队列</h3><p>通常把处于相同状态的进程链接在一起，称为”进程队列”。比如若干个等待执行的进程(就绪进程)按一定的次序链接起来的队列称为”就绪队列”。把等待资源或等待某些时间的进程也排成队列，称为”等待队列”。</p>
<p>链接方式：单向链接和双向链接，如下图。<br><img src="https://farm6.staticflickr.com/5766/21469446041_74f649e32f_z.jpg" alt=""></p>
<p>索引方式：<br><img src="https://farm6.staticflickr.com/5721/20839790253_dd6d1b3cea_z.jpg" alt=""></p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>在多道程序设计的系统中，往往有多个进程处于就绪状态，它们都要求占用CPU执行。但是，一个处理器每一时刻只能让一个进程占用。所以操作系统设计了一个“进程调度”来解决竞争CPU的问题。</p>
<p>进程调度的主要功能有：</p>
<blockquote>
<ul>
<li>记录系统中所有进程的执行情况；</li>
<li>选择占有CPU的进程；</li>
<li>把CPU分配给进程，并进行进程上下文切换；</li>
<li>收回CPU；</li>
</ul>
</blockquote>
<p>进程调度的时机：</p>
<blockquote>
<ol>
<li>正在执行的进程执行完毕；</li>
<li>执行中的进程被阻塞；</li>
<li>在分时系统中时间片用完；</li>
<li>在执行完系统调用等系统程序返回用户进程时；</li>
<li>执行中的进程被优先级更高的进程剥夺CPU；</li>
</ol>
</blockquote>
<p>进程调度算法：</p>
<blockquote>
<ol>
<li>先来先服务算法(FCFS)</li>
<li>优先数调度算法</li>
<li>时间片轮转调度算法</li>
<li>多级反馈队列调度算法</li>
</ol>
</blockquote>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程(Thread)，是进程中的一个实体，<strong>是CPU调度的基本单位</strong>。一个进程可以有一个或多个线程，它们共享所属进程所拥有的资源。线程具有一下特性：</p>
<blockquote>
<ol>
<li>多个线程可以并发执行；</li>
<li>一个线程可以创建另一个线程；</li>
<li>线程具有动态性。一个线程被创建之后便开始了它的生命周期，期间可能处于不同的状态，直至死亡；</li>
<li>每个线程具有自己的线程控制块(Thread Controlling Block, TCB)，其中记录了该线程的标识符、线程执行时的寄存器和栈等现场状态信息；</li>
<li>在同一个进程内，各线程共享同一地址空间(即所属进程的存储空间)；</li>
<li>一个进程中的线程在另一个进程中是不可见的；</li>
<li>同一个进程内的线程间的通信主要是基于全局变量进行的；</li>
</ol>
</blockquote>
<h2 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h2><p>多线程的实现分为三类：<code>内核级线程</code>(Kernel Level Thread, KLT)、<code>用户级线程</code>(User Level Thread, ULT)、<code>混合式线程</code>，即同时支持ULT和KLT两种线程。</p>
<h2 id="进程与线程结构"><a href="#进程与线程结构" class="headerlink" title="进程与线程结构"></a>进程与线程结构</h2><p>引入线程后，一个进程可包括一个或多个线程。如果一个进程只包括一个线程，则该进程除了有自己的PCB、拥有的存储空间、栈(每个进程会有两个栈，一个用户栈，存在于用户空间，一个内核栈，存在于内核空间。当进程在用户空间运行时，cpu堆栈指针寄存器里面的内容是用户堆栈地址，使用用户栈；当进程在内核空间时，cpu堆栈指针寄存器里面的内容是内核栈空间地址，使用内核栈)以外，还有对应的TCB。如下图所示。<br><img src="https://farm1.staticflickr.com/570/21472631771_031a4eaf5d_z.jpg" alt=""></p>
<p>而如果一个进程包含了多个线程，该进程也包括自己的PCB、存储空间、栈以及各个线程的TCB，但是每个线程将拥有自己的栈，这些栈都数据该进程的栈。如下图。<br><img src="https://farm1.staticflickr.com/582/21472677001_1016e750f8_z.jpg" alt=""></p>
<hr>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="">操作系统教程 谢旭升著 机械工业出版社</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="external">阮一峰的网络日志：进程与线程的一个简单解释</a></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg"
               alt="archerda" />
          <p class="site-author-name" itemprop="name">archerda</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">56</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/archerda" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:luo.archer@gmail.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Email
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">archerda</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
