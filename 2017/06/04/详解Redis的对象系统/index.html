<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Redis," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="前言上篇文章介绍了Redis底层的一些数据结构。但是Redis并没有直接使用这些数据结构来实现键值对数据库，而是在这些数据结构上构建了一个对象系统，这个系统包括字符串对象、列表对象、哈希对象、集合对象和有序集合对象这5种类型的对象，每种对象都至少用到了我们前面所讲的数据结构。">
<meta name="keywords" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="详解Redis的对象系统">
<meta property="og:url" content="http://yoursite.com/2017/06/04/详解Redis的对象系统/index.html">
<meta property="og:site_name" content="Archerda&#39;s Blog">
<meta property="og:description" content="前言上篇文章介绍了Redis底层的一些数据结构。但是Redis并没有直接使用这些数据结构来实现键值对数据库，而是在这些数据结构上构建了一个对象系统，这个系统包括字符串对象、列表对象、哈希对象、集合对象和有序集合对象这5种类型的对象，每种对象都至少用到了我们前面所讲的数据结构。">
<meta property="og:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-06-04-051544.jpg">
<meta property="og:updated_time" content="2017-09-28T11:41:33.343Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="详解Redis的对象系统">
<meta name="twitter:description" content="前言上篇文章介绍了Redis底层的一些数据结构。但是Redis并没有直接使用这些数据结构来实现键值对数据库，而是在这些数据结构上构建了一个对象系统，这个系统包括字符串对象、列表对象、哈希对象、集合对象和有序集合对象这5种类型的对象，每种对象都至少用到了我们前面所讲的数据结构。">
<meta name="twitter:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-06-04-051544.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/06/04/详解Redis的对象系统/"/>





  <title>详解Redis的对象系统 | Archerda's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Archerda's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Programmer. Meditating.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/04/详解Redis的对象系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">详解Redis的对象系统</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-04T21:22:19+08:00">
                2017-06-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇文章介绍了Redis底层的一些数据结构。但是Redis并没有直接使用这些数据结构来实现键值对数据库，而是在这些数据结构上构建了一个对象系统，这个系统包括字符串对象、列表对象、哈希对象、集合对象和有序集合对象这5种类型的对象，每种对象都至少用到了我们前面所讲的数据结构。</p>
<a id="more"></a>
<p>通过这5种对象，有2个明显的好处：</p>
<ol>
<li>Redis可以在执行命令之前，根据对象的类型，来判断命令能否执行；</li>
<li>可以根据不同的场景，来使用不同的底层数据结构，从而优化对象在不同场景下的使用效率；</li>
</ol>
<p>此外，Redis的对象系统还使用了基于引用计数法的内存回收技术，还有通过引用引用计数法实现了对象共享机制。</p>
<p>最后，Redis的对象带有访问时间记录信息，用于计算键的空转时长，若服务器开启了maxmemory功能，空转时间大的键可能会被优先删除。</p>
<h2 id="对象的类型和编码"><a href="#对象的类型和编码" class="headerlink" title="对象的类型和编码"></a>对象的类型和编码</h2><p>Redis的每个对象都是由一个 <strong>redisObject</strong> 结构表示，该结果如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* A redis object, that is a type able to hold a string / list / set */</span></div><div class="line"></div><div class="line"><span class="comment">/* The actual Redis Object */</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Redis 对象</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LRU_BITS 24</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LRU_CLOCK_MAX ((1<span class="meta-string">&lt;&lt;REDIS_LRU_BITS)-1) /* Max value of obj-&gt;lru */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LRU_CLOCK_RESOLUTION 1000 <span class="comment">/* LRU clock resolution in ms */</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 类型</span></div><div class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 编码</span></div><div class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 对象最后一次被访问的时间</span></div><div class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></div><div class="line"></div><div class="line">    <span class="comment">// 引用计数</span></div><div class="line">    <span class="keyword">int</span> refcount;</div><div class="line"></div><div class="line">    <span class="comment">// 指向实际值的指针</span></div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line"></div><div class="line">&#125; robj;</div></pre></td></tr></table></figure></p>
<p>redisObject属性里面，和保存数据相关的3个属性分别是 <code>type</code>, <code>encoding</code>, <code>ptr</code>，</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>redisObject的type属性记录了对象的类型，这个属性可以是下表列出的常量中的其中一个：</p>
<table>
<thead>
<tr>
<th>类型常量</th>
<th>对象名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>字符串对象</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>列表对象</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>哈希对象</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>集合对象</td>
</tr>
<tr>
<td>REIDS_ZSET</td>
<td>有序集合对象</td>
</tr>
</tbody>
</table>
<p>对于Redis数据库 保存的键值来说，键总是一个字符串对象，而值可以是上表5个对象中的一个。我们说是XX键的时候，总是相对于它的值而言的，比如列表键，说的就是键值对的值是一个列表对象。</p>
<p>我们可以用 <code>TYPE</code> 命令来获知一个键值对是什么类型，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">redis&gt; type msg</div><div class="line"><span class="built_in">string</span></div><div class="line">redis&gt; type names</div><div class="line"><span class="built_in">list</span></div></pre></td></tr></table></figure></p>
<p>不同类型值对象的TYPE命令输出如下：</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>type属性的值</th>
<th>TYPE命令的输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串对象</td>
<td>REDIS_STRING</td>
<td>“string”</td>
</tr>
<tr>
<td>列表对象</td>
<td>REDIS_LIST</td>
<td>“list”</td>
</tr>
<tr>
<td>哈希对象</td>
<td>REDIS_HASH</td>
<td>“hash”</td>
</tr>
<tr>
<td>集合对象</td>
<td>REDIS_SET</td>
<td>“set”</td>
</tr>
<tr>
<td>有序集合对象</td>
<td>REIDS_ZSET</td>
<td>“zset”</td>
</tr>
</tbody>
</table>
<h3 id="编码及底层实现"><a href="#编码及底层实现" class="headerlink" title="编码及底层实现"></a>编码及底层实现</h3><p>redisObject的ptr指针指向对象的底层实现数据结构，而这些数据结构的类型由redisObject的encoding属性决定。</p>
<p>encoding属性记录对象所使用的编码，也就是说这对象使用了什么数据结构作为对象的底层实现，这个属性可以是下表中的其中一个：</p>
<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_ENCODING_INT</td>
<td>long类型的整数</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr编码的简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>字典</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳跃表和字典</td>
</tr>
</tbody>
</table>
<p>每种类型的对象都至少使用了2种不同的编码，下表列出了每种对象可以使用的编码：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT</td>
<td>整数值实现的字符串对象</td>
</tr>
<tr>
<td></td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr编码实现的简单动态字符串实现的字符串对象</td>
</tr>
<tr>
<td></td>
<td>REDIS_ENCODING_RAW</td>
<td>简单动态字符串实现的字符串对象</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表实现的列表对象</td>
</tr>
<tr>
<td></td>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双端链表实现的列表对象</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表实现的哈希对象</td>
</tr>
<tr>
<td></td>
<td>REDIS_ENCODING_HT</td>
<td>字典实现的哈希对象</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合实现的集合对象</td>
</tr>
<tr>
<td></td>
<td>REDIS_ENCODING_HT</td>
<td>字典实现的集合对象</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表实现的有序集合对象</td>
</tr>
<tr>
<td></td>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳表实现的有序集合对象</td>
</tr>
</tbody>
</table>
<p>使用 <code>OBJECT ENCODING</code> 命令可以查看一个数据库键的编码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">redis&gt; OBJECT ENCODING msg</div><div class="line"><span class="string">"embstr"</span></div><div class="line">redis&gt; OBJECT ENCODING names</div><div class="line"><span class="string">"ziplist"</span></div></pre></td></tr></table></figure>
<p>下表是不同编码的对象对应的OBJECT ENCODING命令的输出：</p>
<table>
<thead>
<tr>
<th>编码常量</th>
<th>OBJECT ENCODING命令输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_ENCODING_INT</td>
<td>“int”</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>“embstr”</td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>“raw”</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>“hashtable”</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>“linkedlist”</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>“ziplist”</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>“intset”</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>“skiplist”</td>
</tr>
</tbody>
</table>
<p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，可以极大提升Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设定不同的编码，从而优化对象在某个场景的效率。比如，在列表对象包含的元素较少的时候，Redis使用压缩列表作为列表对象的编码：</p>
<ul>
<li>因为压缩列表比双端列表更节约内存，并且在元素较少的时候，在内存中以连续块方式保存的压缩列表比起双端队列可以更快地被载入到缓存中；</li>
<li>随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失，对象就会将编码从压缩列表转换为功能更强、更适合保存大量元素的双端队列；</li>
</ul>
<h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><p>字符串对象的编码可以是int、embstr或者raw。</p>
<ul>
<li><strong>int</strong>：如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整个整数值保存在字符串对象结构的ptr属性里面，并且将字符串对象的编码设置为int；</li>
<li><strong>embstr</strong>：如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值；</li>
<li><strong>raw</strong>：如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将字符串对象的编码设置为raw；</li>
</ul>
<p>embstr编码是专门用来保存短字符串的一种优化编码方式，这种编码和raw编码一样，都使用redisObject结构和sdshdr结构，而embstr编码则通过一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr这2个结构，如下图：<br><img src="http://7xl3pd.com1.z0.glb.clouddn.com/2017-06-04-051544.jpg" alt=""></p>
<p>使用embstr编码的字符串来保存短字符串有以下的好处：</p>
<ul>
<li>embstr编码将创建字符串对象所需的内存分配次数从raw编码的 2 次降低为 1 次；</li>
<li>embstr编码将创建字符串对象只需要 1 次内存释放函数，而raw编码需要调用 2 次；</li>
<li>因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串比起raw编码的字符串更够更好地利用缓存带来的优势；</li>
</ul>
<h3 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h3><p>int和embstr编码的字符串对象在条件满足的时候，会被转换为raw编码的字符串对象。如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; <span class="built_in">set</span> number <span class="number">10086</span></div><div class="line">OK</div><div class="line">redis&gt; object encoding number</div><div class="line"><span class="string">"int"</span></div><div class="line">redis&gt; append number <span class="string">" is a good number."</span></div><div class="line">(integer) <span class="number">23</span></div><div class="line">redis&gt; object encoding number</div><div class="line"><span class="string">"raw"</span></div></pre></td></tr></table></figure></p>
<p>注意，重新set一个字符串对象的话，就不是转换了，redis会重新创建一个字符串对象，并根据值设置相应的编码。如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; <span class="built_in">set</span> number <span class="number">10086</span></div><div class="line">OK</div><div class="line">redis&gt; object encoding number</div><div class="line"><span class="string">"int"</span></div><div class="line">redis&gt; <span class="built_in">set</span> number <span class="string">"10086 is a good number."</span></div><div class="line">OK</div><div class="line">redis&gt; object encoding number</div><div class="line"><span class="string">"embstr"</span></div></pre></td></tr></table></figure></p>
<p>另外，因为redis没有为embstr编码的字符串对象编写任何相应的修改程序（只有int编码和raw编码的字符串对象有这些程序），所以embstr编码的字符串对象实际上是只读的。当我们对embstr编码的字符串对象执行任何修改命令时，embstr编码的字符串在执行修改命令后，总会变为一个raw编码的字符串对象。如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; <span class="built_in">set</span> msg <span class="string">"Hello Redis."</span></div><div class="line">OK</div><div class="line">redis&gt; object encoding msg</div><div class="line"><span class="string">"embstr"</span></div><div class="line">redis&gt; append msg <span class="string">" again!"</span></div><div class="line">(integer) <span class="number">19</span></div><div class="line">redis&gt; object encoding msg</div><div class="line"><span class="string">"raw"</span></div></pre></td></tr></table></figure></p>
<h2 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h2><p>列表对象的编码可以是ziplist或者linkedlist。</p>
<ul>
<li><strong>ziplist</strong>：当列表对象保存的所有字符串元素的长度都小宇64字节，并且保存的元素数量小宇512个时，列表对象采用ziplist编码；</li>
<li><strong>linkedlist</strong>：当列表对象不满足上面ziplist的条件时，就会使用linkedlist编码；</li>
</ul>
<blockquote>
<p>注意！ 使用ziplist编码的 2 个条件是可以修改的，具体查看配置文件中关于 <strong>list-max-ziplist-entries</strong> 和 <strong>list-max-ziplist-value</strong>选项的说明。</p>
</blockquote>
<h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3><p>对于使用ziplist编码的列表对象来说，当使用ziplist编码所需要的 2 个条件的任意一个不被满足时，对象的编码转换工作操作就会被执行，原本保存在ziplist里的所有元素都会被转移到linkedlist里面，对象的编码也会从ziplist变为linkedlist。</p>
<p>下面展示了列表对量因为保存了长度太大的元素而进行编码转换的情况：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; rpush blah <span class="string">"hello"</span> <span class="string">"redis"</span> <span class="string">"again"</span></div><div class="line">(integer) <span class="number">3</span></div><div class="line">redis&gt; object encoding blah</div><div class="line"><span class="string">"ziplist"</span></div><div class="line">redis&gt; rpush blah <span class="string">"I'am archerda!I'am archerda!I'am archerda!I'am archerda!I'am archerda!I'am archerda!I'am archerda!I'am archerda!"</span></div><div class="line">(integer) <span class="number">4</span></div><div class="line">redis&gt; object encoding blah</div><div class="line"><span class="string">"linkedlist"</span></div></pre></td></tr></table></figure></p>
<h2 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h2><p>哈希对象的编码可以是ziplist或者hashtable。</p>
<ul>
<li><strong>ziplist</strong>：哈希对象保存的所有键值对的键和值的字符串长度都小于64字节，并且键值对的数量小于512个；</li>
<li><strong>hashtable</strong>：不满足ziplist条件时，哈希对象使用hashtable编码；</li>
</ul>
<blockquote>
<p>注意！使用ziplist编码的 2 个条件是可以修改的，具体查看配置文件中关于 <strong>hash-max-ziplist-entries</strong> 和 <strong>hash-max-ziplist-value</strong>选项的说明。</p>
</blockquote>
<p>ziplist编码的哈希对象，每当有新的键值对加入到哈希对象的时候，程序会先将保存了键的ziplist节点push到ziplist的表尾，然后再将保存了值的ziplist节点push到ziplist表尾，因此：</p>
<ul>
<li>保存了同一个键值对的 2 个节点总是紧挨在一起，保存了键的节点在前，保存了值的节点在后；</li>
<li>先添加到哈希对象中的键值对会被放在ziplist的表头方向，而后来添加到哈希对象中的键值对会被放到ziplist的表尾方向；</li>
</ul>
<p>另一方面，hashtable编码的哈希对象使用字典作为底层实现，哈希对象的每个键值对都使用一个字典键值对来保存；</p>
<h3 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h3><p>对于使用ziplist编码的哈希对象来说，当使用ziplist编码所需的 2 个条件的任意一个不能被满足时，对象的编码转换就会被执行，原本保存在ziplist里面的所有键值对都会被转移并保存到字典里面，对象的编码也会从ziplist变为hashtable。</p>
<p>下面展示了哈希对象因为键值对的键长度太大而引起编码转换的情况：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; hset book name <span class="string">"Redis in Action."</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line">redis&gt; object encoding book</div><div class="line"><span class="string">"ziplist"</span></div><div class="line">redis&gt; hset book desc <span class="string">"I'am archerda!I'am archerda!I'am archerda!I'am archerda!I'am archerda!I'am archerda!I'am archerda!I'am archerda!"</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line">redis&gt; object encoding book</div><div class="line"><span class="string">"hashtable"</span></div></pre></td></tr></table></figure></p>
<p>除了值的长度太长会引起编码转换外，键的长度太大也同样会引起编码转换。</p>
<h2 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h2><p>集合对象的编码可以是intset或者hashtable。</p>
<ul>
<li><strong>intset</strong>：当集合对象保存的所有元素都是整数值，并且元素的数量不超过512个时，集合对象使用intset编码；</li>
<li><strong>hashtable</strong>：当不满足intset的 2 个条件时，集合对象使用hashtable编码；</li>
</ul>
<blockquote>
<p>注意！使用intset编码的条件是可以修改的，具体查看配置文件中关于 <strong>set-max-intset-entries</strong> 选项的说明。</p>
</blockquote>
<p>intset编码的集合对象使用intset作为底层实现，集合对象包含的所有元素都被保存在intset里面。另一方面，hashtable编码的集合对象使用字典作为底层实现，<strong>字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL</strong>。</p>
<h2 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h2><p>有序集合的编码可以是ziplist或者skiplist。</p>
<ul>
<li><strong>ziplist</strong>：当有序集合对象保存的元素小于128个，并且保存的所有元素成员的长度都小于64字节的时候，有序集合将使用ziplist作为底层编码；</li>
<li><strong>skiplist</strong>：当不满足上面 2 个条件的任意一个时，有序集合将使用skiplist作为底层编码。</li>
</ul>
<blockquote>
<p>注意！使用ziplist编码的 2 个条件是可以修改的，具体查看配置文件中关于 <strong>zset-max-ziplist-entries</strong> 和 <strong>zset-max-ziplist-value</strong>选项的说明。</p>
</blockquote>
<p>ziplist编码的有序集合对象使用ziplist作为底层实现，每个集合元素使用 2 个紧挨在一起的ziplist节点来保存，第一个节点保存元素的成员（member），第二个元素则保存元素的分值（score）。</p>
<p>ziplist的集合元素按照分值从小到大排序，分值较小的元素被放置在靠近表头的位置，分值较大的元素则被放置靠近表尾的位置。</p>
<p>skiplist编码的有序集合使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 有序集合</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 字典，键为成员，值为分值</span></div><div class="line">    <span class="comment">// 用于支持 O(1) 复杂度的按成员取分值操作</span></div><div class="line">    dict *dict;</div><div class="line"></div><div class="line">    <span class="comment">// 跳跃表，按分值排序成员</span></div><div class="line">    <span class="comment">// 用于支持平均复杂度为 O(log N) 的按分值定位成员操作</span></div><div class="line">    <span class="comment">// 以及范围操作</span></div><div class="line">    zskiplist *zsl;</div><div class="line"></div><div class="line">&#125; zset;</div></pre></td></tr></table></figure></p>
<p>zset结构中的 zsl 跳跃表按分值从小到大保存了所有集合元素，每个跳跃表都保存了一个集合元素：跳跃表节点的objcet属性保存了属性的成员，而跳跃表节点的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围操作，比如zrank、zrange等命令就是基于跳跃表API来实现的。</p>
<p>此外，zset结构的dict字典为有序集合创建了一个从成员到分值的映射，字典中每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值则保存了元素的分值。通过这个字典，程序可以用 O(1) 复杂度查找给定成员的分值，zscore命令就是根据这个特性实现的，而很多其他有序集合命令都在实现的内部用到了这个特性。</p>
<p>有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。值得一提的是，虽然zset结构同时使用skiplist和dict来保存有序集合的元素，但这 2 种数据结构都会通过指针来共享相同元素的成员和分值，所以不会产生任何重复的成员或者分值，也不会因此浪费额外的内存。</p>
<p>为什么有序集合需要同时使用跳跃表和字典来实现？</p>
<blockquote>
<p>理论上，有序集合可以单独使用字典或者跳跃表的其中一个数据结构来实现，但是无论单独使用字典还是跳跃表，在性能上对比起同时使用都会有降低。比如说，如果我们只使用字典来实现有序集合，那么虽然可以以 O(1) 复杂度查找成员的分值，但是因为字典以无序的方式来保存集合元素，所以每次在执行范围操作的时候，程序都需要对字典保存的所有元素进行排序，完成这种排序至少需要 O(NlogN)的时间复杂度，以及额外的 O(N)的内存空间（因为要创建一个数组来保存排序后的元素）。</p>
<p>另一方面，如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点会被保留，但是因为没有了字典，所以根据成员查找分值这个操作的复杂度将从 O(1)升至 O(logN)。</p>
<p>综上，为了让有序集合的查找和范围型操作都尽可能快地执行，Redis选择了同时使用字典和跳跃表这 2 中数据结构来实现有序集合。</p>
</blockquote>
<h2 id="内存回收技术"><a href="#内存回收技术" class="headerlink" title="内存回收技术"></a>内存回收技术</h2><p>因为C语言不具有自动内存回收的功能，所以Redis在自己的对象系统中构建了一个引用计数技术实现的内存回收技术，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p>
<p>每个对象的引用计数信息由redisObject的refcount属性记录：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 引用计数</span></div><div class="line">    <span class="keyword">int</span> refcount;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125; robj;</div></pre></td></tr></table></figure></p>
<p>队形的引用计数信息会随着对象的使用状态而不断变化：</p>
<ul>
<li>在创建一个新对象时，refcount会被初始化为1；</li>
<li>当对象被一个新程序使用时，它的refcount会被+1；</li>
<li>当对象不再被一个程序使用时，它的refcount会被-1；</li>
<li>当对象的refcount变为0的时候，对象所占用的内存会被释放。</li>
</ul>
<h2 id="对象共享技术"><a href="#对象共享技术" class="headerlink" title="对象共享技术"></a>对象共享技术</h2><p>除了用于实现引用计数内存回收机制之外，对象的refcount属性还带有对象共享的作用。</p>
<p>比如，键A创建了一个包含整数值100的字符串对象作为值对象，此时键B也要创建一个同样保存了整数值100到的字符串对象作为值对象，那么Redis会让键A和键B同时共享包含整数值100的那个字符串对象，并让其refcount的值+1。</p>
<p>共享对象机制对于节约内存非常有帮助，数据库中保存的相同值越多，对象共享机制就越能节约内存。</p>
<p>目前，Redis会在初始化服务器的时候，创建10000个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到从0到9999的字符串对象时，服务器就会使用这些共享对象，而不是创建新对象。</p>
<blockquote>
<p>注意！创建共享字符串对象的数量可以通过修改redis.h/REDIS_SHARED_INTEGERS 常量来修改。</p>
</blockquote>
<p>下面是一个例子，可以看出A和B共享了对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">redis&gt; set A 100</div><div class="line">OK</div><div class="line">redis&gt; object refcount A</div><div class="line">(integer) 2</div><div class="line">redis&gt; set B 100</div><div class="line">OK</div><div class="line">redis&gt; object refcount A</div><div class="line">(integer) 3</div><div class="line">redis&gt; object refcount B</div><div class="line">(integer) 3</div></pre></td></tr></table></figure>
<p>为什么Redis不共享包含字符串的对象，而只共享包含整数值的对象？</p>
<blockquote>
<p>当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同，只有在共享兑现个目标对象完全相同的情况下，程序才会将共享对象用作值的对象，而一个共享对象保存的越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的CPU时间也会越多：</p>
<ul>
<li>如果共享对象是保存整数值的字符串对象，那么验证操作的复杂度为 O(1)；</li>
<li>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)；</li>
<li>如果共享对象是包含多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证的复杂度将会是 O(N^2)。</li>
</ul>
<p>因此，尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享。</p>
</blockquote>
<h2 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h2><p>redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一个被程序访问的时间：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 对象最后一次被访问的时间</span></div><div class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>; <span class="comment">/* lru time (relative to server.lruclock) */</span></div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">&#125; robj;</div></pre></td></tr></table></figure></p>
<p><code>OBJECT IDLETIME</code>命令可以打印给定键的空转市场，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">redis&gt; set msg hello</div><div class="line">OK</div><div class="line">redis&gt; object idletime msg</div><div class="line">(integer) 8</div><div class="line">redis&gt; object idletime msg</div><div class="line">(integer) 13</div><div class="line">redis&gt; get msg</div><div class="line">"hello"</div><div class="line">redis&gt; object idletime msg</div><div class="line">(integer) 1</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意！OBJECT IDLETIME命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的lru属性。</p>
</blockquote>
<p>此外，lru时间还有另外一项作用：如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存超过了maxmemory选项设置的上限值的时候，空转时间较长的那部分键会优先被服务器释放，从而回收内存。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="">Redis设计与实现（第二版）</a></li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/05/15/详解Redis底层的数据结构/" rel="next" title="详解Redis底层的数据结构">
                <i class="fa fa-chevron-left"></i> 详解Redis底层的数据结构
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/05/Redis-VS-Memcached/" rel="prev" title="Redis VS. Memcached">
                Redis VS. Memcached <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png"
               alt="archerda" />
          <p class="site-author-name" itemprop="name">archerda</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">71</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">37</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/archerda" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:luo.archer@gmail.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Email
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的类型和编码"><span class="nav-number">2.</span> <span class="nav-text">对象的类型和编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型"><span class="nav-number">2.1.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编码及底层实现"><span class="nav-number">2.2.</span> <span class="nav-text">编码及底层实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串对象"><span class="nav-number">3.</span> <span class="nav-text">字符串对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编码的转换"><span class="nav-number">3.1.</span> <span class="nav-text">编码的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表对象"><span class="nav-number">4.</span> <span class="nav-text">列表对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编码转换"><span class="nav-number">4.1.</span> <span class="nav-text">编码转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希对象"><span class="nav-number">5.</span> <span class="nav-text">哈希对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编码转换-1"><span class="nav-number">5.1.</span> <span class="nav-text">编码转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合对象"><span class="nav-number">6.</span> <span class="nav-text">集合对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有序集合对象"><span class="nav-number">7.</span> <span class="nav-text">有序集合对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存回收技术"><span class="nav-number">8.</span> <span class="nav-text">内存回收技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象共享技术"><span class="nav-number">9.</span> <span class="nav-text">对象共享技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的空转时长"><span class="nav-number">10.</span> <span class="nav-text">对象的空转时长</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文档"><span class="nav-number">11.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">archerda</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
