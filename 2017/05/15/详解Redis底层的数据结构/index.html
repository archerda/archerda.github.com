<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Redis," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="前言工作中的业务系统大面积应用了Redis，一个NoSQL内存数据库。Redis的高性能、易用性，让它成为目前互联网公司中一个必不可少的工具。这也引起了我的兴趣更进一步去了解它，但由于自己不是专业的DBA，所有很少去接触Redis的复制、Sentinel、Cluster等高级特性的实战，所以接下来的文章中，将更多地去介绍Redis的数据结构和一些原理，为以后Redis的进一步理解打下基础。">
<meta name="keywords" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="详解Redis底层的数据结构">
<meta property="og:url" content="http://yoursite.com/2017/05/15/详解Redis底层的数据结构/index.html">
<meta property="og:site_name" content="Archerda&#39;s Blog">
<meta property="og:description" content="前言工作中的业务系统大面积应用了Redis，一个NoSQL内存数据库。Redis的高性能、易用性，让它成为目前互联网公司中一个必不可少的工具。这也引起了我的兴趣更进一步去了解它，但由于自己不是专业的DBA，所有很少去接触Redis的复制、Sentinel、Cluster等高级特性的实战，所以接下来的文章中，将更多地去介绍Redis的数据结构和一些原理，为以后Redis的进一步理解打下基础。">
<meta property="og:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-03-Redis-SDS-Sample01.png">
<meta property="og:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-16-150458.jpg">
<meta property="og:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-17-165118.jpg">
<meta property="og:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-17-170309.jpg">
<meta property="og:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-17-172344.jpg">
<meta property="og:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-22-153705.jpg">
<meta property="og:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-22-155448.jpg">
<meta property="og:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-23-153942.jpg">
<meta property="og:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-23-154057.jpg">
<meta property="og:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-23-154329.jpg">
<meta property="og:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-23-155103.jpg">
<meta property="og:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-23-155717.jpg">
<meta property="og:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-23-155958.jpg">
<meta property="og:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-26-141618.jpg">
<meta property="og:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-26-143409.jpg">
<meta property="og:updated_time" content="2017-09-28T06:53:20.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="详解Redis底层的数据结构">
<meta name="twitter:description" content="前言工作中的业务系统大面积应用了Redis，一个NoSQL内存数据库。Redis的高性能、易用性，让它成为目前互联网公司中一个必不可少的工具。这也引起了我的兴趣更进一步去了解它，但由于自己不是专业的DBA，所有很少去接触Redis的复制、Sentinel、Cluster等高级特性的实战，所以接下来的文章中，将更多地去介绍Redis的数据结构和一些原理，为以后Redis的进一步理解打下基础。">
<meta name="twitter:image" content="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-03-Redis-SDS-Sample01.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/05/15/详解Redis底层的数据结构/"/>





  <title>详解Redis底层的数据结构 | Archerda's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Archerda's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Programmer. Meditating.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/15/详解Redis底层的数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">详解Redis底层的数据结构</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-15T23:29:53+08:00">
                2017-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作中的业务系统大面积应用了Redis，一个NoSQL内存数据库。Redis的高性能、易用性，让它成为目前互联网公司中一个必不可少的工具。这也引起了我的兴趣更进一步去了解它，但由于自己不是专业的DBA，所有很少去接触Redis的复制、Sentinel、Cluster等高级特性的实战，所以接下来的文章中，将更多地去介绍Redis的数据结构和一些原理，为以后Redis的进一步理解打下基础。</p>
<a id="more"></a>
<p>本文主要介绍Redis底层的6种数据结构，分别是：</p>
<ul>
<li>简单动态字符串；</li>
<li>链表；</li>
<li>字典；</li>
<li>跳跃表；</li>
<li>整数集合；</li>
<li>压缩列表；</li>
</ul>
<h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>简单动态字符串(simple dynamic string)，下称SDS。SDS是Redis最常用的数据结构，没有之一。当Redis需要的是一个可能被修改的字符串时，它就会使用SDS来表示，比如在Redis的数据库中，包含字符串值的键值对在底层都是由SDS实现的。看下面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET msg <span class="string">"Hello Redis."</span></div><div class="line">OK</div></pre></td></tr></table></figure></p>
<ul>
<li>键值对的键是一个字符串对象，对象的底层实现是一个保存着“msg”的SDS；</li>
<li>键值对的值也是一个字符串对象，对象的底层是一个保存着“Hello Redis.”的SDS；</li>
</ul>
<p>又比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis&gt; RPUSH name <span class="string">"Robert"</span> <span class="string">"Archerda"</span></div><div class="line">(integer) <span class="number">2</span></div></pre></td></tr></table></figure></p>
<ul>
<li>键值对的键是一个字符串对象，底层实现是一个保存着“name”的SDS；</li>
<li>键值对的值是一个列表对象，列表对象包含了2个字符串对象，这2个字符串对象的底层分别是2个SDS，保存着“Robert”，“Archerda”；</li>
</ul>
<p>除了用来保存字符串值外，SDS有以下用处：</p>
<ul>
<li>用作缓冲区（buffer）<ul>
<li>AOF模块中的AOF缓冲区；</li>
<li>客户端状态的输入缓冲区；</li>
</ul>
</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在sds.h中，对SDS的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 保存字符串对象的结构</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></div><div class="line">    <span class="comment">// buf 中已占用空间的长度</span></div><div class="line">    <span class="keyword">int</span> len;</div><div class="line"></div><div class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></div><div class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 数据空间</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>请看下面的实例解析：<br><img src="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-03-Redis-SDS-Sample01.png" alt="2017-05-03-Redis-SDS-Sample01"></p>
<p>上图展示了一个SDS实例：</p>
<ul>
<li>len属性的值为5，说明这个SDS保存了一个5个字节长的字符串；</li>
<li>free属性的值为0，说明这个SDS没有分配未使用的空间；</li>
<li>buff是一个char型的数组，数组的前5个字节分别保存了’R’,’e’,’d’,’i’,’s’这5个字符，而最后一个字节则保存着’\0’字符；</li>
</ul>
<p>注意，SDS遵循C字符串以空字符结尾的规范，这样可以使得SDS直接使用C函数库里面的一些方法，比如<code>printf(&quot;%s&quot;, sds-&gt;buf);</code>。但是保存空字符的这个字节不计算在len属性里面。而且，为空字符额外分配1字节的操作和把空字符添加到末尾都是SDS函数自动完成的，对SDS的使用者完全透明。</p>
<p>我们可以使用<code>DEBUG OBJECT &lt;key-name&gt;</code>来查看某个key占用了多少空间。比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">redis&gt; get msg</div><div class="line"><span class="string">"Redis"</span></div><div class="line">redis&gt; DEBUG OBJECT msg</div><div class="line">Value at:<span class="number">0x7ff7e45050d0</span> refcount:<span class="number">1</span> encoding:embstr serializedlength:<span class="number">6</span> lru:<span class="number">636632</span> lru_seconds_idle:<span class="number">25</span></div></pre></td></tr></table></figure></p>
<p>这里，我们只关注 <strong>serializedlength : 6</strong>，说明msg这个键对应的值占用了6个字节，注意这里是包括了最后一个空字符的长度。</p>
<h3 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h3><p>SDS与C字符串都是以空字符’\0’结尾，但是C字符串不满足Redis对于安全性、效率以及功能方面的要求。</p>
<ul>
<li>常数复杂度获取字符串长度<ul>
<li>SDS获取字符串长度，只需要读取len属性的值就可以了，复杂度为O(1);</li>
<li>C字符串获取字符串长度，需要遍历整个字符串来计算长度，复杂度为O(n);</li>
</ul>
</li>
<li>杜绝缓冲区溢出<ul>
<li>当SDS的API需要修改SDS时，API会先检查SDS的空间是否满足修改的要求，如果不满足，API会自动扩展SDS的空间，然后再进行操作；所以SDS不需要手动去修改SDS的空间大小，也不存在类似C函数strcat所存在的缓冲区溢出的问题；</li>
</ul>
</li>
<li>减少修改字符串所带来的内存重分配次数<ul>
<li>C字符串底层总是用N+1长度的字符数组来保存一个长度为N的字符串，每当需要修改这个字符串的时候，比如trim或者append，程序需要先通过内存重分配操作来扩展或释放内存空间，否则会出现缓冲区溢出或内存泄露；</li>
<li><strong>内存重分配</strong> 涉及复杂的算法，可能会需要执行系统调用，所以这是一个比较耗时的操作；</li>
<li>Redis作为内存数据库，经常被用于对速度要求苛刻、数据被频繁修改的场景，如果每次修改字符串都需要内存重分配，那么很大可能对性能造成影响；所以SDS用free属性来解除了字符串长度和底层数组长度之间的关联；</li>
</ul>
</li>
<li>二进制安全<ul>
<li>C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则会被认为是字符串结尾，使得它只能保存文本数据，而不能保存图片、音频等二进制数据。而SDS的API会以处理二进制的方式来处理SDS存放在buf数组里面的数据，程序不会对其中的数组做任何限制、过滤。通过二进制安全的SDS，使得Redis不仅能够保存文本数据，还可以保存任意格式的二进制数据。</li>
</ul>
</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>链表提供了高效地节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。链表在Redis中的应用也非常广泛，比如Redis中的列表键的底层实现之一就是链表。举个例子，下面的integers列表键包含了1024个整数。integers列表键的底层实现就是一个链表，链表中的每个节点保存了一个整数值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">redis&gt; <span class="function">LLEN <span class="title">integers</span></span></div><div class="line"><span class="params">(integer)</span> 1024</div><div class="line">redis&gt; LRANGE integers 0 10</div><div class="line"> 1) "12"</div><div class="line"> 2) "11"</div><div class="line"> 3) "10"</div><div class="line"> 4) "9"</div><div class="line"> 5) "8"</div><div class="line"> 6) "7"</div><div class="line"> 7) "6"</div><div class="line"> 8) "5"</div><div class="line"> 9) "4"</div><div class="line">10) "3"</div><div class="line">11) "2"</div></pre></td></tr></table></figure></p>
<p>除了链表键以外，Redis以下的功能也使用了链表：</p>
<ul>
<li>发布与订阅；</li>
<li>慢查询；</li>
<li>监视器；</li>
<li>保存多个客户端的状态信息；</li>
<li>构建客户端的输出缓冲区（output buffer）；</li>
</ul>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>每个链表节点使用一个adList.h/listNode结构来表示；如下，多个listNode通过prev指针和next指针来组成一个双端队列。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 双端链表节点</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 前置节点</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></div><div class="line"></div><div class="line">    <span class="comment">// 后置节点</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></div><div class="line"></div><div class="line">    <span class="comment">// 节点的值</span></div><div class="line">    <span class="keyword">void</span> *value;</div><div class="line"></div><div class="line">&#125; listNode;</div></pre></td></tr></table></figure></p>
<p>虽然使用多个listNode结构就可以组成链表，但是Redis使用adList.h/list结构来持有列表，操作起来更方便。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 双端链表结构</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 表头节点</span></div><div class="line">    listNode *head;</div><div class="line"></div><div class="line">    <span class="comment">// 表尾节点</span></div><div class="line">    listNode *tail;</div><div class="line"></div><div class="line">    <span class="comment">// 节点值复制函数</span></div><div class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</div><div class="line"></div><div class="line">    <span class="comment">// 节点值释放函数</span></div><div class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</div><div class="line"></div><div class="line">    <span class="comment">// 节点值对比函数</span></div><div class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</div><div class="line"></div><div class="line">    <span class="comment">// 链表所包含的节点数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</div><div class="line"></div><div class="line">&#125; <span class="built_in">list</span>;</div></pre></td></tr></table></figure></p>
<p>list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match函数则是用于实现多态链表所需的类型特定函数：</p>
<ul>
<li>dup函数用于复制链表节点所保存的值；</li>
<li>free函数用于释放链表节点所保存的值；</li>
<li>match函数用于对比链表节点所保存的值和另一个输入值是否相等；</li>
</ul>
<p>下图是1个list结构和3个listNode结构组成的链表。<br><img src="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-16-150458.jpg" alt=""></p>
<p>Redis的链表实现的特性总结如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">双端</td>
<td style="text-align:left">链表的节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)</td>
</tr>
<tr>
<td style="text-align:left">无环</td>
<td style="text-align:left">表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点</td>
</tr>
<tr>
<td style="text-align:left">带链表长度计数器</td>
<td style="text-align:left">程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度是O(1)</td>
</tr>
<tr>
<td style="text-align:left">多态</td>
<td style="text-align:left">链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match这3个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值</td>
</tr>
</tbody>
</table>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>字典，是一种用于保存键值对（key-value pair）的抽象数据结构。字典中的每个键都是独一无二的，程序可以在字典中根据键查找到与之关联的值，或者通过键来更新值，又或者根据键来删除整个键值对等。</p>
<p>字典在Redis中的应用非常广泛，比如Redis的数据库就是使用字典作为底层来实现的，对数据库的增删查改操作也是在对字典的操作之上的。比如，当我们执行命令：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis&gt; set msg <span class="string">"hello redis."</span></div><div class="line">OK</div></pre></td></tr></table></figure></p>
<p>这个时候，Redis在数据库中创建了一个键为”msg”，值为”hello redis.”的键值对时，这个键值对就保存在数据库的字典里面。</p>
<p>除了用来表示数据库之外，字典还是哈希键的底层实现之一。举个例子，website是一个包含10086个键值对的哈希键，这个哈希键的键都是一些数据库的名字，而键的值就是数据库的主页网址：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; <span class="function">HLEN <span class="title">website</span></span></div><div class="line"><span class="params">(integer)</span> 10086</div><div class="line">redis&gt; HGETALL website</div><div class="line">1) "Redis"</div><div class="line">2) "redis.io"</div><div class="line">3) "MongoDB"</div><div class="line">4）"mongodb.org"</div><div class="line"># ...</div></pre></td></tr></table></figure></p>
<p>website键的底层实现就是一个字典，字典中包含了10086个键值对，例如：</p>
<ul>
<li>键值对的键为”Redis”，值为”redis.io”;</li>
<li>键值对的键为”MongoDB”，值为”mongodb.org”；</li>
</ul>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以用多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对，下面分别介绍Redis的哈希表、哈希表节点以及字典的实现。</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>Redis字典所使用的哈希表由dict.h/dictht结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 哈希表</div><div class="line"> *</div><div class="line"> * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 哈希表数组</span></div><div class="line">    dictEntry **table;</div><div class="line"></div><div class="line">    <span class="comment">// 哈希表大小</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</div><div class="line"></div><div class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></div><div class="line">    <span class="comment">// 总是等于 size - 1</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</div><div class="line"></div><div class="line">    <span class="comment">// 该哈希表已有节点的数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</div><div class="line"></div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure></p>
<p>table属性是一个数组，数组中的每一个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对。size属性记录了哈希表的大小，也就是table数组的大小，而used属性则记录了哈希表目前已有节点的数量（也就是键值对的数量）。sizemark属性的值总是等于size - 1，这个属性和哈希值一起决定了一个键应该被放到table数组的哪个索引上。</p>
<p>下图展示了一个大小为4的空哈希表（没有任何键值对）。<br><img src="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-17-165118.jpg" alt=""></p>
<h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对。dictEntry的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 哈希表节点</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 键</span></div><div class="line">    <span class="keyword">void</span> *key;</div><div class="line"></div><div class="line">    <span class="comment">// 值</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span> *val;</div><div class="line">        <span class="keyword">uint64_t</span> u64;</div><div class="line">        <span class="keyword">int64_t</span> s64;</div><div class="line">    &#125; v;</div><div class="line"></div><div class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></div><div class="line"></div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure></p>
<p>key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。</p>
<p>next属性是执行另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，以此来解决键冲突（collision）的问题（这个解决方式和JDK中HashMap解决hash冲突的方式是类似的）。</p>
<p>下图展示了如何通过next指针，将两个索引值相同的键k0和k1连接在一起：<br><img src="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-17-170309.jpg" alt=""></p>
<h4 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h4><p>Redis中的字典是由dict.h/dict结构来表示的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 字典</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 类型特定函数</span></div><div class="line">    dictType *type;</div><div class="line"></div><div class="line">    <span class="comment">// 私有数据</span></div><div class="line">    <span class="keyword">void</span> *privdata;</div><div class="line"></div><div class="line">    <span class="comment">// 哈希表</span></div><div class="line">    dictht ht[<span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="comment">// rehash 索引</span></div><div class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></div><div class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></div><div class="line"></div><div class="line">    <span class="comment">// 目前正在运行的安全迭代器的数量</span></div><div class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></div><div class="line"></div><div class="line">&#125; dict;</div></pre></td></tr></table></figure></p>
<p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：</p>
<ul>
<li><p>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定键值对的函数，Redis会为不用用途的字典设置不同的类型特定函数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 字典类型特定函数</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 计算哈希值的函数</span></div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 复制键的函数</span></div><div class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</div><div class="line"></div><div class="line">    <span class="comment">// 复制值的函数</span></div><div class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</div><div class="line"></div><div class="line">    <span class="comment">// 对比键的函数</span></div><div class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</div><div class="line"></div><div class="line">    <span class="comment">// 销毁键的函数</span></div><div class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</div><div class="line"></div><div class="line">    <span class="comment">// 销毁值的函数</span></div><div class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</div><div class="line"></div><div class="line">&#125; dictType;</div></pre></td></tr></table></figure>
</li>
<li><p>privdata属性则保存了需要传给那些特定函数的可选参数；</p>
</li>
</ul>
<p>ht属性是一个包含两个项的数组，数组的每个项都是一个dictht哈希表。一般情况，字典只使用ht[0]哈希表，ht[1]只会在ht[0]进行rehash的时候使用。</p>
<p>除了ht[1]外，另一个和rehash相关的属性就是rehashidx了，它记录了目前rehash的进度，如果目前没有rehash，那么它的值为-1.</p>
<p>下图展示了一个普通状态下（没有进行rehash）的字典：<br><img src="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-17-172344.jpg" alt=""></p>
<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持平均<code>O(logN)</code>、最坏<code>O(N)</code>复杂度的节点查找，还可以通过顺序性来批量处理节点。在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且实现比平衡树简单，所以有不少程序都使用跳跃表来代替平衡树。</p>
<p>跳跃表是Redis有序集合键的底层实现之一。举个例子，fruit-price是一个有序集合，这个有序集合以水果名作为成员，水果价作为分值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANCE fruit-price <span class="number">0</span> <span class="number">2</span> WITHSCORES</div><div class="line"><span class="number">1</span>) <span class="string">"banana"</span></div><div class="line"><span class="number">2</span>) <span class="string">"5"</span></div><div class="line"><span class="number">3</span>) <span class="string">"cherry"</span></div><div class="line"><span class="number">4</span>) <span class="string">"6.5"</span></div><div class="line"><span class="number">5</span>) <span class="string">"apple"</span></div><div class="line"><span class="number">6</span>) <span class="string">"8"</span></div><div class="line"></div><div class="line">redis&gt; ZCARD fruit-price</div><div class="line">(integer) <span class="number">130</span></div></pre></td></tr></table></figure></p>
<p>fruit-price有序集合的所有数据都被保存在一个跳跃表里面，其中每个跳跃表节点都保存了一种水果的价格，所有水果按照价格从低到高在跳跃表里排序：</p>
<ul>
<li>跳跃表的第一个元素的成员为”banana”，它的分值是5；</li>
<li>跳跃表的第二个元素的成员为”cherry”，它的分值是6.5；</li>
<li>跳跃表的第三个元素的成员为”apple”，它的分值是8；</li>
</ul>
<p>和链表、字典等数据结构被广泛应用在Redis内部不同，<strong>Redis只在2个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部结构</strong>，除此之外，跳跃表在Redis内部没有其他用途。</p>
<h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>我们先看下面一个跳跃表：<br><img src="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-22-153705.jpg" alt=""></p>
<h4 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h4><p>跳跃表节点的实现由redis.h/zskiplistNode结构定义，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 跳跃表节点</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 成员对象</span></div><div class="line">    robj *obj;</div><div class="line"></div><div class="line">    <span class="comment">// 分值</span></div><div class="line">    <span class="keyword">double</span> score;</div><div class="line"></div><div class="line">    <span class="comment">// 后退指针</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></div><div class="line"></div><div class="line">    <span class="comment">// 层</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></div><div class="line"></div><div class="line">        <span class="comment">// 前进指针</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></div><div class="line"></div><div class="line">        <span class="comment">// 跨度</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</div><div class="line"></div><div class="line">    &#125; level[];</div><div class="line"></div><div class="line">&#125; zskiplistNode;</div></pre></td></tr></table></figure></p>
<ul>
<li>层<br>跳跃表节点的level数组可以包含多个元素，每个元素都包含了一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快；<br>每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law，越大的数出现的概率越低）<strong>随机生成一个介于1~32之间的值作为level数组的大小，这个大小就是层的”高度”</strong>。<br>下图分别展示了2个高度为1层和3层的节点。<br><img src="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-22-155448.jpg" alt=""></li>
<li>前进指针<br>每个层都有一个指向表尾方向的前进指针（level[i].forward属性），用于表头向表尾方向访问节点。</li>
<li>跨度<br>层的跨度（level[i].span属性）用于记录两个节点之间的距离；<br>1.两个节点之间的跨度越大，他们相距得就越远；<br>2.指向NULL的所有前进指针的跨度都为0，因为他们没有连向任何节点。<br>看上去，很容易以为跨度和遍历操作有关，但实际上并不是遍历操作只使用前进指针就可以完成，跨度其实是用来计算排位（rank）的：<strong>在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位</strong>。</li>
<li>后退指针<br>节点的后退指针（backward属性）用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点都只有一个后退指针，所以每次只能后退到前一个节点。</li>
<li>分值和成员<br>节点的分值（score属性）是一个double类型的浮点数，跳跃表的所有节点都按照分值从小到大排序。<br>节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象里面存着一个SDS值。<br>在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点的分值却是可以相同的：分值相同的节点将按照对象在字典序中的大小来排序。</li>
</ul>
<h4 id="跳跃表-1"><a href="#跳跃表-1" class="headerlink" title="跳跃表"></a>跳跃表</h4><p>跳跃表由redis.h/zskiplist结构定义，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">*</div><div class="line"> * 跳跃表</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 表头节点和表尾节点</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></div><div class="line"></div><div class="line">    <span class="comment">// 表中节点的数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</div><div class="line"></div><div class="line">    <span class="comment">// 表中层数最大的节点的层数</span></div><div class="line">    <span class="keyword">int</span> level;</div><div class="line"></div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure>
<ul>
<li>header<br>指向跳跃表的表头节点。</li>
<li>tail<br>指向跳跃表的表尾节点。</li>
<li>level<br>记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不算在内）。</li>
<li>lenght<br>记录跳跃表的长度，也就是，跳跃表目前包含的节点的数量（表头节点的层数不算在内）。</li>
</ul>
<p>通过使用lenght属相来记录节点的数量，程序可以在O(1)复杂度内返回跳跃表的长度。注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性不会被用到，所以图中略去了，只显示了表头节点的各个层。</p>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><p>整数集合（intset）是集合键的底层实现之一。举个例子，当我们创建了一个只包含5个元素的集合键时，并且集合中的所有元素都是整数值，那么这个集合键的底层实现就会是整数集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">redis&gt; SADD numbers <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span></div><div class="line">(integer) <span class="number">5</span></div><div class="line">redis&gt; OBJECT ENCODING numbers</div><div class="line"><span class="string">"intset"</span></div></pre></td></tr></table></figure></p>
<h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>整数集合（intset）是Redis用来保存整数值的集合抽象数据结构，它可以保存int16_t、int32_t、int64_t的整数值，并且保证集合中不会出现重复值。</p>
<p>每个整数集合用intset.h/intset结构来表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 编码方式</span></div><div class="line">    <span class="keyword">uint32_t</span> encoding;</div><div class="line"></div><div class="line">    <span class="comment">// 集合包含的元素数量</span></div><div class="line">    <span class="keyword">uint32_t</span> length;</div><div class="line"></div><div class="line">    <span class="comment">// 保存元素的数组</span></div><div class="line">    <span class="keyword">int8_t</span> contents[];</div><div class="line"></div><div class="line">&#125; intset;</div></pre></td></tr></table></figure></p>
<p>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个项，各个项在数组中按值的大小有序地排列，并且数组中不包含重复项。<br>length属性记录了整数集合包含的元素数量，也即是contents数组的长度。</p>
<p>虽然intset将contents数组声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，contents属性的真正类型取决于encoding属性的值：</p>
<ul>
<li>如果encoding属性的值为INTSET_ENC_INT16,那么contents就是一个int16_t类型的数组，数组里面每个项都是一个int16_t类型的整数值（-32768 &lt;= int16_t &lt;= 32767）;</li>
<li>如果encoding属性的值为INTSET_ENC_INT32,那么contents就是一个int32_t类型的数组，数组里面每个项都是一个int32_t类型的整数值（-2147483648 &lt;= int32_t &lt;= 2147483647）;</li>
<li>如果encoding属性的值为INTSET_ENC_INT64,那么contents就是一个int64_t类型的数组，数组里面每个项都是一个int64_t类型的整数值（-9223372036854775808 &lt;= int64_t &lt;= 9223372036854775807）;</li>
</ul>
<p>下图展示了一个整数集合：<br><img src="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-23-153942.jpg" alt=""></p>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>每当我们要将一个新元素加到intset里面的时候，并且新元素的类型比intset现有所有元素的类型都要长，那么intset需要先进行升级（upgrade），然后才能将新元素加到intset里面。</p>
<p>升级intset需要3步：</p>
<ol>
<li>根据新元素的类型，扩展intset底层contents数组的空间大小，并为新元素分配空间；</li>
<li>将contents数组现有的所有元素都转换成与新元素相同的类型，并将转换后的元素放置到正确的位置，而且在放置元素的过程中，需要继续维持contents数组的有序性质不变；</li>
<li>将新元素添加到contents数组里面。</li>
</ol>
<p>举个例子，假设现有一个intset，如下图：<br><img src="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-23-154057.jpg" alt=""><br>因为每个元素都占用16位的空间，所以intset的contents数组的大小为 16 * 3 = 48位，下图展示了intset的3个元素在这48位的位置：<br><img src="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-23-154329.jpg" alt=""><br>现在，我们要把类型为int32_t的整数值65535添加到intset中。因为65535的类型int32_t比intset里面当前所有元素的类型都要长，所以在添加65535到intset之前，需要对intset进行升级。</p>
<p>升级首先要做的是，根据新类型的长度，以及intset元素的数量（包括要添加的新元素），对contents数组进行空间再分配。intset目前有3个元素，加上新元素65535，一共需要4个元素的空间，所以占用的空间大小是32 * 4 = 128位。如下图所示。虽然程序对contents数组进行了空间再分配，但是数组里面原有的3个元素1、2、3仍然是int64_t类型，这些元素还被保存在前48位上。<br><img src="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-23-155103.jpg" alt=""></p>
<p>所以程序接下来要将这3个元素转换为int32_t类型，并将转换的元素放置到正确的位上，而且在放置元素的过程中，需要维持contents数组的有序性质不变。首先，因为元素3在1、2、3、65535这4个元素中排名第三，所以它将被移动到contents数组的索引2位置上，也就是数组64~95位上，如下图所示：<br><img src="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-23-155717.jpg" alt=""></p>
<p>依次移动元素2、元素1、元素65535，最后排列如下图所示：<br><img src="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-23-155958.jpg" alt=""></p>
<p>最后，程序将intset的encoding属性从 INTSET_ENC_INT16 改为 INTSET_ENC_INT32，并将length从3改为4。</p>
<p>因为每次添加新元素都有可能会引起升级，而每次升级都需要对底层数组中已有的所有元素进行转换，所以向intset添加新元素的复杂度为 O(N)。</p>
<p>升级的好处：</p>
<ol>
<li>提升intset的灵活性：因为C语言是静态类型，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据类型里面。但是因为intset可以通过自动升级来适应新元素，所以我们可以随意地将int16_t、int32_t、int64_t类型的整数放到集合中，而不必担心类型错误，这种做法非常灵活；</li>
<li>节约内存：想要一个数据同时保存int16_t、int32_t、int64_t这3种类型，最简单的方法就是用int64_t来保存，但是用int64_t来保存int16_t、int32_t，会出现浪费内存的情况。</li>
</ol>
<p>此外，intset支持升级，但是不支持降级。</p>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><h3 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h3><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含几个项，并且每个项要么是小整数值，要么是比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。比如，下面将会创建一个ziplist实现的列表键：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; RPUSH lst <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="string">"hello"</span> <span class="string">"redis"</span></div><div class="line">(integer) <span class="number">5</span></div><div class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; OBJECT ENCODING lst</div><div class="line"><span class="string">"ziplist"</span></div></pre></td></tr></table></figure></p>
<p>再比如，下面将会创建一个ziplist实现的哈希键：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; HMSET profiles <span class="string">"name"</span> <span class="string">"archerda"</span> <span class="string">"age"</span> <span class="number">23</span></div><div class="line">OK</div><div class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; OBJECT ENCODING profiles</div><div class="line"><span class="string">"ziplist"</span></div></pre></td></tr></table></figure></p>
<h3 id="ziplist构成"><a href="#ziplist构成" class="headerlink" title="ziplist构成"></a>ziplist构成</h3><p>ziplist是Redis为了节省内存而设计开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）的数据结构。一个ziplist可以包含多个节点（entry），每个entry可以保存一个字节数组或者一个整数值。</p>
<p>下图展示了ziplist的各个组成部分，表格则描述了各个组成部分的类型、长度以及用途。<br><img src="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-26-141618.jpg" alt=""></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>长度</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>4字节</td>
<td>记录整个ziplist占用的内存字节数：在堆ziplist进行内存重分配或者计算zlend的位置时使用</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>4字节</td>
<td>记录ziplist表尾节点距离ziplist的起始地址有多少字节：通过这个偏移量，程序无需遍历就可以确定表尾节点的地址</td>
</tr>
<tr>
<td>zllen</td>
<td>unint16_t</td>
<td>2字节</td>
<td>记录ziplist包含的节点数量：当这个属性的值小于UINT16_MAX(65535)时，这个属性的值就是ziplist包含的节点的数量；当这个值等于UINT16_MAX的时候，节点的真实数量需要遍历整个ziplist才能够计算出来</td>
</tr>
<tr>
<td>entryX</td>
<td>列表节点</td>
<td>不定</td>
<td>ziplist包含的各个节点，节点的长度由节点保存的内容决定</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td>1字节</td>
<td>特殊值0xFF（十进制255），用于标记ziplist的末端</td>
</tr>
</tbody>
</table>
<p>下图展示了一个压缩列表sample：</p>
<ul>
<li>zlbytes=0x50（十进制80），表示ziplist的总长为80字节；</li>
<li>zltail=0x3c（十进制60），表示如果我们有一个指向ziplist起始地址的指针p，那么只要用指针p加上偏移量60，就可以计算出entry3的地址；</li>
<li>zllen=0x3（十进制3），表示ziplist有3个entry节点；<br><img src="http://7xl3pd.com1.z0.glb.clouddn.com/2017-05-26-143409.jpg" alt=""></li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>到这里，Redis底层的7种数据结构就介绍完了，接下来开始介绍基于这7种数据结构而创建的5种对象。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="">Redis设计与实现（第二版）</a></li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/10/Shell脚本语法/" rel="next" title="Shell脚本常用语法">
                <i class="fa fa-chevron-left"></i> Shell脚本常用语法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/04/详解Redis的对象系统/" rel="prev" title="详解Redis的对象系统">
                详解Redis的对象系统 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xl3pd.com1.z0.glb.clouddn.com/archerda2.png"
               alt="archerda" />
          <p class="site-author-name" itemprop="name">archerda</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">71</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">37</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/archerda" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:luo.archer@gmail.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Email
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单动态字符串"><span class="nav-number">2.</span> <span class="nav-text">简单动态字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用"><span class="nav-number">2.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">2.2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDS与C字符串的区别"><span class="nav-number">2.3.</span> <span class="nav-text">SDS与C字符串的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表"><span class="nav-number">3.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用-1"><span class="nav-number">3.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-1"><span class="nav-number">3.2.</span> <span class="nav-text">定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字典"><span class="nav-number">4.</span> <span class="nav-text">字典</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用-2"><span class="nav-number">4.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-2"><span class="nav-number">4.2.</span> <span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#哈希表"><span class="nav-number">4.2.1.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哈希表节点"><span class="nav-number">4.2.2.</span> <span class="nav-text">哈希表节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字典-1"><span class="nav-number">4.2.3.</span> <span class="nav-text">字典</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跳跃表"><span class="nav-number">5.</span> <span class="nav-text">跳跃表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用-3"><span class="nav-number">5.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-3"><span class="nav-number">5.2.</span> <span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#跳跃表节点"><span class="nav-number">5.2.1.</span> <span class="nav-text">跳跃表节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跳跃表-1"><span class="nav-number">5.2.2.</span> <span class="nav-text">跳跃表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#整数集合"><span class="nav-number">6.</span> <span class="nav-text">整数集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用-4"><span class="nav-number">6.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-4"><span class="nav-number">6.2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#升级"><span class="nav-number">6.3.</span> <span class="nav-text">升级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#压缩列表"><span class="nav-number">7.</span> <span class="nav-text">压缩列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用-5"><span class="nav-number">7.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ziplist构成"><span class="nav-number">7.2.</span> <span class="nav-text">ziplist构成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最后"><span class="nav-number">8.</span> <span class="nav-text">最后</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文档"><span class="nav-number">9.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">archerda</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
