<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JVM," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="概述虚拟机是如何加载Class文件的？Class文件加载到虚拟机后会发生什么变化？这些问题都牵涉到虚拟机的类加载机制。虚拟机把描述类的数据从Class文件中加载到内存中，并对数据进行校验（为什么要校验？）、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型（怎么样的才能直接使用呢？），这就是虚拟机的类加载机制。 与那些在编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载、连">
<meta name="keywords" content="JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM 类加载机制">
<meta property="og:url" content="http://yoursite.com/2015/09/09/JVM-类加载机制/index.html">
<meta property="og:site_name" content="Archerda&#39;s Blog">
<meta property="og:description" content="概述虚拟机是如何加载Class文件的？Class文件加载到虚拟机后会发生什么变化？这些问题都牵涉到虚拟机的类加载机制。虚拟机把描述类的数据从Class文件中加载到内存中，并对数据进行校验（为什么要校验？）、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型（怎么样的才能直接使用呢？），这就是虚拟机的类加载机制。 与那些在编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载、连">
<meta property="og:image" content="https://farm6.staticflickr.com/5794/21033863319_d6946a3dc9_b.jpg">
<meta property="og:image" content="https://farm6.staticflickr.com/5708/21034022708_e7d1c442fb_o.png">
<meta property="og:image" content="https://farm1.staticflickr.com/690/21034481358_a1788f6c88_o.png">
<meta property="og:image" content="https://farm6.staticflickr.com/5696/20600709404_7c953b20ab_b.jpg">
<meta property="og:image" content="https://farm6.staticflickr.com/5793/21250745705_5cf57d4632.jpg">
<meta property="og:updated_time" content="2017-05-19T09:01:55.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM 类加载机制">
<meta name="twitter:description" content="概述虚拟机是如何加载Class文件的？Class文件加载到虚拟机后会发生什么变化？这些问题都牵涉到虚拟机的类加载机制。虚拟机把描述类的数据从Class文件中加载到内存中，并对数据进行校验（为什么要校验？）、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型（怎么样的才能直接使用呢？），这就是虚拟机的类加载机制。 与那些在编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载、连">
<meta name="twitter:image" content="https://farm6.staticflickr.com/5794/21033863319_d6946a3dc9_b.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2015/09/09/JVM-类加载机制/"/>





  <title>JVM 类加载机制 | Archerda's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Archerda's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Programmer. Meditating.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/09/JVM-类加载机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="archerda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Archerda's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JVM 类加载机制</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-09T02:39:13+08:00">
                2015-09-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>虚拟机是如何加载Class文件的？Class文件加载到虚拟机后会发生什么变化？这些问题都牵涉到虚拟机的类加载机制。虚拟机把描述类的数据从Class文件中加载到内存中，并对数据进行校验（为什么要校验？）、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型（怎么样的才能直接使用呢？），这就是虚拟机的类加载机制。</p>
<p>与那些在编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的。这种策略虽然会令类加载时稍微增加一些性能开销（这里指定是时间上的开销吧？），但是会为Java程序提供高度的灵活性，<strong>Java天生可以动态扩展（怎么算动态扩展？）的语言特性就是依赖运行期间动态加载和动态连接这个特点实现的</strong>。</p>
<hr>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a><strong>类加载的时机</strong></h2><p>类从被加载到虚拟机内存中开始使用，到卸载出内存位置，它的整个生命周期如下图。<br><img src="https://farm6.staticflickr.com/5794/21033863319_d6946a3dc9_b.jpg" alt="类的生命周期"></p>
<p>上图中，加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始。<strong>但是解析阶段却不一定，它在某些情况下可以在初始化阶段之后再开始</strong>，这是为了支持Java语言的运行时绑定（这是什么鬼？？？）。</p>
<p>什么时候需要开始类加载过程的第一个阶段：加载。Java虚拟机规范中并没有进行强制约束，这点可以由虚拟机自由把握。但是<strong>对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行”初始化”</strong>（而加载、验证、准备自然需要在此之前开始）。</p>
<ol>
<li>遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类没有进行过类的初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候、调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包的方法堆类进行反射调用的时候，如果类没有进行初始化过，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动的时候，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个类。</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法的句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。（这里只能呵呵了，句柄是什么鬼？？？）</li>
</ol>
<p>对于这5种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定词：”有且只有”，<strong>这5种场景中的行为成为对一个类进行主动引用</strong>。除此之外，所有引用类的方法都不会触发初始化，成为被动引用。</p>
<h3 id="被动引用场景-1：通过子类引用父类的静态字段，不会导致子类初始化。"><a href="#被动引用场景-1：通过子类引用父类的静态字段，不会导致子类初始化。" class="headerlink" title="被动引用场景-1：通过子类引用父类的静态字段，不会导致子类初始化。"></a>被动引用场景-1：<strong>通过子类引用父类的静态字段，不会导致子类初始化</strong>。</h3><p><img src="https://farm6.staticflickr.com/5708/21034022708_e7d1c442fb_o.png" alt=""></p>
<p>输出结果：</p>
<blockquote>
<p>SuperClass init.<br>123</p>
</blockquote>
<p>类加载列表：</p>
<blockquote>
<p>[Loaded test1 from file:]<br>[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]<br>[Loaded SuperClass from file:]<br>[Loaded SubClass from file:]<br>SuperClass init.<br>123<br>[Loaded java.lang.Shutdown from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]<br>[Loaded java.lang.Shutdown$Lock from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]</p>
</blockquote>
<p>分析：</p>
<blockquote>
<p>上面的代码之所以没有输出“SubClass init.”，是因为对于静态字段，只有直接定义了这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否要触发子类的加载和验证，在虚拟机规范中并未规定。对于HotSpot虚拟机来说，可通过-XX:+TraceClassLoading参数来观察此操作会导致子类的加载。</p>
</blockquote>
<h3 id="被动引用场景-2：通过数组定义来引用类，不会触发此类的初始化。"><a href="#被动引用场景-2：通过数组定义来引用类，不会触发此类的初始化。" class="headerlink" title="被动引用场景-2：通过数组定义来引用类，不会触发此类的初始化。"></a>被动引用场景-2：<strong>通过数组定义来引用类，不会触发此类的初始化</strong>。</h3><p><img src="https://farm1.staticflickr.com/690/21034481358_a1788f6c88_o.png" alt=""></p>
<p>输出结果：（无）</p>
<p>类加载列表：</p>
<blockquote>
<p>[Loaded test2 from file:]<br>[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]<br>[Loaded SuperClass from file:]<br>[Loaded java.lang.Shutdown from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]<br>[Loaded java.lang.Shutdown$Lock from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]</p>
</blockquote>
<p>分析：</p>
<blockquote>
<p>运行之后发现没有输出“SuperClass init.”，说明没有触发类SuperClass的初始化阶段。但是这段代码里面触发了另一个名为”[LSuperClass”的类的初始化阶段，对于用户来说，这并不是一个合法的累名称，它是一个又虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令anewarray触发。这个类代表了一个元素类型为SuperClass的一维数组，数组中应有的属性和方法（用户可直接只用的只有被修饰未public的length属性和clone方法）都实现在这个类里面。Java语言中对数组的访问比C/C++相对安全是因为这个类封装了数组元素的访问方法（准确地说，越界检查不是封装在数组元素访问的类中，而是封装在数组访问的xaload、xastore字节码指令中），而C/C++直接翻译为对数组指针的移动。在java语言中，当检查发生数组越界时会抛出java.lang.ArrayIndexOutOfBoundsException异常。</p>
</blockquote>
<h3 id="被动引用场景-3：使用父类常量不会触发定义常量的类的初始化"><a href="#被动引用场景-3：使用父类常量不会触发定义常量的类的初始化" class="headerlink" title="被动引用场景-3：使用父类常量不会触发定义常量的类的初始化"></a>被动引用场景-3：<strong>使用父类常量不会触发定义常量的类的初始化</strong></h3><p><img src="https://farm6.staticflickr.com/5696/20600709404_7c953b20ab_b.jpg" alt=""></p>
<p>输出结果：</p>
<blockquote>
<p>Hello World.</p>
</blockquote>
<p>类加载列表：</p>
<blockquote>
<p>[Loaded test from file:]<br>[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]<br>Hello World.<br>[Loaded java.lang.Shutdown from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]<br>[Loaded java.lang.Shutdown$Lock from /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar]</p>
</blockquote>
<p>分析：</p>
<blockquote>
<p>上述代码运行之后，也没有输出“ConstClass init.”，这是因为虽然在Java源码中引用了ConstClass类中的常量HW，但其实在编译阶段通过<strong>常量传播优化</strong>，已经将此常量的值“Hello World.”存储到<strong>test类的常量池</strong>中，以后test对常量ConstClass.HW的引用实际都被转化为test类对自身常量池（每个类都有自己的常量池？？）的引用了。也就是说，实际上test的Class文件中没有ConstClass类的<strong>符号引用入口</strong>，这两个类在翻译成Class之后就不存在任何联系了。</p>
</blockquote>
<p><strong>PS</strong>：接口的加载过程与类加载稍有一些不同，针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的，上面的代码块都是用<code>static {}</code>来输出初始化信息的，而接口中不能使用，但是编译器仍然会为接口生成 <code>&lt;clinit&gt;()</code>类构造器（方法构造器是<code>&lt;init&gt;()</code>），用于初始化接口中所定义的成员变量。<br><strong>PSS</strong>：接口与类真正有所区别的是前面讲述的5种“有且仅有”需要开始初始化的第3种：当一个类在初始化，要求其父类全部都已经初始化过了。但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（比如引用接口中定义的常量）才会初始化。</p>
<hr>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a><strong>类加载过程</strong></h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a><strong>加载</strong></h3><p>“加载”是“类加载”（Class Loading）过程的一个阶段。在加载阶段，虚拟机需要完成3件事：</p>
<ol>
<li>通过一个<strong>类的全限定名</strong>（java.lang.Object的全限定名为java/lang/Object）来获取定义此类的二进制字节流；</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；</li>
</ol>
<p>虚拟机规范的这3点要求其实不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的。例如“通过类的全限定名来获取此类的二进制字节流”这条，它没有指明二进制字节流要从一个Class文件获取，准确地说根本没有指明要从哪里获取、怎样获取。虚拟机设计团队在加载阶段搭建了一个相当开放的、广阔的“舞台”，许多举足轻重的Java技术都建立在这基础上，例如：</p>
<ul>
<li>从ZIP包中获取，这很常见，最终成为JAR、EAR、WAR格式的基础。</li>
<li>从WEB中获取，这种场景最典型的应用就是Applet了。</li>
<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerateProxyClass来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景就是JSP应用，即由JSP文件生成对应的Class类。</li>
<li>从数据库中读取，这种场景相对少见，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成代码在集群间的分发。</li>
<li>….<br>说这么多，其实就是要说明二进制字节流来源多。。。</li>
</ul>
<p>相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发者可以通过自定义的类加载器去控制字节流的获取方式（也就是重写一个类加载器的loadClass()方法）。</p>
<p>对于数组类而言，情况就有所不同，<strong>数组类本身不通过类加载器创建</strong>，它是由Java虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，一个数组类（下面简称C）创建过程遵循以下规则：</p>
<ul>
<li>如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类型，那就递归采用上面定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识（！important，一个类必须与类加载器一起唯一确定性）。</li>
<li>如果数组的组件不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与引导类加载器关联。</li>
<li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将被默认为public。</li>
</ul>
<p>关于类加载器，可以查看后续段落。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象（<strong>并没有规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面</strong>），这个对象作为程序访问方法区中的这些类型数据的外部接口。</p>
<p>加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这2个阶段的开始时间仍然保持这固定的先后顺序。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h3><p>验证的目的是为了确保Class文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>Java语言本身是相对安全的语言，使用纯碎的Java代码无法做到诸如访问数组边界外的数据、将一个对象转换未它并未实现的类型、跳转到不存在的代码行之类的事情。如果做了，编译器将拒绝编译。但前面说过，Class文件并不一定要求用Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写产生Class文件。在字节码语言层面，上述Java代码无法做到的事情都是可以实现的，至少语义上是可以表达出来的。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机堆自身安全的一项重要工作。</p>
<p>验证阶段是非常重要的，这个阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代码的攻击，从执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载子系统又占了相当大的一部分。《Java虚拟机规范（第二版）》对这个阶段的限制、指导还是比较笼统的，规范中列举了一些Class文件格式中的静态和结构化约束，如果验证到输入的字节流不符合Class文件格式的约束，虚拟机就应该抛出一个java.lang.VerifyError异常或者其子类异常，但具体应当检查哪些方面、如何检查、何时检查，都没有足够具体的要求和明确的说明。直到2011年发布的《Java虚拟机规范（Java SE 7版）》大幅增加了描述验证过程的篇幅（从不足10页到130页），这时约束和验证规则才变得具体起来。下面从整体上看，验证阶段大致会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
<h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a><strong>文件格式验证</strong></h4><p>第一阶段验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这个阶段可能包括下面这些验证点：</p>
<ul>
<li>是否以魔数0xCAFEBABE（为了方便虚拟机识别文件是否是class格式的文件，JVM规定每个class文件都必须以一个word(4个字节)来开始，这个数字就称为魔数）开头。</li>
<li>主、次版本号是否在当前虚拟机的处理范围之内（魔数后续的内容就是一个word的长度来表示生成的class文件的版本号，版本号分为主版本号和次版本号，其中前两个字节表示次版本号，后两个字节表示主版本号，排列的顺序遵从高位在前，低位在后的原则）。</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。</li>
<li>Class文件中各个部分及文件本身是否有被删除或附加的其他信息。</li>
<li>…..</li>
</ul>
<p>实际上，第一阶段的验证点还远不止这些，上面这些只是从HotSpot虚拟机源码中摘抄的一小部分，<strong>该验证阶段的主要是保证输入的字节流能正确地解析并存储于方法区中，格式上符合描述一个Java类型信息的要求</strong>。<em>这阶段的验证是基于二进制字节流进行的，只有通过这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面3个验证阶段全部都是基于方法区的存储结构进行的，不会再直接操作字节流。</em></p>
<h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a><strong>元数据验证</strong></h4><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，这个阶段可能包括的验证点如下：</p>
<ul>
<li>这个类是否有父类（除了java.lang.Object之外，所有类都应当有父类）。</li>
<li>这个类的父类是否抽象了不允许被继承的类（被final修饰的类）。</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段、出现了不符合规则的方法重载比如方法参数都一样但返回值类型不同等）。</li>
<li>……</li>
</ul>
<p><strong>第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</strong></p>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a><strong>字节码验证</strong></h4><p>第三阶段是整个验证过程中最复杂的一个阶段，<strong>主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</strong>在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如：</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载如本地变量表中。</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li>
<li>保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，只是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</li>
<li>……</li>
</ul>
<p>如果类方法体的字节码没有通过字节码验证，那肯定有问题；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。即使字节码验证之中进行了大量的检验，也不能保证这一点，这里涉及了一个离散数学中很著名的问题“Halting Problem”：通俗的说就是，通过程序去校验程序逻辑是无法做到绝对准确的–不能通过程序准确地检查出程序是否能在有限的时间内结束运行。</p>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a><strong>符号引用验证</strong></h4><p>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接第三阶段—解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性检验，通过需要校验一下内容：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段、方法的访问性（public、default、protectd、private）是否可以被当前类访问。</li>
<li>……</li>
</ul>
<p><strong>符号引用验证的目的是确保解析动作能正常执行</strong>，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p>
<p>对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要的（因为对程序运行期没有影响）阶段。如果所运行的全部代码（包括自己编写的以及第三方的代码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用<code>-Xverify:none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h3><p>准备阶段<strong>是正式为类变量分配内存并且设置类变量初始值的阶段，这些变量所使用的内存将在方法区进行分配</strong>。这个阶段中有2个容易产生混淆的概念需要强调一些，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p>
<blockquote>
<p>public static int value = 123;</p>
</blockquote>
<p>那变量value在准备阶段的初始值是0而不是123，因为这时候尚未开始任何Java方法，而把value赋值为123的<code>putstatic</code>指令是在程序被编译后，存放于类构造器<clint>()方法中，所以把value赋值未123的动作将在初始化阶段才会执行。下表是Java中所有基本数据类型的零值。<br>|数据类型|零值|<br>|:-|:-|<br>|byte|(byte)0|<br>|short|(short)0|<br>|int|0|<br>|long|0L|<br>|float|0.0f|<br>|double|0.0d|<br>|char|’\u0000’|<br>|boolean|false|<br>|reference|null|</clint></p>
<p>上面提到，在“通常情况”下，初始值是零值，相对的“特殊情况”就是：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就回被初始化为ConstantValue属性所指定的值，假如有：</p>
<blockquote>
<p>public static <strong>final</strong> int value = 123;</p>
</blockquote>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值未123.</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a><strong>解析</strong></h3><p>解析阶段是<strong>虚拟机将常量池内的符号引用替换为直接引用的过程</strong>。那解析阶段中的所说的直接引用与符号引用有什么关联呢？</p>
<ul>
<li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时无歧义地定位到目标即可。<strong>符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中</strong>。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</li>
<li>直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。<strong>直接引用是和虚拟机实现的内存布局相关的</strong>，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。<strong>如果有了直接引用，那引用的目标必定已经存在内存中</strong>。</li>
</ul>
<p>虚拟机规范并未规定解析阶段发生的具体时间，只要求在执行</p>
<blockquote>
<p>anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield、putstatic</p>
</blockquote>
<p>这16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p>
<h4 id="类或接口解析"><a href="#类或接口解析" class="headerlink" title="类或接口解析"></a><strong>类或接口解析</strong></h4><p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要一下3个步骤：D（N -&gt; C）</p>
<ol>
<li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或者实现的接口。一旦这个加载过程出现任何异常，解析过程就宣告失败。</li>
<li>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型，那么需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。</li>
<li>如果上面的步骤没有任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IIlegalAccessError异常。</li>
</ol>
<h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a><strong>字段解析</strong></h4><p>要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项中索引中的CONSTANT_Class_info符号引用，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口的符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按如下步骤对C进行后续字段的搜索。</p>
<ol>
<li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符斗鱼目标相匹配的字段，则返回这个字符的直接引用，查找结束。</li>
<li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</li>
</ol>
<p>如果成功返回了直接引用，还要对直接引用进行权限验证，如果没有相应的权限，则会抛出java.lang.IIlegalAccessError异常。</p>
<h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a><strong>类方法解析</strong></h4><p>类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。</p>
<ol>
<li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，搜索结束。</li>
<li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li>
</ol>
<h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a><strong>接口方法解析</strong></h4><p>接口方法解析的第一个步骤与字段解析一样，也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。</p>
<ol>
<li>与类方法解析不同，如果在接口方法表现class_index中索引C是个类而不是接口，就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，搜索结束。</li>
<li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li>
</ol>
<p>由于接口中的所有方法默认都是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lang.IIlegalAccessError异常。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h3><p>类的初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全有虚拟机主导控制。到了初始化阶段，才真正开始执行类中定义的java代码（或者说是字节码）。</p>
<p>在准备阶段，变量已经赋值过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器&lt; clinit &gt;()方法的过程。我们迟点会解析这个方法是如何生成的，but for now，我们先看这个方法执行过程中一些可能会影响程序运行行为的特点和细节，这部分相对比较贴近普通程序开发者。</p>
<ul>
<li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（statci{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，<strong>静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</strong>。如下代码<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        i = <span class="number">0</span>; <span class="comment">// 给变量赋值可以正常编译通过</span></div><div class="line">        System.out.println(i); <span class="comment">// 这句会提示"非法前向引用"错误</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>Test.java:4: 错误: 非法前向引用<br>        System.out.println(i); // 这句会提示”非法向前引用”<br>                           ^<br>1 个错误</p>
</blockquote>
<ul>
<li><code>&lt;clinit&gt;()</code>方法与类的构造函数（或者说是实例构造器<code>&lt;init&gt;()</code>方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此在虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法肯定是java.lang.Object的。</li>
<li><p>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的赋值操作。如下代码，字段B的值是2而不是1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		System.out.println(Sub.B);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</div><div class="line">		<span class="keyword">static</span> &#123;</div><div class="line">			A = <span class="number">2</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</p>
</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法并不需要执行父类的<code>&lt;clinit&gt;()</code>方法。只有当使用父接口中定义的变量时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</li>
<li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要线程阻塞等待，知道活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</li>
</ul>
<hr>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a><strong>类加载器</strong></h2><p>虚拟机团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放在Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<p>类加载器可以说是Java语言创新的一项创新，也是Java语言流行的重要原因之一，它最初是为了满足Java Applet的需求而开发出来的。虽然现在Applet技术基本已经“死亡”，但类加载器却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为Java技术体系中一块重要的基石。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a><strong>类与类加载器</strong></h3><p>类加载器虽然只用于实现类的加载动作，但是它在Java程序中起到的作用却远远不限于类加载阶段。对于任意类，都需要由它的类加载器和这个类本身一同确定其在Java虚拟机中的唯一性，<strong>每一个类加载器，都拥有一个独立的类命名空间</strong>。这句话可以表达得更通俗一些：比较2个类是否“相等”，只有在这2个类是由同一个类加载器加载的前提下才有意义，否则，即使这2个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这2个类必定不相等。</p>
<p>这里所谓的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果。以下代码演示了不同类加载器堆instanceof关键字运算的结果的影响。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 类加载器与instanceof关键字演示</div><div class="line">**/</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">		ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</div><div class="line">					InputStream is = <span class="keyword">this</span>.getClass().getResourceAsStream(fileName);</div><div class="line">					<span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</div><div class="line">						<span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</div><div class="line">					is.read(bs);</div><div class="line">					<span class="keyword">return</span> defineClass(name, bs, <span class="number">0</span>, bs.length);</div><div class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		Object obj = myLoader.loadClass(<span class="string">"ClassLoaderTest"</span>).newInstance();</div><div class="line">		System.out.println(obj.getClass());</div><div class="line">		System.out.println(obj <span class="keyword">instanceof</span> ClassLoaderTest);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<blockquote>
<p>class ClassLoaderTest<br>false</p>
</blockquote>
<p>上面代码构造了一个简单的类加载器，尽管很简单，但是很简单，但是对于这个演示还是够用了。它可以加载与自己在同一路径下的Class文件。我们使用这个类加载器去加载了一个名为”ClassLoaderTest”的类，并实例化了这个类的对象。2行输出中，从第1行我们可以看出，这个对象确实是类ClassLoaderTest实例化出来的对象，但从第2行可以发现，这个对象与ClassLoaderTest做所属类型检查的时候却返回了false，这是因为虚拟机中存在了2个ClassLoaderTest类，一个由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都来自同一个Class文件，但依然是2个独立的类，做对象所属类型检查时结果自然为false。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a><strong>双亲委派模型</strong></h3><p>从Java虚拟机的角度来讲，只存在2种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++实现（这里指的是HotSpot，想MRP、Maxine等虚拟机，整个虚拟机都是由Java编写的，自然Bootstrap ClassLoader也是由Java而不是C++实现。退一步讲，除了HotSpot以外的2个高性能虚拟机JRockit和J9都有一个代表Bootstrap ClassLoader的Java类存在，但是关键方法的实现还是利用JNI回调到C（注意不是C++）的实现上，这个Bootstrap ClassLoader的实例也无法被用户获取到），是虚拟机自身的一部分；另外一种就是所有其他的类加载器，这些类加载器都Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</p>
<p>从开发人员的角度来看，类加载器还可以分的更细致一些，绝大部分程序都会使用到以下3种系统提供的类加载器。</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：前面介绍过，这个类负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录下也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器的时候，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。</li>
<li>扩展类加载器（Extension ClassLoader）：这个加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader）：这个类加载器由<code>sun.misc.Launcher$ApplClassLoader</code>实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，<strong>如果程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</strong>。</li>
</ul>
<p>我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这几种类加载器之间的关系如下图。<br><img src="https://farm6.staticflickr.com/5793/21250745705_5cf57d4632.jpg" alt=""></p>
<p>上图所示的类加载器之间的这种层次关系，称为类加载器的<code>双亲委派模型</code>(Parents Delegation Model)。双亲委派模型要求除了顶层的BC之外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。</p>
<p>类加载器的双亲委派模型在JDK1.2期间被引入并广泛只用于几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，二是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。因此所有的加载请求最终都应该传送到顶层的BC中，只有当父类加载器反馈自己无法完成加载时（它的搜索范围没有找到所需的类），子加载器才会尝试自己去加载。</p>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都是委派给处于顶层的BC进行加载，因此Object类在程序的各个类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，哪系统将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也会变得一片混乱。可以尝试去编写一个与rt.jar类库中已有类重名的Java类，将会发现可以正常编译，但永远无法加载。</p>
<p>双亲委派模型对于保证Java程序的稳定运作很重要，但它的实现却非常简单，实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass()方法中。</p>
<h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a><strong>破坏双亲委派模型</strong></h3><hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>本文介绍了类加载过程的“加载”、“验证”、“准备”、“解析”、“初始化”5个阶段中虚拟机进行了哪些操作，也介绍了类加载器的工作原理及其堆虚拟机的意义。</p>
<hr>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JVM/" rel="tag"># JVM</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/09/08/JVM体系结构(图文版)/" rel="next" title="JVM体系结构(图文版)">
                <i class="fa fa-chevron-left"></i> JVM体系结构(图文版)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/09/10/Tomcat的类加载器架构/" rel="prev" title="Tomcat的类加载器架构">
                Tomcat的类加载器架构 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xl3pd.com1.z0.glb.clouddn.com/daojian2.jpg"
               alt="archerda" />
          <p class="site-author-name" itemprop="name">archerda</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">55</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/archerda" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:luo.archer@gmail.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Email
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载的时机"><span class="nav-number">2.</span> <span class="nav-text">类加载的时机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#被动引用场景-1：通过子类引用父类的静态字段，不会导致子类初始化。"><span class="nav-number">2.1.</span> <span class="nav-text">被动引用场景-1：通过子类引用父类的静态字段，不会导致子类初始化。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#被动引用场景-2：通过数组定义来引用类，不会触发此类的初始化。"><span class="nav-number">2.2.</span> <span class="nav-text">被动引用场景-2：通过数组定义来引用类，不会触发此类的初始化。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#被动引用场景-3：使用父类常量不会触发定义常量的类的初始化"><span class="nav-number">2.3.</span> <span class="nav-text">被动引用场景-3：使用父类常量不会触发定义常量的类的初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载过程"><span class="nav-number">3.</span> <span class="nav-text">类加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加载"><span class="nav-number">3.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证"><span class="nav-number">3.2.</span> <span class="nav-text">验证</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件格式验证"><span class="nav-number">3.2.1.</span> <span class="nav-text">文件格式验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#元数据验证"><span class="nav-number">3.2.2.</span> <span class="nav-text">元数据验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字节码验证"><span class="nav-number">3.2.3.</span> <span class="nav-text">字节码验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#符号引用验证"><span class="nav-number">3.2.4.</span> <span class="nav-text">符号引用验证</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#准备"><span class="nav-number">3.3.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析"><span class="nav-number">3.4.</span> <span class="nav-text">解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类或接口解析"><span class="nav-number">3.4.1.</span> <span class="nav-text">类或接口解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字段解析"><span class="nav-number">3.4.2.</span> <span class="nav-text">字段解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类方法解析"><span class="nav-number">3.4.3.</span> <span class="nav-text">类方法解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口方法解析"><span class="nav-number">3.4.4.</span> <span class="nav-text">接口方法解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">3.5.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载器"><span class="nav-number">4.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类与类加载器"><span class="nav-number">4.1.</span> <span class="nav-text">类与类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双亲委派模型"><span class="nav-number">4.2.</span> <span class="nav-text">双亲委派模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#破坏双亲委派模型"><span class="nav-number">4.3.</span> <span class="nav-text">破坏双亲委派模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">archerda</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
